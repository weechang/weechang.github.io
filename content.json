{"meta":{"title":"耒耒耒耒耒","subtitle":"张未的技术博客","description":"本站是Java程序猿耒耒耒耒耒（张未）的个人技术博客。内容涵盖Java后端技术、AxonFrameWork、领域驱动、DDD、CQRS、微服务架构、系统监控等相关的研究与知识分享。","author":"张未","url":"https://blog.weechang.xyz"},"pages":[{"title":"关于","date":"2018-09-30T08:27:35.355Z","updated":"2018-09-30T08:27:35.332Z","comments":true,"path":"about/index.html","permalink":"https://blog.weechang.xyz/about/index.html","excerpt":"","text":"简介我是耒(lěi)耒耒耒耒（张未）。欢迎来到我的个人技术博客。目前主要做Java后端开发，同时兼顾一些Vue页面的开发，对领域驱动较为感兴趣。专业技能 Mysql：★★★★★★☆☆☆☆ Java：★★★★★★★★☆☆ Vue：★★★★★★☆☆☆☆ PS：★★★☆☆☆☆☆☆☆ 附加技能 手工达人：★★★★★★★★★★ 健 身：★★★★★★☆☆☆☆ 摄 影：★★★★☆☆☆☆☆☆ 意见反馈若本站内容有做得不到位的地方（如：涉及版权等问题），请联系我进行整改。联系方式邮箱：zhangwei_sc@foxmail.com微信：zw591961493QQ：591961493"},{"title":"工具库","date":"2018-09-29T06:18:19.097Z","updated":"2018-09-29T06:18:19.025Z","comments":true,"path":"tools/index.html","permalink":"https://blog.weechang.xyz/tools/index.html","excerpt":"","text":"该页面乃我浪迹网络多年，搜集整理而出的，感觉比较有用的一些工具集合。留给自己，也献给需要用到的朋友，希望能够对各位有所帮助。另外有任何好的网站或工具，也可以在评论区下方留言，供其他朋友使用。"},{"title":"AxonFramework-内容汇总","date":"2018-09-29T09:39:18.944Z","updated":"2018-09-29T09:39:18.914Z","comments":true,"path":"topic/AxonFramework-内容汇总/index.html","permalink":"https://blog.weechang.xyz/topic/AxonFramework-内容汇总/index.html","excerpt":"该系列文章为AxonFrameWork内容汇总，主要用于汇总AxonFrameWork方面的内容，会不定时更新。","text":"该系列文章为AxonFrameWork内容汇总，主要用于汇总AxonFrameWork方面的内容，会不定时更新。简介AxonFramework简介基础概念AxonFramework架构概述AxonFramework消息、命令和事件AxonFramework工作单元"},{"title":"Hexo博客","date":"2018-09-29T09:14:20.452Z","updated":"2018-09-29T09:14:20.423Z","comments":true,"path":"topic/Hexo博客/index.html","permalink":"https://blog.weechang.xyz/topic/Hexo博客/index.html","excerpt":"用过了较多博客系统，如CSDN，开源中国，博客园等，一直不太满意。CSDN的巨慢，而且现在开始要求绑定各种信息，感觉有些无力吐槽吧。开源中国一直还不错，动弹挺好的，但是大家都在上面划水了，博客流量确实很一般。博客园呢，个人感觉目前还比较纯粹吧。但是还是有点丑，界面有些跟不上时代的步伐了。所以思来想去为了装逼，还是要搞一个自己的博客系统（其实还是为了装逼，没有个自己的博客系统，总感觉逼格不够）。于是开始选择用hexo + github方式搞自己的博客系统。开此专题，和大家一起分享一下自己搞博客的心得与遇到的坑。","text":"用过了较多博客系统，如CSDN，开源中国，博客园等，一直不太满意。CSDN的巨慢，而且现在开始要求绑定各种信息，感觉有些无力吐槽吧。开源中国一直还不错，动弹挺好的，但是大家都在上面划水了，博客流量确实很一般。博客园呢，个人感觉目前还比较纯粹吧。但是还是有点丑，界面有些跟不上时代的步伐了。所以思来想去为了装逼，还是要搞一个自己的博客系统（其实还是为了装逼，没有个自己的博客系统，总感觉逼格不够）。于是开始选择用hexo + github方式搞自己的博客系统。开此专题，和大家一起分享一下自己搞博客的心得与遇到的坑。Hexo系列六元一个的私有博客系统，了解一下？为你的博客添加版权说一说我所用到的hexo插件SEO系列"},{"title":"Java学习之从头开始","date":"2018-10-08T02:48:56.976Z","updated":"2018-10-08T02:48:56.976Z","comments":true,"path":"topic/Java学习之从头开始/index.html","permalink":"https://blog.weechang.xyz/topic/Java学习之从头开始/index.html","excerpt":"毕业两年了，一直做Java相关的开发工作。感觉自己做过的项目也不少，大的、小的都有，传统的，互联网的都不缺。同时也看过不少博客文章，订阅了不少公众号。但是始终感觉自己提升有限，于是决定从基础开始，进行一遍系统的学习。通过博客的方式记录自己的学习计划、进度及心得总结。希望能够提升自己。","text":"毕业两年了，一直做Java相关的开发工作。感觉自己做过的项目也不少，大的、小的都有，传统的，互联网的都不缺。同时也看过不少博客文章，订阅了不少公众号。但是始终感觉自己提升有限，于是决定从基础开始，进行一遍系统的学习。通过博客的方式记录自己的学习计划、进度及心得总结。希望能够提升自己。Java基础java基础-0——Object类java基础-1——String类Java集合Java集合-0——HashMap类Java集合-1——HashTable类Java多线程Java多线程-0——基础概念Java多线程-1——Java中如何实现多线程Java多线程-2——Thread中run()和start()的区别"}],"posts":[{"title":"哈希算法究竟是个什么鬼","slug":"hash","date":"2018-10-19T05:28:01.000Z","updated":"2018-10-19T10:10:07.452Z","comments":true,"path":"2018/10/19/hash/","link":"","permalink":"https://blog.weechang.xyz/2018/10/19/hash/","excerpt":"一直以来写博客都是抱着给别人看的心态写的，其实，别人看了又怎样，重要的是自己写的过程。这几天终于想明白了这个道理，但是博客该有的套路还是得一个不少的加上。最近感觉写Java方面的知识有些厌倦了，于是干脆写点自己想写的。","text":"一直以来写博客都是抱着给别人看的心态写的，其实，别人看了又怎样，重要的是自己写的过程。这几天终于想明白了这个道理，但是博客该有的套路还是得一个不少的加上。最近感觉写Java方面的知识有些厌倦了，于是干脆写点自己想写的。曾经面试被问到过哈希算法，而曾经的我什么都不懂，就在那儿乱扯一通，现在看来那个时候的自己真的好笑。于是准备补上这个坑，搜集汇总哈希算法的相关只是于此。一、前言我们如何比较两个文件是否一致呢？将文件读成二进制流，然后比较两个文件的二进制流？如果二进制流一开始就不一样还好说，或者是文件小都好说。但是如果是大文件呢？如果文件最后几位二进制不一样，这怎么办？耗时太久。这个时候我们就需要一个高效而可靠办法，给每个文件一个唯一的ID，然后直接比较两个ID，这貌似是一个不错的方法。嗯，想一想很不错。但是如何确定两个文件的ID不同呢？这时候就可以用到HASH方法了。二、简介散列算法（Hash Algorithm），又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。三、应用哈希算法，目前在信息安全领域主要用到以下几个方面：文件校验我们常见的很多文件下载的时候，除了能够下载具体的文件外，还有很多会给出文件的MD5码。这就是用于文件校验使用的。因为在传统的加密渠道中，我们只能对文件传输过程中的信道进行容错处理，但是不能对抗恶意的文件篡改问题。所以如果有了MD5码，我们就能够通过MD5码，校验我们收到的问题件是否是未经篡改的文件。数字签名Hash 算法也是现代password体系中的一个重要组成部分。因为非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。 对 Hash 值，又称”数字摘要”进行数字签名，在统计上能够觉得与对文件本身进行数字签名是等效的。鉴权协议当数据在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。四、实现Hash算法最主要的目的就是为了将一个大范围映射到一个小范围。将大范围映射到小范围是为了节省空间。另外，还要使Hash值足够唯一，这样ID才具有唯一性。除此之外，Hash算法还得具有单向性。具体说来，Hash算法应该具有以下几个限制点：Hash的主要原理就是把大范围映射到小范围；所以，你输入的实际值的个数必须和小范围相当或者比它更小。不然冲突就会非常多。Hash逼近单向函数；所以，你能够用它来对数据进行加密。不同的应用对Hash函数有着不同的要求；比方，用于加密的Hash函数主要考虑它和单项函数的差距，而用于查找的Hash函数主要考虑它映射到小范围的冲突率。明白了这几点，我们就能够对Hash函数的实现做一些了解了。总的说来，目前主流的Hash算法有以下几种实现方法：1. 加法Hash所谓的加法Hash就是把输入元素一个一个的加起来构成最后的结果。标准的加法Hash的构造例如以下：123456static int additiveHash(String key, int prime)&#123; int hash, i; for (hash = key.length(), i = 0; i &lt; key.length(); i++) hash += key.charAt(i); return (hash % prime);&#125;这里的prime是随意的质数，看得出，结果的值域为[0,prime-1]。2. 位运算Hash这类型Hash函数通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素。比方，标准的旋转Hash的构造例如以下：123456static int rotatingHash(String key, int prime) &#123; int hash, i; for (hash=key.length(), i=0; i&lt;key.length(); ++i) hash = (hash&lt;&lt;4)^(hash&gt;&gt;28)^key.charAt(i); return (hash % prime); &#125;先移位，然后再进行各种位运算是这样的类型Hash函数的主要特点。比方，以上的那段计算hash的代码还能够有例如以下几种变形：1hash = (hash&lt;&lt;5)^(hash&gt;&gt;27)^key.charAt(i);123hash += key.charAt(i);hash += (hash &lt;&lt; 10);hash ^= (hash &gt;&gt; 6);12345if((i&amp;1) == 0)&#123; hash ^= (hash&lt;&lt;7) ^ key.charAt(i) ^ (hash&gt;&gt;3);&#125; else &#123; hash ^= ~((hash&lt;&lt;11) ^ key.charAt(i) ^ (hash &gt;&gt;5));&#125;1hash += (hash&lt;&lt;5) + key.charAt(i);1hash = key.charAt(i) + (hash&lt;&lt;6) + (hash&gt;&gt;16) – hash;1hash ^= ((hash&lt;&lt;5) + key.charAt(i) + (hash&gt;&gt;2));3. 乘法Hash这种类型的Hash函数利用了乘法的不相关性（乘法的这种性质，最有名的莫过于平方取头尾的随机数生成算法，虽然这种算法效果并不好）。比如，1234567static int bernstein(String key) &#123; int hash = 0; int i; for (i=0; i&lt;key.length(); ++i) hash = 33*hash + key.charAt(i); return hash;&#125;jdk5.0里面的String类的hashCode()方法也使用乘法Hash。不过，它使用的乘数是31。推荐的乘数还有：131, 1313, 13131, 131313等等。使用这种方式的著名Hash函数还有：32位FNV算法123456789int M_SHIFT = 0;public int FNVHash(byte[] data) &#123; int hash = (int)2166136261L; for(byte b : data) hash = (hash * 16777619) ^ b; if (M_SHIFT == 0) return hash; return (hash ^ (hash &gt;&gt; M_SHIFT)) &amp; M_MASK;&#125;以及改进的FNV算法：123456789101112public static int FNVHash1(String data) &#123; final int p = 16777619; int hash = (int)2166136261L; for(int i=0;i&lt;data.length();i++) hash = (hash ^ data.charAt(i)) * p; hash += hash &lt;&lt; 13; hash ^= hash &gt;&gt; 7; hash += hash &lt;&lt; 3; hash ^= hash &gt;&gt; 17; hash += hash &lt;&lt; 5; return hash;&#125;除了乘以一个固定的数，常见的还有乘以一个不断改变的数，比如：12345678910static int RSHash(String str)&#123; int b = 378551; int a = 63689; int hash = 0; for(int i = 0; i &lt; str.length(); i++)&#123; hash = hash * a + str.charAt(i); a = a * b; &#125; return (hash &amp; 0x7FFFFFFF);&#125;虽然Adler32算法的应用没有CRC32广泛，不过，它可能是乘法Hash里面最有名的一个了。关于它的介绍，大家可以去看RFC 1950规范。4. 除法Hash除法和乘法一样，同样具有表面上看起来的不相关性。不过，因为除法太慢，这种方式几乎找不到真正的应用。需要注意的是，我们在前面看到的hash的 结果除以一个prime的目的只是为了保证结果的范围。如果你不需要它限制一个范围的话，可以使用如下的代码替代”hash%prime”：1hash = hash ^ (hash&gt;&gt;10) ^ (hash&gt;&gt;20)5. 查表Hash查表Hash最有名的样例莫过于CRC系列算法。尽管CRC系列算法本身并非查表，可是，查表是它的一种最快的实现方式。以下是CRC32的实现：12345678910111213141516171819202122232425262728293031323334353637383940static int crctab[256] = &#123;0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d&#125;;int crc32(String key, int hash) &#123; int i; for (hash=key.length(), i=0; i&lt;key.length(); ++i) hash = (hash &gt;&gt; 8) ^ crctab[(hash &amp; 0xff) ^ k.charAt(i)]; return hash;&#125;查表Hash中有名的样例有：Universal Hashing和Zobrist Hashing。他们的表格都是随机生成的。6. 混合Hash混合Hash算法利用了以上各种方式。各种常见的Hash算法，比如MD5、Tiger都属于这个范围。它们一般很少在面向查找的Hash函数里面使用。7. 数组Hash12345678inline int hashcode(const int *v) &#123; int s = 0; for(int i=0; i&lt;k; i++) s=((s&lt;&lt;2)+(v[i]&gt;&gt;4))^(v[i]&lt;&lt;10); s = s % M; s = s &lt; 0 ? s + M : s; return s;&#125;五、碰撞通过前面说到的几种Hash算法的实现，我们可以发现，Hash算法虽然很多好，但是无法保证两个片段产生的Hash值不能重复。Hash算法产生冲突的情况，称之为Hash冲突，也称之为Hash碰撞。通过构造性能良好的Hash算法，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是Hash算法的另一个关键问题。目前解决Hash冲突的主流方法大概有以下几种：1. 开放寻址法(再散列法)开放寻址法的基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：Hi=（H（key）+di）% m i=1，2，…，n其中H（key）为哈希函数，m 为表长，di称为增量序列。2. 再哈希法这种方法的基本思想是：同时构造多个不同的哈希函数：Hi=RH1（key） i=1，2，…，k当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。3. 链地址法（拉链法）这种方法的基本思想是：将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。4. 建立公共溢出区这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。目前用的比较多的就是 开放寻址法 和 拉链法 ,针对 开放寻址法 和 拉链法 其具体的优缺点如下：拉链法优点：1.避免了动态调整的开销2.由于底层是链表结构，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了3.同样也是因为链表结构，删除记录时，比较方便，直接通过指针操作即可缺点：1.由于链表结构，所以查询比较耗时2.由于链表结构，不利于序列化操作开放寻址法优点1.记录更容易进行序列化（serialize）操作缺点1.存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升2.使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低3.由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费4.删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。总结：拉链法适合数据量不可预知，且写入多，查询少的情况。开放寻址法适合数据量可预知，查询多，写入少的情况。在传统的JDK中，采用的都是拉链法，自JDK1.8起，对拉链法做了改造。当链表长度超过预定值后将采用红黑树结构替代链表结构，这样对查询操作做了更好的优化。具体可参考我之前写的关于HashMap的文章 Java集合-0——HashMap类PS: 文中对Hash算法实现的代码均源于网络，若有侵权，请联系删除 原文链接","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://blog.weechang.xyz/categories/算法与数据结构/"}],"tags":[{"name":"哈希算法","slug":"哈希算法","permalink":"https://blog.weechang.xyz/tags/哈希算法/"},{"name":"算法","slug":"算法","permalink":"https://blog.weechang.xyz/tags/算法/"}]},{"title":"【Java学习之从头开始】Java多线程-3——synchronized是如何工作的","slug":"java-thread-03-synchronized","date":"2018-10-03T14:15:42.000Z","updated":"2018-10-08T02:48:56.975Z","comments":true,"path":"2018/10/03/java-thread-03-synchronized/","link":"","permalink":"https://blog.weechang.xyz/2018/10/03/java-thread-03-synchronized/","excerpt":"这是我Java多线程的第四篇博文了。本来计划一天一更的，但是国庆假期，都浪去了，没坚持更新。今天主要讲讲在Java多线程中，synchronized是如何工作的。","text":"这是我Java多线程的第四篇博文了。本来计划一天一更的，但是国庆假期，都浪去了，没坚持更新。今天主要讲讲在Java多线程中，synchronized是如何工作的。synchronized 原理在Java中，每一个对象有且仅有一个同步锁。即同步锁是依赖于对象而存在。当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。且不同线程对同步锁的访问是互斥的。synchronized 基本规则synchronized 遵循以下三条规则：一、当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。二、当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。三、当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。synchronized 的几种使用方法在Java中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 既可以加在一段代码上，也可以加在方法上。下面将仔细了解 synchronized 关键字的几种使用方法。synchronized 作用于实例方法synchronized 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。正确示列：12345678910111213141516171819202122232425public class InstanceSync implements Runnable &#123; static int i = 0; public synchronized void syncCount() &#123; i++; &#125; public void run() &#123; for (int j = 0; j &lt; 100000; j++) &#123; syncCount(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; InstanceSync instance = new InstanceSync(); Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); &#125;&#125;运行结果:1200000错误示例：123456789101112131415161718192021222324public class InstanceSyncBad implements Runnable&#123; static int i = 0; public synchronized void syncCount() &#123; i++; &#125; public void run() &#123; for (int j = 0; j &lt; 100000; j++) &#123; syncCount(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(new InstanceSyncBad()); Thread t2 = new Thread(new InstanceSyncBad()); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); &#125;&#125;运行结果：1175000代码分析 ：上面两个例子中，第一个获得了我们预期结果，第二个未获得预期结果。说明在第二个例子中 synchronized 方法出现了问题，因为第二个例子中， t1 和 t2 锁住的不是同一个对象。在t1、t2中变量是不共享的。解决这个问题的办法是，让 synchronized 锁住 静态方法。实例锁：锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。实例锁对应的就是synchronized关键字。（即修饰实例方法的锁）synchronized 作用于静态方法synchronized 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。12345678910111213141516171819202122232425262728public class StaticSync implements Runnable &#123; static int i=0; public static synchronized void increase()&#123; i++; &#125; public void run() &#123; for(int j=0;j&lt;100000;j++)&#123; increase(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 新实例 Thread t1=new Thread(new StaticSync()); Thread t2=new Thread(new StaticSync()); // 启动线程 t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); &#125;&#125;运行结果：1200000代码分析：该实例中，synchronized 锁住的是静态方法，与锁住实例方法不一样。锁住静态方法，就相当于锁住整个类。全局锁：该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）（即修饰静态方法的锁）。synchronized 作用于代码块synchronized 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。123456789101112131415161718192021222324public class BlockSync implements Runnable &#123; static BlockSync instance = new BlockSync(); static int i = 0; public void run() &#123; //使用同步代码块对变量i进行同步操作,锁对象为instance synchronized (instance) &#123; for (int j = 0; j &lt; 100000; j++) &#123; i++; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); &#125;&#125;运行结果：1200000","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"https://blog.weechang.xyz/categories/Java多线程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.weechang.xyz/tags/Java/"},{"name":"Java多线程","slug":"Java多线程","permalink":"https://blog.weechang.xyz/tags/Java多线程/"}]},{"title":"【Java学习之从头开始】Java多线程-2——Thread中run()和start()的区别","slug":"java-thread-02-run-start","date":"2018-10-02T10:12:03.000Z","updated":"2018-10-08T02:48:56.974Z","comments":true,"path":"2018/10/02/java-thread-02-run-start/","link":"","permalink":"https://blog.weechang.xyz/2018/10/02/java-thread-02-run-start/","excerpt":"前一篇博文中，我们讨论了Java中多线程的常用实现方式及Thread和Runnable的区别。在本篇，我们将讨论Thread中run()和start()的区别。","text":"前一篇博文中，我们讨论了Java中多线程的常用实现方式及Thread和Runnable的区别。在本篇，我们将讨论Thread中run()和start()的区别。实现下面我们将通过代码来实现，两者的调用。并展示两者区别12345678910111213141516171819202122232425public class RunAndStart &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(&quot;test&quot;); System.out.println(&quot;*** myThread run method&quot;); myThread.run(); System.out.println(&quot;*** myThread start method&quot;); myThread.start(); &#125;&#125;class MyThread extends Thread&#123; public MyThread(String name)&#123; super(name); &#125; @Override public void run()&#123; System.out.println(&quot;my name is &quot; + Thread.currentThread().getName()); &#125;&#125;其运行结果如下：1234*** myThread run methodmy name is main*** myThread start methodmy name is test对以上运行结果呢，我做一下解释：Thread.currentThread().getName()是用于获取“当前线程”的名称。myThread.run()是在“主线程main()”中调用的，该run()方法直接运行在“主线程main()”上。myThread.start()会启动“线程myThread”，“线程myThread”启动之后，会调用run()方法。区别从以上代码的运行结果我们可以看到run() 和 start() 的区别：start() : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用（该处我没给出具体代码，感兴趣的同学可以自行验证）。run() : run()就和普通的成员方法一样，直接调用的话会在当前线程中执行run()，而并不会启动新线程。且能多次重复调用。源码实现start()1234567891011121314151617181920212223242526public synchronized void start() &#123; // 检查线程启动状态 // 如果不是就绪状态，则抛出异常 if (threadStatus != 0) throw new IllegalThreadStateException(); // 将当前线程，加入group中 group.add(this); boolean started = false; try &#123; // 通过本地方法 start0 启动线程 start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125;&#125;private native void start0();源码解释： 在调用start方法的时候，其实是通过本地方法start0() 来启动的。通过start0() 创建一个新的线程，且调用run()执行。run()12345public void run() &#123; if (target != null) &#123; target.run() &#125;&#125;源码解析: 直接调用目标对象的 run() 方法，并不会创建新线程。PS：此章节内容相关源码已上传至GitHub","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"https://blog.weechang.xyz/categories/Java多线程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.weechang.xyz/tags/Java/"},{"name":"Java多线程","slug":"Java多线程","permalink":"https://blog.weechang.xyz/tags/Java多线程/"}]},{"title":"【Java学习之从头开始】Java多线程-1——Java中如何实现多线程","slug":"java-thread-01-implements-thread","date":"2018-09-30T16:08:39.000Z","updated":"2018-10-08T02:48:56.974Z","comments":true,"path":"2018/10/01/java-thread-01-implements-thread/","link":"","permalink":"https://blog.weechang.xyz/2018/10/01/java-thread-01-implements-thread/","excerpt":"上一节，学习了Java多线程的基本概念，接下来就要正式进入多线程的学了。首先学习的是，在Java中如何实现一个多线程。","text":"上一节，学习了Java多线程的基本概念，接下来就要正式进入多线程的学了。首先学习的是，在Java中如何实现一个多线程。简介Java中主要通过 Thread 和 Runnable 两种方式来实现多线程。另外通过JUC中的线程池也能实现线程，该方法暂时不在我的学习范围之内。关于 Thread 和 RunnableRunnable 是一个接口。其中只定义了一个 run() 方法。12345@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125;Thread 是一个Java类。是通过实现Runnable而成。1public class Thread implements Runnable &#123;&#125;我们可以通过实现Runnable接口来实现一个多线程。利用Thread方法，可以直接实现多线程。下面我们将通过具体的例子说明如何实现多线程。通过 Thread 实现多线程1234567891011121314151617181920212223242526272829303132public class ImplementThread &#123; public static void main(String[] args) &#123; ImplementThread implementThread = new ImplementThread(); implementThread.byThread(); &#125; /** * 继承 Thread 方式 */ public void byThread()&#123; MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); t1.start(); t2.start(); &#125;&#125;class MyThread extends Thread &#123; private int count = 10; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (this.count &gt; 0) &#123; System.out.println(this.getName() + &quot; 计数器：count&quot; + this.count--); &#125; &#125; &#125;&#125;运行结果1234567891011121314151617181920Thread-1 计数器：count10Thread-0 计数器：count10Thread-1 计数器：count9Thread-0 计数器：count9Thread-1 计数器：count8Thread-0 计数器：count8Thread-1 计数器：count7Thread-0 计数器：count7Thread-1 计数器：count6Thread-0 计数器：count6Thread-1 计数器：count5Thread-0 计数器：count5Thread-1 计数器：count4Thread-0 计数器：count4Thread-1 计数器：count3Thread-0 计数器：count3Thread-0 计数器：count2Thread-0 计数器：count1Thread-1 计数器：count2Thread-1 计数器：count1通Thread继承方式，我们发现。MyThread 继承自Thread 是一个自定义线程。在主线程main()中，创建并启动了2个子线程，这两个子线程分别计数10次。通过 Runnable 实现多线程12345678910111213141516171819202122232425262728293031323334public class ImplementThread &#123; public static void main(String[] args) &#123; ImplementThread implementThread = new ImplementThread(); implementThread.byRunnable(); &#125; /** * 实现 Runnable方式 */ public void byRunnable()&#123; MyRunnable myRunnable = new MyRunnable(); Thread t1 = new Thread(myRunnable); Thread t2 = new Thread(myRunnable); t1.start(); t2.start(); &#125;&#125;class MyRunnable implements Runnable&#123; private int count = 10; public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (this.count &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; 计数器：count&quot; + this.count--); &#125; &#125; &#125;&#125;运行结果12345678910Thread-0 计数器：count10Thread-1 计数器：count9Thread-0 计数器：count8Thread-0 计数器：count6Thread-0 计数器：count5Thread-1 计数器：count7Thread-0 计数器：count4Thread-0 计数器：count2Thread-1 计数器：count3Thread-0 计数器：count1通过Runnable方式我们可以发现，主线程main()中虽然启动了2个线程。但是这2个线程一共计数10次。说明这两个线程是基于MyRunnable共享的。Thread 与 Runnable的异同相同点：都是一种多线程的实现方式。不同点：1) Thread 是 类， Runnable 是接口；2) “一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性；3) Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。建议使用Runnable去实现多线程关于Thread的补充在很多博客上看到说，Runnable 相较于 Tread 能够实现资源共享，没有一个好的解释。就我上面的例子而言。可以看出Thread 与 Runnable 的写法不同。有些人肯定会心存疑虑。所以在此，我对 Thread 的 写法做另一种补充以证清白。123456789101112131415161718192021222324252627282930313233343536public class ImplementThread &#123; public static void main(String[] args) &#123; ImplementThread implementThread = new ImplementThread(); implementThread.byThread2(); &#125; /** * Thread 资源不共享的补充说明 */ public void byThread2()&#123; MyThread myThread = new MyThread(); Thread t1 = new Thread(myThread); Thread t2 = new Thread(myThread); t1.start(); t2.start(); &#125;&#125;class MyThread extends Thread &#123; private int count = 10; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (this.count &gt; 0) &#123; System.out.println(this.getName() + &quot; 计数器：count&quot; + this.count--); &#125; &#125; &#125;&#125;通过和 Runnable一样的启动方式启动Thread 多线程。运行结果12345678910Thread-0 计数器：count10Thread-0 计数器：count9Thread-0 计数器：count8Thread-0 计数器：count6Thread-0 计数器：count5Thread-0 计数器：count4Thread-0 计数器：count7Thread-0 计数器：count3Thread-0 计数器：count2Thread-0 计数器：count1从上述结果可以看到，在main()主线程中，只有一个线程的运行结果。这是为什么呢，因为Thread 一旦被start() 就没法再次start()。若想同时启动多个 Thread 只能创建多个不同的Thread实例。但是多个不同Thread 实例中，资源是不共享的。本博客代码已托管到github","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"https://blog.weechang.xyz/categories/Java多线程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.weechang.xyz/tags/Java/"},{"name":"Java多线程","slug":"Java多线程","permalink":"https://blog.weechang.xyz/tags/Java多线程/"}]},{"title":"【Java学习之从头开始】Java多线程-0——基础概念","slug":"java-thread-00-base","date":"2018-09-30T08:59:22.000Z","updated":"2018-09-30T09:31:59.507Z","comments":true,"path":"2018/09/30/java-thread-00-base/","link":"","permalink":"https://blog.weechang.xyz/2018/09/30/java-thread-00-base/","excerpt":"Java多线程，一直是Java里面一个绕不去的坎，对程序员的要求比较高。同时，得益于Java社区的日益强健，Java框架也随之丰富起来了，特别是Web框架。所以大多数做Web的程序员，都是拿来就用，我就是其中一员。Web中几乎不用程序员自身去操作多线程，所以这也就导致了大多数的Java Web程序员多线程方面较为薄弱。为了解决这一问题，下定决心学习Java多线程，同时记录自己的学习过程，以供日后翻阅。","text":"Java多线程，一直是Java里面一个绕不去的坎，对程序员的要求比较高。同时，得益于Java社区的日益强健，Java框架也随之丰富起来了，特别是Web框架。所以大多数做Web的程序员，都是拿来就用，我就是其中一员。Web中几乎不用程序员自身去操作多线程，所以这也就导致了大多数的Java Web程序员多线程方面较为薄弱。为了解决这一问题，下定决心学习Java多线程，同时记录自己的学习过程，以供日后翻阅。线程与进程线程与进程一直是相互关联，而又完全不同的两个概念。其不同在于：线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位）其关联性在于：1、一个进程可以有多个线程，但至少有一个线程；而一个线程只能在一个进程的地址空间内活动。2、资源分配给进程，同一个进程的所有线程共享该进程所有资源。3、CPU分配给线程，即真正在处理器运行的是线程。4、线程在执行过程中需要协作同步，不同进程的线程间要利用消息通信的办法实现同步。线程的状态Java中线程的状态分为五个阶段：1、新建状态(New)： 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。2、就绪状态(Runnable)： 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。3、运行状态(Running)： 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。4、阻塞状态(Blocked)： 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：01) 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。02) 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。03) 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。5、死亡状态(Dead)： 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。五种状态的转换关系如下：更多关于线程的知识将在后续章节中，详细介绍，敬请期待……","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"https://blog.weechang.xyz/categories/Java多线程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.weechang.xyz/tags/Java/"},{"name":"Java多线程","slug":"Java多线程","permalink":"https://blog.weechang.xyz/tags/Java多线程/"}]},{"title":"一个关于FastJson的高危漏洞","slug":"fastjson-bug","date":"2018-09-29T16:12:22.000Z","updated":"2018-09-30T01:42:05.098Z","comments":true,"path":"2018/09/30/fastjson-bug/","link":"","permalink":"https://blog.weechang.xyz/2018/09/30/fastjson-bug/","excerpt":"最近了解到一个关于FastJson的高危漏洞，在此列出来，给各位开发者提个醒。希望有用到该版本的开发者，及时升级版本，避免受到影响。","text":"最近了解到一个关于FastJson的高危漏洞，在此列出来，给各位开发者提个醒。希望有用到该版本的开发者，及时升级版本，避免受到影响。具体漏洞情况如下，当FastJson版本低于1.2.49时，将json字符串泛解析为java对象的时候，在某些特定值的情况下。会导致长时间的阻塞（根据具体的CPU计算性能决定，时间长达几分钟）cup占用率飙升。涉及到的地方包括：1.调用JSON.parseObject()方法。2.使用@RequestBody 并且 HttpMessageConverter 为FastJson 的时候。且导致这一现象的代价微乎其微，效果堪比DDOS，由于该漏洞的具体细节，目前只是在小范围内传播，而且涉及范围过广，所以在此我也就不公布具体的漏洞细节了。官方已在1.2.49及以后的版本中修复这一漏洞。希望有用到1.2.49以下版本的同学尽快升级","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.weechang.xyz/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.weechang.xyz/tags/Java/"},{"name":"FastJson高危漏洞","slug":"FastJson高危漏洞","permalink":"https://blog.weechang.xyz/tags/FastJson高危漏洞/"}]},{"title":"说一说我所用到的hexo插件","slug":"hexo-plugins","date":"2018-09-29T06:52:20.000Z","updated":"2018-09-29T09:20:15.213Z","comments":true,"path":"2018/09/29/hexo-plugins/","link":"","permalink":"https://blog.weechang.xyz/2018/09/29/hexo-plugins/","excerpt":"在我之前的博文中，介绍了如何用hexo搭建一个自己的博客系统。当然只是简单地搭建，还有很多东西需要补全的。今天我就介绍下，hexo常用插件，以此来丰富你的博客功能、改善用户体验。","text":"在我之前的博文中，介绍了如何用hexo搭建一个自己的博客系统。当然只是简单地搭建，还有很多东西需要补全的。今天我就介绍下，hexo常用插件，以此来丰富你的博客功能、改善用户体验。关于如何使用hexo搭建自己的博客系统，感兴趣的同学可以看我之前的文章六元一个的私有博客系统，了解一下？。下面将详细介绍，我的博客中所使用到的一些hexo插件，丰富博客功能、改善用户体验。字数统计插件1npm install hexo-wordcount该插件能够做到统计每一篇文章的字数，以及预估阅读时间。但是如果自身的主题不支持的话，还得自己在主题中添加相关代码。如下12345678910&lt;div class=&quot;article-word-count&quot;&gt;&lt;span&gt; &lt;i class=&quot;fas fa-file-word&quot;&gt;&lt;/i&gt; 共&lt;%= wordcount(post.content) %&gt;字，&lt;/span&gt;&lt;span&gt; &lt;i class=&quot;fas fa-clock&quot;&gt;&lt;/i&gt; 大约需要&lt;%= min2read(post.content) %&gt;分钟&lt;/span&gt;&lt;/div&gt;添加后就能清楚地看到每篇博文的字数，及大概阅读用时了。sitemap 生成插件1npm install hexo-generator-sitemap该插件能够生成网站地图，供搜索引擎蜘蛛爬取所用。百度sitemap生成插件1npm install hexo-generator-baidu-sitemap由于百度蜘蛛的sitemap编写规则与谷歌等有所不同，所以需要针对百度生成一个专门的sitemap，可以使用该插件RSS 源生成插件1npm install hexo-generator-feed值得注意的是，rss源生成查件不仅仅需要安装，还得配置。需要在你的项目 _config.yml 里面添加配置信息12345678# RSS pluginplugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20nofollow 插件1npm install hexo-autonofollownofollow 插件能够给所有非本站的超链接加上 nofollow 标签，nofollow 标签的意义在于 指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重！同时，nofollow插件也需要配置才能生效，同样在你的项目 _config.yml 添加配置1234567#nofollow not includenofollow: enable: true exclude: - blog.unknowns.info - yanhaijing.com - 友链domain百度URL主动提交插件1npm install hexo-baidu-url-submit百度url主动提交的意义在于，及时主动地向搜索引擎提交你站的新增文章url，对于搜索引擎的及时收录有一定的帮助。当然如果是一个高质量的老站，而且蜘蛛爬取频次很快的站的话，就当我没说过这句话吧。需新增配置123456baidu_url_submit: # count表示一次提交几条最新的url count: 1 host: 网站域名 token: 百度站长主动提交处得token path: baidu_urls.txttoken具体查看地址的，百度站长平台-用户中心-站点管理-数据引入-链接提交，token为图中token参数后面的值另外需要，在修改 _config.yml 的deploy配置选项12345678deploy: type: baidu_url_submitter# type: git branch: master repo: coding: https://git.coding.net/weechang93/weechang93.coding.me.git github: https://github.com/weechang/weechang.github.io.git bucket: blog.weechang.xyz其中deploy的type只能同时存在一个，这就需要在部署与提交url之间相互切换了。静态资源压缩插件静态资源压缩插件我知道的有两个，一个是全站压缩，一个是可选压缩，先说可选压缩的吧可选压缩1npm install hexo-neat需要在 _config.yml 增加配置文件1234567891011121314151617181920# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude:# 压缩cssneat_css: enable: true exclude: - &apos;**/*.min.css&apos;# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - &apos;**/*.min.js&apos;需要注意的是，css 及 js压缩需要排除掉已经压缩了的资源。另外需要压缩html就不能排除markdown的压缩。全站压缩1npm install hexo-all-minifier该插件不需要配置，而且不仅能压缩html、css、js 还能压缩图片。所以我选择了这个插件。还有个问题就是，压缩就是为了节省空间，毕竟博客放的github或者coding。两者节点都不在大陆，所以网速是个大问题，这才是我选择后者的关键原因，后者没有版权注释，前者有版权注释，感觉注释也是一种浪费啊。不是说版权不重要。注意，用压缩插件的时候。如果markdown里面有 pre 标签写的代码的话，建议尽快修改。因为这两个压缩插件对于 pre标签里面的java泛型都不是很友好，都会报错。OK，我所用到的hexo插件就介绍到这儿，希望对你有所帮助。","categories":[{"name":"开源之路","slug":"开源之路","permalink":"https://blog.weechang.xyz/categories/开源之路/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.weechang.xyz/tags/Hexo博客/"},{"name":"hexo插件","slug":"hexo插件","permalink":"https://blog.weechang.xyz/tags/hexo插件/"}]},{"title":"为你的博客添加版权","slug":"为你的博客添加版权","date":"2018-09-28T06:48:37.000Z","updated":"2018-09-29T09:28:04.732Z","comments":true,"path":"2018/09/28/为你的博客添加版权/","link":"","permalink":"https://blog.weechang.xyz/2018/09/28/为你的博客添加版权/","excerpt":"自己做自建博客也有一段时间了，有转载别人的博客，也有自己动手写博客。在没做独立博客之前，对版权意识并不是那么重视，也没了解过自己文章的收录情况。","text":"自己做自建博客也有一段时间了，有转载别人的博客，也有自己动手写博客。在没做独立博客之前，对版权意识并不是那么重视，也没了解过自己文章的收录情况。最近为了提高网站的收录量，开始将一些自己原创的博客放到oschina 等博客平台上去。但是发现自己的文章很快就被收录了，然后被别的权重较高的网站转载。结果就是自己辛辛苦苦写的文章为他人做了嫁衣，还没有自己的署名新。于是开始研究为自己文章加上版权信息。人家的hexo博客主题都要自带的版权申明，奈何我的没有，于是只能自己写咯，谁让我要选择这个博客主题呢，谁让我要自己搞独立博客呢。因为之前有过自己在博客主题里面添加信息的经历，所以此次添加就比较简单了。因为我的博客主题页面用的是Ejs模板写的，所以需要先写一个Ejs模板，模板主要写的就是版权的布局内容。copyright.ejs1234567891011121314151617&lt;% if (!index || !post.excerpt) &#123; %&gt; &lt;div class=&quot;post-copyright&quot;&gt; &lt;div class=&quot;author&quot;&gt; &lt;b&gt;本文作者： &lt;/b&gt; post.author &lt;/div&gt; &lt;div class=&quot;link&quot;&gt; &lt;b&gt;本文链接： &lt;/b&gt; &lt;a href=&quot; &lt;%= post.permalink %&gt;&quot; target=&quot;_blank&quot;&gt; &lt;%= post.permalink %&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;copyright&quot;&gt; &lt;b&gt; 版权声明： &lt;/b&gt; 本博客所有文章除特别声明外，均采用 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0 &lt;/a&gt; 许可协议。转载请注明出处！ &lt;/div&gt; &lt;/div&gt;&lt;% &#125; %&gt;然后找到文章的布局模板,我是用的模板，文章布局模板文件是 article.ejs ，将 copyright.ejs 在你想要显示的地方插入。我是添加在文末，标签及分享按钮之前。所以插入位置如下然后通过js文件调试自己的版权布局样式123456.post-copyright padding: 20px background: #F6F6F6 border-left: 4px solid #DDDDDD line-height: 1.6remOk，大功告成。启动预览，点击文章。可以发现文章已经加入了版权信息，好开心啊。这样人家的爬虫爬取你的文章的时候，就会加入你的定制版权信息了。就算转载了你的文章，也能在一定程度上增加你网站的外链。另外，在自己原创文章发布后，可以立即向百度等搜索引擎提交自己的链接，这样对于收录也是有一定的好处的。另外，转载文章不留出处的方式，真的很恶心，希望大家都能尊重人家的劳动成果，加上署名及出处","categories":[{"name":"开源之路","slug":"开源之路","permalink":"https://blog.weechang.xyz/categories/开源之路/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.weechang.xyz/tags/Hexo博客/"},{"name":"版权","slug":"版权","permalink":"https://blog.weechang.xyz/tags/版权/"}]},{"title":"记一次SQL优化","slug":"记一次SQL优化","date":"2018-09-27T06:31:52.000Z","updated":"2018-09-29T07:47:11.418Z","comments":true,"path":"2018/09/27/记一次SQL优化/","link":"","permalink":"https://blog.weechang.xyz/2018/09/27/记一次SQL优化/","excerpt":"最近收到项目的慢查询报警，刚好手上空下来了，就准备做一些优化。特开此贴记录一下此次的优化详情。","text":"最近收到项目的慢查询报警，刚好手上空下来了，就准备做一些优化。特开此贴记录一下此次的优化详情。背景介绍由于项目保密原因，因此很多字段采取保密写法，望各位看官见谅。其实呢，整个表的数据量其实也不大，也就170W+。字段大概在65个左右，除了几个单号，几个内容这种稍大一点的字段外，其他的基本都是状态和关联id的字段。所以行大小也不大。但是，上个月的时候，产品提出一个需要根据单号模糊查询的功能，就是这个功能，导致了慢查询。优化前，根据现有逻辑以及模糊查询的需求，大概的sql是这样的123456789101112131415161718SELECT id, work_order_num AS workOrderNum, content, OTHERS_COLUMNS...FROM work_orderWHERE work_order_num LIKE &apos;%201808221644820%&apos;AND sender_id = 11768AND status IN (2, 1, 0)AND record_status IN (4, 2)AND (locked = 0 OR locked = 2)AND yn = 1ORDER BY create_time DESCLIMIT 0, 10数据分析其中，上述Sql中，条件中的字段 work_order_num、sender_id 都是建了索引的，以下是慢查询统计情况total_count19total_time133.23avg_time7.01max_time7.6426avg_return_rows0.79max_return_rows1avg_examined_rows1695975.47max_examined_rows1734740可以看见的是，慢查询基本都是全表扫描。为什么会这样呢，我具体执行了一下Sql发现，以上条件根本就查不出数据啊。然后修改条件发现，是工单号有问题。该工单号不存在，，，不存在啊。所以导致了全表扫描。调优进行时首先想的是去掉like 特别是like的左匹配，试了一下，去掉左匹配，速度能减少到50%。虽然有效，但是业务不允许这样做。然后考虑的是用instr函数代替like，测试了一下，能够减少1S的时间，但是对于7S的查询来说，这TM有什么效果。还是不行。最后想到了一次案例分享中的，先用子查询查询出符合条件的id，再用id作为筛选条件，去获取所有的列。最后修改后的sql如下12345678910111213141516171819202122232425SELECT id, work_order_num AS workOrderNum, content, OTHERS_COLUMNS...FROM work_orderWHERE id IN ( SELECT id FROM ws_work_order WHERE work_order_num LIKE &apos;%201808221644820%&apos; AND sender_id = 11768 AND STATUS IN (2, 1, 0) AND record_status IN (4, 2) AND (locked = 0 OR locked = 2) AND yn = 1 )ORDER BY create_time DESCLIMIT 0, 10运行一下试试，，，果然，时间减少到了 0.03xxS。看着就有点小激动啊。原理剖析原理呢，暂时忘了，先挖一个坑，等我想起了，再回来填坑。","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://blog.weechang.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://blog.weechang.xyz/tags/日常记录/"},{"name":"MySql","slug":"MySql","permalink":"https://blog.weechang.xyz/tags/MySql/"},{"name":"Sql","slug":"Sql","permalink":"https://blog.weechang.xyz/tags/Sql/"}]},{"title":"论如何优雅地使用爬虫摸鱼","slug":"论如何优雅地使用爬虫摸鱼","date":"2018-09-21T08:05:11.000Z","updated":"2018-09-30T07:29:08.343Z","comments":true,"path":"2018/09/21/论如何优雅地使用爬虫摸鱼/","link":"","permalink":"https://blog.weechang.xyz/2018/09/21/论如何优雅地使用爬虫摸鱼/","excerpt":"最近手上项目空了下来，没什么事做。博客博客不想写，文章文章不想看。于是干脆看点小说吧，但是上班时间，大家都在认认真真敲代码，自己拿出手机看小说又不是很好（其实主要是数据线坏了，在公司没发充电），电脑上浏览器看，更是不行。于是想了想，干脆就自己爬着看吧，把内容打印在IDE的控制台，想一想这波操作就很骚，于是说动就动。","text":"最近手上项目空了下来，没什么事做。博客博客不想写，文章文章不想看。于是干脆看点小说吧，但是上班时间，大家都在认认真真敲代码，自己拿出手机看小说又不是很好（其实主要是数据线坏了，在公司没发充电），电脑上浏览器看，更是不行。于是想了想，干脆就自己爬着看吧，把内容打印在IDE的控制台，想一想这波操作就很骚，于是说动就动。爬虫选择由于本人是一枚正经的Javaer，所以爬虫当然也要用Java咯。Java下也有几款比较好的爬虫软件，如nutch、crawler4j 等。但是我只是爬个网页，看个小说而已啊。于是就选了个Jsoup，直接解析Html信息，从中提取小说内容。其实选择Jsoup还有个原因就是我好歹写过一阵子jQuery，对jQuery语法比较熟悉。因为Jsoup语法与jQuery语法非常一致。开始动工添加maven依赖12345&lt;dependency&gt; &lt;groupId&gt; org.jsoup &lt;/groupId&gt; &lt;artifactId&gt; jsoup &lt;/artifactId&gt; &lt;version&gt; 1.9.2 &lt;/version&gt;&lt;/dependency&gt;爬取页面信息Jsoup的爬取方式十分简单，是通过获取html文档到本地，然后再用jQuery的解析方式做的DOM解析。12345678910111213141516171819202122232425262728293031323334public class BiQuGeCrawler extends AbstractCrawler &#123; @Override public String getPage(String url) &#123; try &#123; page = Jsoup.connect(url).get(); this.getNext(); this.getLast(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return this.getContent(); &#125; @Override protected String getContent()&#123; Element cntEl = page.getElementById(&quot;content&quot;); // 八个空格，（制表符号） return cntEl.text().replaceAll(&quot; &quot;, &quot;\\n&quot;); &#125; protected void getNext() &#123; Element ul = page.getElementsByClass(&quot;page_chapter&quot;).get(0).child(0); Element nextHref = ul.child(2).child(0); nextUrl = nextHref.attr(&quot;abs:href&quot;); &#125; protected void getLast() &#123; Element ul = page.getElementsByClass(&quot;page_chapter&quot;).get(0).child(0); Element lastHref = ul.child(0).child(0); lastUrl = lastHref.attr(&quot;abs:href&quot;); &#125;&#125;获取小说正文内容及前一页、后一页链接等关键信息。设置翻页及退出每次抓取完页面后，监听控制台输入值，进行翻页、退出操作。12345678910111213141516171819202122232425262728293031323334353637383940public class Function &#123; // app配置 private AppConfig config; // 爬虫类 private AbstractCrawler crawler; public Function(String firstUrl)&#123; config = new AppConfig(); crawler = CrawlerFactory.build(config.sourceType); startView(firstUrl); &#125; // 页面浏览 private void startView(String pageUrl)&#123; String content = crawler.getPage(pageUrl); System.out.println(content); this.inputListener(); &#125; // 开始浏览 private void inputListener()&#123; System.out.println(&quot;*************&quot;); System.out.println(&quot;* L 上一页 *&quot;); System.out.println(&quot;* Q 退出 *&quot;); System.out.println(&quot;* 其他 下一页 *&quot;); System.out.println(&quot;*************&quot;); Scanner sc = new Scanner(System.in); String input = sc.nextLine(); if (&quot;l&quot;.equalsIgnoreCase(input))&#123; // 上一页 startView(crawler.lastUrl); &#125; else if (&quot;q&quot;.equalsIgnoreCase(input))&#123; // 退出 &#125; else &#123; // 下一页 startView(crawler.nextUrl); &#125; &#125;&#125;如上，整个摸鱼神器的关键代码就已经完成了，具体的完整代码，可以查看我的github项目Run一下首先配置需要看的小说网页信息及个人操作习惯设置。然后通过运行main方法。即可运行。后续支持OK，到此爬虫已经能够正常爬取小说内容了。并且已经实现翻页、退出等基本功能。后续将支持更多小说来源如 纵横综合网 等网站。以及更多的功能如 日志混淆、 日志格式化 、断点续看 等功能。本文章涉及的代码已托管到github，欢迎各位客官使用https://github.com/weechang/ReadingCrawler","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://blog.weechang.xyz/categories/日常记录/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://blog.weechang.xyz/tags/爬虫/"},{"name":"Jsoup","slug":"Jsoup","permalink":"https://blog.weechang.xyz/tags/Jsoup/"}]},{"title":"IDEA、WebStorm最新永久激活方式","slug":"IDEA、WebStorm最新永久激活方式","date":"2018-09-21T05:22:40.000Z","updated":"2018-09-29T08:37:32.625Z","comments":true,"path":"2018/09/21/IDEA、WebStorm最新永久激活方式/","link":"","permalink":"https://blog.weechang.xyz/2018/09/21/IDEA、WebStorm最新永久激活方式/","excerpt":"今天早上一大早打开IDEA发现激活已过期，遂开始寻找激活码。但是一直不成功，后来终于找到一种比较靠谱的激活方式。在此记录下来，以备不时之需。","text":"今天早上一大早打开IDEA发现激活已过期，遂开始寻找激活码。但是一直不成功，后来终于找到一种比较靠谱的激活方式。在此记录下来，以备不时之需。目前网上现有的激活方式大概有这么三种激活码这种方式一般是给出一段激活码，然后有些还需要改host。目前这种方式，很多激活码都不能使用了，就算能使用可能到了某一天你会发现他用不了了。所以不太推荐这种方式。服务器这种方式一般是填写一个服务器地址就行了，但是现在很多服务器都被官方封了。没被封的也在被封的路上。自建服务器这种方式比较靠谱，自己搭建一个认证服务器。但是对于没有服务器的穷人来说，也是一个巨大的挑战。所以不是特别推荐。接下来就推荐一种比较靠谱的方式。插件激活这种方式呢目前而言比较靠谱，由于插件在本地，不存在官方封域名及IP的说法，但是不排除被后期修复的问题。至少目前而言是没问题的，亲自验证过IDEA2017.3.5与2018.2是没有任何问题的。下面将具体介绍这种方式的操作方法。下载插件首先下载插件jar包 http://idea.lanyus.com/jar/JetbrainsCrack-3.1-release-enc.jar安装插件然后将插件移动到 IDEA 安装目录的bin下。如我的目录 D:\\idea\\IntelliJ IDEA 2018.2.4\\bin修改配置修改 IDEA 安装bin目录下的 idea64.exe.vmoptions 或者 idea.exe.vmoptions 具体修改哪一个看自己操作系统是64 位还是32位。64位修改 idea64.exe.vmoptions ， 32位修改 idea.exe.vmoptions。然后在文件末尾添加上1-javaagent:D:\\idea\\IntelliJ IDEA 2018.2.4\\bin\\JetbrainsCrack-3.1-release-enc.jar其中 D:\\idea\\IntelliJ IDEA 2018.2.4\\bin\\JetbrainsCrack-3.1-release-enc.jar 为插件的安装路径和文件名。注意，目录和文件名一定要一直，不然IDEA不能启动重启IDEA、填写CODE重启IDEA，选择Activation Code填写激活码123456789101112131415161718192021222324ThisCrackLicenseId-&#123;&quot;licenseId&quot;:&quot;ThisCrackLicenseId&quot;,&quot;licenseeName&quot;:&quot;你想填的用户名&quot;,&quot;assigneeName&quot;:&quot;&quot;,&quot;assigneeEmail&quot;:&quot;你想填的邮箱&quot;,&quot;licenseRestriction&quot;:&quot;For This Crack, Only Test! Please support genuine!!!&quot;,&quot;checkConcurrentUse&quot;:false,&quot;products&quot;:[&#123;&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;],&quot;hash&quot;:&quot;2911276/0&quot;,&quot;gracePeriodDays&quot;:7,&quot;autoProlongated&quot;:false&#125;激活OK，至此为止，你的IDEA 就激活成功，又可以继续浪了。Web Storm 激活步骤与此相同","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://blog.weechang.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://blog.weechang.xyz/tags/日常记录/"},{"name":"IDEA永久激活","slug":"IDEA永久激活","permalink":"https://blog.weechang.xyz/tags/IDEA永久激活/"},{"name":"WebStorm永久激活","slug":"WebStorm永久激活","permalink":"https://blog.weechang.xyz/tags/WebStorm永久激活/"}]},{"title":"六元一个的私有博客系统，了解一下？","slug":"六元一个的私有博客系统，了解一下？","date":"2018-09-19T06:33:09.000Z","updated":"2018-09-29T07:47:10.981Z","comments":true,"path":"2018/09/19/六元一个的私有博客系统，了解一下？/","link":"","permalink":"https://blog.weechang.xyz/2018/09/19/六元一个的私有博客系统，了解一下？/","excerpt":"神说要有光，于是便有了光写代码的，偶尔都想装点逼，想要自己写点博客。刚开始还能在各大社区写，比如说CSDN，开源中国，博客园什么的。但是越写就会越觉得，那些博客平台都不是自己想要的，虽然大平台，能够提高在搜索引擎的收录，但是我看着别人的博客，我也想要有一个自建的博客系统。于是开始了自建博客的入坑之旅，在这儿给大伙分享一下我的自建博客历程。","text":"神说要有光，于是便有了光写代码的，偶尔都想装点逼，想要自己写点博客。刚开始还能在各大社区写，比如说CSDN，开源中国，博客园什么的。但是越写就会越觉得，那些博客平台都不是自己想要的，虽然大平台，能够提高在搜索引擎的收录，但是我看着别人的博客，我也想要有一个自建的博客系统。于是开始了自建博客的入坑之旅，在这儿给大伙分享一下我的自建博客历程。准备工作因为自己不是很懂，网上找的资料也很分散。所以整个历程大概经历了四天左右才把自己的博客系统搞好。首先需要准备以下资源github账号（应该都有吧，没有的自己去注册一个）传送门选择一个你喜欢的hexo主题，这个网上太多了。可以去hexo官网，或者github上看看准备一个nodeJS环境，具体怎么搞，可以度娘一下 windows传送门，Mac 传送门一个阿里云账号（如果使用github提供的域名的话，这个可以省了）新建github项目新建github项目时项目命名规则为{username}.github.io如我的github用户名为weechang。则项目命名为weechang.github.io。注意：命名规则必须按照这个规则来。github项目配置创建成功后就可以配置github项目了。github会自动根据项目名识别是否为github pages项目。如果是github pages项目，会出现github pages配置项目。在此，可以设置github pages项目所在分支及自定义域名等信息。注意：自定义域名通过cname方式解析，由于github服务器在国外，所以可以不用备案。查看页面在浏览器输入 http://{username}.github.io 即可访问你的个人页面。如: http://weechang.github.io如果访问不了页面，请检查以下问题：1.项目名是否准确2.域名是否解析到了指定cname地址3.分支选择是否正确安装hexo客户端打开cmd命令行，选择一个你喜欢的目录（建议可以用git从github克隆工程到本地的本地目录），输入安装命令，开始安装hexo1npm install hexo -g安装完成后，输入命令，检查hexo是否安装成功1hexo -v初始化项目文件夹在项目文件夹下输入初始化命令，进行初始化（此处如果实在克隆项目进行的话，建议新建一个分支，比如我的就是hexo分支，该分支用来管理博客源文件与配置。当然如果想要新建项目管理这些东西的话，当我没说）1hexo inithexo组件初始化完成后。需要安装依赖包,输入命令即可安装1npm install运行项目OK到了此处,你的博客系统已经可运行了。首先，生成博客1hexo generate // 或者 hexo g本地部署，本地运行、预览1hexo server // 或者 hexo sweb服务启动后，在浏览器输入给出的预览地址，即可预览如下，是我的本地预览效果图推送到github通过hexo 配置，即可将生成的页面推送到github修改_config.yml文件。配置如下:123456deploy: type: git branch: master repo: github: https://github.com/weechang/weechang.github.io.git bucket: blog.weechang.xyz通过命令推送到github1hexo deploy // 或者 hexo d推送完毕后，即可通过访问 http://{username}.github.io 访问你刚部署的博客系统（由于服务器缓存等原因，可能需要等几分钟才能访问到最新页面）。OK，至此为止。最基本的博客系统就构建完成了。如果需要了解更详细的信息，可以继续关注我的相关文章。若有疑问可以查看我的项目配置 https://github.com/weechang/weechang.github.io该项目 master分支是生成的博客文章信息。hexo是博客源码。如有疑惑之处，欢迎留言讨论。","categories":[{"name":"开源之路","slug":"开源之路","permalink":"https://blog.weechang.xyz/categories/开源之路/"}],"tags":[{"name":"手把手教学","slug":"手把手教学","permalink":"https://blog.weechang.xyz/tags/手把手教学/"},{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.weechang.xyz/tags/Hexo博客/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://blog.weechang.xyz/tags/GitHub-Pages/"}]},{"title":"AxonFramework-事件序列化器调优","slug":"AxonFramework-事件序列化器调优","date":"2018-08-31T03:20:34.000Z","updated":"2018-09-27T06:22:48.071Z","comments":true,"path":"2018/08/31/AxonFramework-事件序列化器调优/","link":"","permalink":"https://blog.weechang.xyz/2018/08/31/AxonFramework-事件序列化器调优/","excerpt":"XStream序列化器XStream是完全可配置和可扩展的。如果你只使用一个无格式XStreamSerializer，有一些速效方案随时取用。","text":"XStream序列化器XStream是完全可配置和可扩展的。如果你只使用一个无格式XStreamSerializer，有一些速效方案随时取用。XStream允许你为包名称和事件类名称配置别名。别名通常更短(特别是如果你有长包名)，使事件的序列化形式更小。由于我们讨论的是XML，所以每个字符从XML中移除是两次(一个开始标记，一个结束标记)。在XStream中一个更高级的话题创建自定义转换器。默认的基于反射的转换器是简单的，但不会生成最紧凑的XML。总是仔细观察生成的XML，看看是否真正需要重建原始实例的所有信息。如果有可能避免upcasters的使用。XStream允许别名用于字段，当他们已经改变了名字。想象版本为0事件,使用一个名为“clientId”字段。业务更喜欢“客户”一词，所以版本1使用被称为“customerId”的字段创建。在XStream中这个使用字段别名完全可以配置。你需要配置两个别名，按照以下顺序：别名“customerId”到“clientId”然后别名“customerId”到“customerId”。这将告诉XStream，如果遇到一个叫做“customerId”字段，它将调用相应的XML元素“customerId”(第二个别名覆盖第一个)。但如果XStream遇到一个XML称为“clientId”的元素，这是一个已知的别名，将解析为字段名称“customerId”。查看XStream文档了解更多信息。对于终极性能，没有基于反射机制的alltogether你可能更好。在这种情况下，创建一个自定义的序列化机制，这可能是最明智的。DataInputStream和DataOutputStream允许你容易将事件的内容写入输出流。ByteArrayOutputStream和ByteArrayInputStream允许写入和读取字节数组。防止重复序列化特别是在分布式系统中，事件消息需要在多个场合进行序列化。Axon的组件检测这个并支持SerializationAware消息。如果检测到SerializationAware消息，其方法用来序列化一个对象,而不是简单地传递载荷到序列化器。这允许对性能进行优化。当你序列化你自己消息时，希望受益于SerializationAware优化，使用MessageSerializer类序列化消息的有效负载和元数据。所有优化逻辑是在这个类中实现。更多细节请参考MessageSerializer的JavaDoc。自定义标识符生成器AxonFramework使用IdentifierFactory生成所有的标识符，不论它们是事件或命令。默认情况下，IdentifierFactory随机生成基于java.util.UUID的标识符。尽管它们使用起来非常安全，但生成它们的过程的性能并出色。IdentifierFactory是一个抽象工厂，使用Java的ServiceLoader(从Java 6)机制找到实现来使用。这意味着你可以创建自己的工厂的实现，将实现的名称放在一个叫做“/META-INF/services/org.axonframework.common.IdentifierFactory”文件中。Java的ServiceLoader机制将检测到文件并尝试创建名为inside类的实例。IdentifierFactory有几个的需求。必须实现：在类路径中让它的完全限定类名作为/META-INF/services/org.axonframework.common.IdentifierFactory文件的内容,有一个可访问的无参数构造函数,扩展IdentifierFactory,通过应用程序的类加载器上下文或类加载器加载IdentifierFactory类来访问，并且必须的是线程安全的。作者：勇赴链接：https://www.jianshu.com/p/801dade37318來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework-高级定制","slug":"AxonFramework-高级定制","date":"2018-08-31T03:14:03.000Z","updated":"2018-09-27T06:22:48.055Z","comments":true,"path":"2018/08/31/AxonFramework-高级定制/","link":"","permalink":"https://blog.weechang.xyz/2018/08/31/AxonFramework-高级定制/","excerpt":"参数解析器你可以配置额外的ParameterResolvers，通过扩展ParameterResolverFactory类和创建一个名为/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory的文件，包含实现类的完全限定名称。","text":"参数解析器你可以配置额外的ParameterResolvers，通过扩展ParameterResolverFactory类和创建一个名为/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory的文件，包含实现类的完全限定名称。警告此时，OSGi支持仅限于在清单文件中被提到的所需的头这一事实。ParameterResolverFactory实例的自动检测在OSGi上工作，但由于类加载器的局限性，它可能需要复制/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory 文件的内容到OSGi包，包含用于解析参数的类（即事件处理程序）。Meta AnnotationsTODOCustomizing Message Handler behaviorTODO性能调优待办事项:更新Axon3本章包含一个清单和在为生产级性能做准备时需要考虑的一些指导方针。现在，你可能已经使用了测试固件测试你的命令处理逻辑和sagas。然而，生产环境不像测试环境那么宽容。聚合往往存活得更久，更频繁地和并发的使用。对于额外的性能和稳定性，你最好调整配置满足你的具体需求。数据库索引和列类型SQL DatabasesSQL数据库如果你使用你的JPA实现自动生成表(例如Hibernate)，你可能没有把所有正确的索引设置在你的表上。为获得最佳性能，事件存储的不同用法需要不同的索引设置。该列表显示，为默认EventStorageEngine实现使用的不同类型的查询添加不同类型的索引：标准操作使用(存储和加载事件):Table ‘DomainEventEntry’, columns aggregateIdentifier and sequenceNumber (unique index)Table ‘DomainEventEntry’, eventIdentifier (unique index)快照：Table ‘SnapshotEventEntry’, aggregateIdentifier column.Table ‘SnapshotEventEntry’, eventIdentifier (unique index)SagasTable ‘AssociationValueEntry’, columns associationKey and sagaId,默认生成的列长度可以工作，例如Hibernate，但不会是最优的。例如，一个UUID总是有相同的长度。而不是可变长度列255个字符，你可以为聚合标识符使用一个固定长度36个字符的列。“时间戳”列在DomainEventEntry表只储存ISO 8601时间戳。如果所有时间存储在UTC时区，他们需要一个长度为24个字符的列。如果你使用另一个时区，这可能高达28位。使用可变长度列通常是没有必要的，因为时间戳总是具有相同的长度。警告强烈建议所有时间戳以UTC格式存储。在夏令时的国家，用当地时间存储时间戳，在时区转换时可能会导致事件生成的顺序错误。使用UTC时不会发生这种情况。有些服务器配置为始终使用UTC。另外你应该在存储它们之前配置事件存储将时间戳转换成UTC。在DomainEventEntry中的“type”列存储聚合的标识符类型。一般来说，这些都是聚合的简单的名称。在Spring中事件臭名昭著的“AbstractDependencyInjectionSpringContextTests”只算45个字符。在这里，再一次，一个长度较短(但可变)的字段应该足够了。MongoDB默认情况下，MongoEventStore只会为正确的操作生成它需要的索引。这意味着当事件存储被创建时，所需的惟一索引在“聚合标识符”、“聚合类型”和“事件序列号”上也被创建。然而，当为某些操作使用MongoEventStore时，可能是值得添加一些额外索引的。注意，在查询优化和更新速度之间的总有一个平衡点。负载测试最终是发现哪些索引提供最佳性能的最好方法。正常操作使用：在“aggregateIdentifier”上自动创建一个索引，“type”和“sequenceNumber”在领域事件(缺省名称:“domainevents”)集合中。Snapshotting：在事件快照(缺省名称:“snapshotevents”)集合中把(unique)索引放“aggregateIdentifier”,“type”和“sequenceNumber“上。Replaying events:在领域事件(缺省名称:“domainevents”)集合中，把非唯一索引放在“timestamp”和“sequenceNumber”上。Sagas：在saga（默认名称：“sagas”）集合中把(唯一)索引放到“sagaIdentifier”上。在saga（默认名称：“sagas”）集合中把索引放到”sagaType”、“associations.key”和“associations.value“属性上。Caching一个设计良好的命令处理模块当实现缓存时应该不会构成任何问题。尤其是当使用事件溯源时，从事件存储中加载一个聚合是一项昂贵的操作。用正确配置的缓存，加载一个聚合可以转化为一个纯粹的in-memory过程。下面是一些帮助您最大限度地利用缓存解决方案的指导原则：确保工作单元永远不需要为功能原因执行回滚。回滚意味着一个聚合已经达到了一个无效的状态。Axon会自动将相关的缓存项失效。下一个请求将迫使聚合从事件中重建。如果你使用异常作为一个潜在的(功能的)返回值，你可以在命令总线上配置一个RollbackConfiguration。默认情况下，当运行时异常时这个工作单元将回滚。单个聚合的所有命令必须到达在缓存中具有该聚合的机器上。这意味着命令应该始终被路由到同一台机器，只要这台机器是“健康”的。路由命令总是阻止缓存过期。命中一个过期缓存将导致一个命令被执行，并且事件存储在事件存储中会失败。配置一个合理的生存时间/闲置时间默认情况下，缓存倾向于有一个相对较短的生存时间，即几分钟。对于具有一致的路由的命令处理组件，一个较长的闲置时间和生存时间通常是更好的。这可以防止需要初始化一个基于它的事件的聚合，仅仅因为它的缓存条目过期了。缓存的生存时间应该与你的聚合的预期寿命相匹配。Snapshotting快照删除需要重载和重放大量的事件。单个快照代表在在某一特定时刻整个聚合状态。然而，快照的处理本身也需要处理时间。因此，在构建快照时所花费的时间和阻止许多事件被读取节省的时间应该保持平衡。对所有类型的应用程序都没有默认行为。一些将指定一些事件之后将创建一个快照，而其他应用程序需要一个基于时间的快照间隔。无论你选择何种方式为您的应用程序，如果你有long-living聚合，确保快照就位。作者：勇赴链接：https://www.jianshu.com/p/1dc158d81511來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework-SpringBoot自动配置","slug":"AxonFramework-SpringBoot自动配置","date":"2018-08-31T03:10:15.000Z","updated":"2018-09-29T07:47:11.128Z","comments":true,"path":"2018/08/31/AxonFramework-SpringBoot自动配置/","link":"","permalink":"https://blog.weechang.xyz/2018/08/31/AxonFramework-SpringBoot自动配置/","excerpt":"Axon支持的SpringBoot自动配置是迄今为止开始配置Axon基础设施组件最简单的选择。只需添加axon-spring-boot-starter依赖性，Axon会自动配置基础设施组件(命令总线，事件总线)，以及运行和储存聚合和Saga所需的任何组件。","text":"Axon支持的SpringBoot自动配置是迄今为止开始配置Axon基础设施组件最简单的选择。只需添加axon-spring-boot-starter依赖性，Axon会自动配置基础设施组件(命令总线，事件总线)，以及运行和储存聚合和Saga所需的任何组件。根据在应用程序上下文中的其他组件，如果他们在应用程序上下文中不是已经明确定义，Axon将定义某些组件。这意味着只需要配置不同于默认值的组件。事件总线和事件存储配置如果JPA可用，事件存储默认使用JPA事件存储引擎。这允许聚合的存储使用事件溯源而无需任何明确的配置。如果JPA不可用，Axon默认使用SimpleEventBus，这意味着你需要为每个聚合指定一个非事件溯源存储库，或者在你的Spring配置中配置一个EventStorageEngine 。配置一个不同的事件存储引擎，即使JPA在class path上，只需定义一个EventStorageEngine类型的bean (使用事件溯源)或EventBus(如果不需要事件溯源)。命令总线配置如果在应用程序上下文中没有显式定义CommandBus实现，Axon会配置一个SimpleCommandBus。这个CommandBus将使用PlatformTransactionManager管理事务，如果它在上下文中可用。如果只有CommandBus bean定义是一个DistributedCommandBus实现，Axon仍将配置一个CommandBus实现作为DistributedCommandBus本地segment。这个bean将获取一个“localSegment”限定符。建议定义DistributedCommandBus为@Primary，以便它优先考虑依赖注入。聚合配置@Aggregate注解(在org.axonframework.spring.stereotype包中)触发自动配置，配置使用带注解的类型的必要组件作为聚合 。注意，只有聚合根需要注解。Axon会用命令总线自动注册所有带@CommandHandler注解的方法，并且如果不存在则建立一个存储库。建立一个与默认情况不同的存储库，在应用程序上下文中定义一个。可选地，你可以定义要使用的存储库的名称，在@Aggregate上使用存储库属性。如果没有定义存储库属性，Axon将尝试以聚合的名称使用存储库(第一个字符小写)，后缀为存储库。依此类推，一个MyAggregate类的类型，默认的存储库名字叫myAggregateRepository。如果没有找到那个名称的bean，Axon将定义一个EventSourcingRepository(如果没有EventStore可用其会失败)。Saga配置基础设施组件的配置操作的Saga是@Saga注解触发的(在org.axonframework.spring.stereotype包中)。Axon会配置一个SagaManagert和SagaRepository。SagaRepository将在上下文中使用一个可用的SagaStore(如果找到JPA默认为JPASagaStore)为实际Saga存储。为Saga使用不同的SagaStores，在每个@Saga注解的sagaStore属性中，提供要使用的SagaStore的bean名称。Saga将从应用程序上下文中注入资源。注意，这并不意味着Spring-injecting用于注入这些资源。@Autowired和@javax.inject.Inject注解可用于标定依赖关系，但它们由Axon通过寻找这些被注解的字段和方法来注入。构造函数注入(还)不支持。事件处理（Event Handling）配置默认情况下，所有单例Spring bean组件包含带@EventHandler注解的方法，将订阅一个事件处理器去接收事件消息发布到事件总线。EventHandlingConfiguration bean，在应用程序上下文可用，有方法来调整事件处理程序的配置。有关详细信息,请参阅配置API配置事件处理程序和事件处理器。更新事件处理（EventHandling）配置，创建一个autowired方法,设置你想要的配置:1234@Autowiredpublic void configure(EventHandlingConfiguration config) &#123; config.usingTrackingProcessors(); // default all processors to tracking mode.&#125;事件处理器(（Event Processors）的某些方面也可以在application.properties中配置。12axon.eventhandling.processors[&quot;name&quot;].mode=trackingaxon.eventhandling.processors[&quot;name&quot;].source=eventBus使用application.yml:123456axon: eventhandling: processors: name: mode: tracking source: eventBus源文件属性指的是bean的名称实现了SubscribableMessageSource或StreamableMessageSource，名称应该被用来做上述处理器的事件源。源文件默认事件总线或事件存储在应用程序上下文中定义。启用AMQP启用AMQP支持，确保axon-amqp模块在类路径上，并且在应用程序上下文中AMQP ConnectionFactory是可用的(例如通过引用spring-boot-starter-amqp)。在应用程序中转发生成的事件到一个AMQP Channel，一行application.properties配置就够了：1axon.amqp.exchange=ExchangeName这将以给定的名称自动发送所有已经发布的事件到AMQP Channel。默认情况下，发送时没有使用AMQP事务。这可以使用axon.amqp.transaction-mode属性覆盖，并设置它为事务或publisher-ack。从队列中接收事件，并在Axon应用程序内处理它们，你需要配置一个SpringAMQPMessageSource：1234567891011@Beanpublic SpringAMQPMessageSource myQueueMessageSource(AMQPMessageConverter messageConverter) &#123; return new SpringAMQPMessageSource(messageConverter) &#123; @RabbitListener(queues = &quot;myQueue&quot;) @Override public void onMessage(Message message, Channel channel) throws Exception &#123; super.onMessage(message, channel); &#125; &#125;;&#125;然后配置一个处理器，使用这个bean作为其消息来源:1axon.eventhandling.processors[&quot;name&quot;].source=myQueueMessageSource使用JGroups分发命令进行中…如果你不能等，添加一个依赖项到axon-spring-boot-starter-jgroups模块。作者：勇赴链接：https://www.jianshu.com/p/d843fe8bd7d1來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework-Snapshotting","slug":"AxonFramework-Snapshotting","date":"2018-08-31T03:07:08.000Z","updated":"2018-09-29T07:47:11.178Z","comments":true,"path":"2018/08/31/AxonFramework-Snapshotting/","link":"","permalink":"https://blog.weechang.xyz/2018/08/31/AxonFramework-Snapshotting/","excerpt":"当聚合存活很长一段时间，它们的状态不断变化，它们会生成大量的事件。不得不加载所有这些事件去复原一个聚合的状态，可能会有很大的性能影响。快照事件是一个有着特殊用途的领域事件：它将任意数量的事件归纳为单个事件。通过定期创建和存储快照事件，事件存储不必返回长的事件列表。只返回最后一个快照事件和在快照之后发生的所有事件","text":"当聚合存活很长一段时间，它们的状态不断变化，它们会生成大量的事件。不得不加载所有这些事件去复原一个聚合的状态，可能会有很大的性能影响。快照事件是一个有着特殊用途的领域事件：它将任意数量的事件归纳为单个事件。通过定期创建和存储快照事件，事件存储不必返回长的事件列表。只返回最后一个快照事件和在快照之后发生的所有事件例如，库存物品往往会经常变化。每销售一件物品，事件就减少一件库存。每次一批新物品进来，库存就增加一些。如果你每天销售一百件，你每天会产生至少100个事件。几天之后，你的系统将会花太多的时间读取所有这些事件，只是为了弄清楚它是否应该raise一个“ItemOutOfStockEvent”。单个快照事件仅仅通过存储当前的库存数量就可以取代很多这些事件。Creating a snapshot创建一个快照快照的创建可由多种因素触发，例如，从上次快照创建以来的事件的数量，初始化一个聚合的时候超过了某个阈值，基于时间的，等等。目前，Axon提供了一种机制，允许你基于事件计数阈值触发快照。当要创建快照时的定义，由SnapshotTriggerDefinition接口提供。当加载聚合所需的事件数量超过一定的阈值时，EventCountSnapshotTriggerDefinition提供触发快照创建的机制。如果加载一个聚合需要的事件的数量超过某个可配置的阈值，触发器告诉Snapshotter为聚合创建一个快照。快照触发器在一个事件溯源存储库上配置，并有很多属性允许你调整触发:快照设置实际的快照实例，负责创建和存储实际的快照事件;触发器设置触发快照创建的阈值;Snapshotter负责快照的实际创建。通常，快照是一个应该尽可能少的扰乱操作进程的进程。因此,建议在不同的线程运行Snapshotter。Snapshotter接口声明了单独的方法：scheduleSnapshot()，以聚合的类型和标识符作为参数。Axon提供了AggregateSnapshotter，它创建并存储AggregateSnapshot实例。这是一种特殊类型的快照，因为它包含了在它内部的实际的聚合实例。Axon提供的存储库知道这种类型的快照，并从它提取聚合，而不是实例化一个新的。快照事件之后加载的所有事件传输到取出的聚合实例。注意确保你使用的序列化器实例(默认为XStreamSerializer)是能够序列化你的聚合的。XStreamSerializer要求使用Hotspot JVM，或者你的聚合要有一个可访问的默认的构造函数或实现Serializable接口。AbstractSnapshotter提供了一组基本的属性，允许你调整创建快照的方式：EventStore设置事件存储，用于加载过去的事件和存储快照。这个事件存储必须实现SnapshotEventStore接口。Executor设计executor，比如ThreadPoolExecutor提供了线程来处理实际快照的创建。默认情况下，快照的创建是在线程中调用scheduleSnapshot()方法，一般不建议用于生产。AggregateSnapshotter提供另一个属性:AggregateFactories是允许你设置创建聚合实例工厂的属性。配置多个聚合工厂允许你使用一个单独的Snapshotter为各种聚合类型创建快照。EventSourcingRepository实现提供了访问他们使用的AggregateFactory。这可以用于配置相同的聚合工厂像在存储库中使用的Snapshotter一样。注意如果你使用一个executor在另一个线程中执行快照创建，如果必要的话，确保你为潜在的事件存储配置正确的事务管理。Spring用户可以使用SpringAggregateSnapshotter，当需要创建一个快照时，它将从应用程序上下文自动查找合适的AggregateFactory。存储快照事件当快照存储在事件存储中时，它会自动使用快照归纳所有之前的事件并将其返回到它们的位置。所有事件存储实现允许并发创建快照。这意味着它们允许快照被存储的同时，另一个进程为同一个聚合添加事件。这允许快照进程作为一个完全独立进程。注意通常情况下，一旦它们是快照事件的一部分，你就可以归档所有的事件。快照事件将永远不会在常规操作场景中再次读取事件存储。然而,如果你希望能够重建快照创建前一刻的聚合状态，你必须保持事件为最新。Axon提供了一种特殊类型的快照事件：AggregateSnapshot,它将整个聚合存储为一个快照。动机很简单:你的聚合应该只包含与业务决策相关的的状态。这正是你想要在一个快照中捕获的信息。所有事件溯源存储库由Axon承认的AggregateSnapshot提供，并将从它提取的聚合。注意，使用这个快照事件要求事件序列化机制需要能够对聚合进行序列化。根据快照事件初始化聚合快照事件是一个和其他事件一样的事件。这意味着一个快照事件就像任何其他领域事件一样被处理。当使用注解来划分事件处理程序(@EventHandler)时，你可以注解一个方法，基于快照事件初始化全部的聚合状态。下面的代码示例演示了，如何像对待任何其他聚合中的领域事件一样对待快照事件。12345678910111213141516public class MyAggregate extends AbstractAnnotatedAggregateRoot &#123; // ... code omitted for brevity @EventHandler protected void handleSomeStateChangeEvent(MyDomainEvent event) &#123; // ... &#125; @EventHandler protected void applySnapshot(MySnapshotEvent event) &#123; // the snapshot event should contain all relevant state this.someState = event.someState; this.otherState = event.otherState; &#125;&#125;有一种类型的快照事件处理方式不同:AggregateSnapshot。这种类型的快照事件包含实际的聚合。聚合工厂识别这种类型的事件并从快照中提取聚合。然后，将所有其他事件重新应用到提取的快照。这意味着聚合从不需要能够处理AggregateSnapshot实例自身。先进的冲突检测和解决方案明确改变的含义作为一个主要的优势，就是你可以更精确地检测冲突的变化。通常,这些冲突的变化，发生在两个用户同时处理相同的数据(几乎)时。想象一下两个用户都查看一个特定版本的数据。他们都决定对这些数据进行修改。他们都将发送一个命令就像“在这个聚合的X版本上，那样做”，其中X是聚合的预期版本。其中一个会将修改实际应用于预期的版本。另一个用户不会。当聚合已经被另一个进程修改时，你可以检查用户的意图与任何看不见的修改是否冲突，而不是简单地拒绝所有传入命令。检测冲突，传递一个ConflictResolver类型的参数到你的聚合的 @CommandHandler方法。这个接口提供了detectConflicts方法，允许你在执行特定类型的命令时，定义被认为是冲突的事件类型。注意注意ConflictResolver只会包含任何潜在的冲突事件，如果聚合用一个预期的版本加载。使用@TargetAggregateVersion在一个命令的字段上标示聚合的预期的版本。如果找到事件匹配的断言（predicate），抛出异常(detectConflicts可选的第二个参数允许你定义抛出的异常)。如果没有找到，处理将继续正常进行。如果没有调用detectConflicts，并有潜在冲突的事件,@CommandHandler将失败。这可能是提供一个预期的版本的情况下，在@CommandHandler方法的参数中没有可用的ConflictResolver 。作者：勇赴链接：https://www.jianshu.com/p/0cf9c4c0e037來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework-事件向上转换","slug":"AxonFramework-事件向上转换","date":"2018-08-31T03:03:17.000Z","updated":"2018-09-29T07:47:11.000Z","comments":true,"path":"2018/08/31/AxonFramework-事件向上转换/","link":"","permalink":"https://blog.weechang.xyz/2018/08/31/AxonFramework-事件向上转换/","excerpt":"由于软件应用程序的不断变化的性质，很可能事件定义也随着时间而变化。由于事件存储被认为是只读和只追加（没有修改和删除）的数据源，所以应用程序必须能够读取所有事件，而不管它们何时添加。这时upcasting 出现了。","text":"由于软件应用程序的不断变化的性质，很可能事件定义也随着时间而变化。由于事件存储被认为是只读和只追加（没有修改和删除）的数据源，所以应用程序必须能够读取所有事件，而不管它们何时添加。这时upcasting 出现了。最初是面向对象编程的一个概念，“一个子类在需要的时候自动转换成超类”，upcasting 概念也可以应用于事件溯源。upcast一个事件意味着将它从原来的结构转换成新的结构。不像OOP的upcasting，事件的upcasting无法全部自动化完成，因为旧的事件对新事件的结构是不了解的。手工编写的Upcasters，必须提供指定如何将旧的结构upcast成新结构。Upcasters类，获取一个x版本的输入事件，并且输出为零或更多版本x+1的新事件。此外，upcasters在一个链中被处理，这意味着一个upcaster的输出发送到下一个upcaster的输入。这允许你以增量的方式更新事件，为每一个新事件版次编写一个Upcaster ，使其小、隔离、并且容易理解。注意也许upcasting最大的好处是，它允许你做非破坏性重构，即完整的事件历史仍然保持不变。在本节中，我们将解释如何编写upcaster，描述随着Axon不同的的Upcaster实现，并解释事件的序列化形式如何影响写upcasters。允许upcaster看到什么版本的序列化对象被接收，Event Store存储版本号以及事件的完全限定名称。这个版本号是由RevisionResolver生成,在序列化器中配置。Axon提供了几个RevisionResolver的实现，比如AnnotationRevisionResolver，它检查在事件有效负载上的@Revision注解，SerialVersionUIDRevisionResolver 使用Java Serialization API和FixedValueRevisionResolver所定义的serialVersionUID，它总是返回一个预定义的值。后者在注入当前应用程序版本时是有用的。这将允许你看哪个版本的应用程序生成一个特定的事件。Maven用户可以使用MavenArtifactRevisionResolver自动使用项目的版本。它使用项目获取的groupId，artifactId版本初始化。因为这只适用由Maven创建的JAR文件,版本不总能通过IDE来解析。如果无法解析版本，则返回null。编写一个upcaster事件的老版本:1234567@Revision(&quot;1.0&quot;)public class ComplaintEvent &#123; private String id; private String companyName; // Constructor, getter, setter...&#125;新版本的事件:12345678@Revision(&quot;2.0&quot;)public class ComplaintEvent &#123; private String id; private String companyName; private String complain; // New field // Constructor, getter, setter...&#125;Upcaster:12345678910111213141516171819202122// Upcaster from 1.0 revision to 2.0 revisionpublic class ComplaintEventUpcaster extends SingleEventUpcaster &#123; private static SimpleSerializedType targetType = new SimpleSerializedType(ComplainEvent.class.getTypeName(), &quot;1.0&quot;); @Override protected boolean canUpcast(IntermediateEventRepresentation intermediateRepresentation) &#123; return intermediateRepresentation.getType().equals(targetType); &#125; @Override protected IntermediateEventRepresentation doUpcast(IntermediateEventRepresentation intermediateRepresentation) &#123; return intermediateRepresentation.upcastPayload( new SimpleSerializedType(targetType.getName(), &quot;2.0&quot;), org.dom4j.Document.class, document -&gt; &#123; document.getRootElement().addElement(&quot;complaint&quot;); document.getRootElement().element(&quot;complaint&quot;).setText(&quot;no complaint description&quot;); // Default value return document; &#125; ); &#125;&#125;Spring boot configuration:123456789101112131415161718192021@Configurationpublic class AxonConfiguration &#123; @Bean public SingleEventUpcaster myUpcaster() &#123; return new ComplaintEventUpcaster(); &#125; @Bean public JpaEventStorageEngine eventStorageEngine(Serializer serializer, DataSource dataSource, SingleEventUpcaster myUpcaster, EntityManagerProvider entityManagerProvider, TransactionManager transactionManager) throws SQLException &#123; return new JpaEventStorageEngine(serializer, myUpcaster::upcast, dataSource, entityManagerProvider, transactionManager); &#125;&#125;TODO - DescribeUpcasters工作在中间的表现层它们更新流到流抽象一对一的upcasting实现代码示例Content type conversion（内容类型转换）一个upcaster工作在给定内容类型上(如dom4j文档)。upcasters之间提供额外的灵活性，内容类型在链接的upcasters之间可能会有所不同。Axon将尝试使用ContentTypeConverters在内容类型之间自动地转换。它将寻找从类型x到类型y最短的路径，执行转换并交值转换成请求的upcaster。考虑到性能因素 ，如果receiving upcaster上的canUpcast方法产生true，转换才会被执行ContentTypeConverters可能依赖于使用的序列化器类型。试图把一个byte[]转换成dom4j文档，这没有任何意义，除非使用序列化器把事件作为XML来写。确保UpcasterChain有权访问serializer-specific ContentTypeConverters,你可以通过UpcasterChain的构造函数引用序列化器。提示为了达到最佳性能,确保所有upcasters在同一链上(其中一个的输出是另一个的输入)处理相同的内容类型。如果你需要不是由Axon提供的内容类型转换，你可以使用ContentTypeConverter接口编写一个自己的。XStreamSerializer支持Dom4J像支持 XOM一样作为XML文档表示。JacksonSerializer 支持Jackson的JsonNode。作者：勇赴链接：https://www.jianshu.com/p/e4e943937993來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework-EventStore实现","slug":"AxonFramework-EventStore实现","date":"2018-08-31T02:52:45.000Z","updated":"2018-09-29T07:47:10.937Z","comments":true,"path":"2018/08/31/AxonFramework-EventStore实现/","link":"","permalink":"https://blog.weechang.xyz/2018/08/31/AxonFramework-EventStore实现/","excerpt":"事件溯源存储库需要一个事件存储（event store）从聚合中存储和加载事件。事件存储提供了一个事件总线的功能，增加了持久化已发布的事件，并能够基于聚合标识符检索事件。","text":"事件溯源存储库需要一个事件存储（event store）从聚合中存储和加载事件。事件存储提供了一个事件总线的功能，增加了持久化已发布的事件，并能够基于聚合标识符检索事件。Axon提供了一个开箱即用的事件存储，EmbeddedEventStore。它委托事件实际的存储和检索到EventStorageEngine。有多个EventStorageEngine的实现：JpaEventStorageEngineJpaEventStorageEngine存储事件在JPA-compatible数据源中。JPA事件存储存储事件在所谓的条目中。这些条目包含事件的序列化形式，以及存储一些领域元数据以快速查找这些条目。使用JpaEventStorageEngine，你必须在你的类路径中有JPA注解(javax.persistence)。默认情况下，事件存储需要你配置你的持久化上下文(如在META-INF/persistence.xml中定义)包含DomainEventEntry和SnapshotEventEntry（两者都在org.axonframework.eventsourcing.eventstore.jpa包中)。下面是一个持久化上下文配置的示例配置：123456&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot; version=&quot;1.0&quot;&gt; &lt;persistence-unit name=&quot;eventStore&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt; (1) &lt;class&gt;org...eventstore.jpa.DomainEventEntry&lt;/class&gt; (2) &lt;class&gt;org...eventstore.jpa.SnapshotEventEntry&lt;/class&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt;在这个示例中，事件存储有一个特定的持久化单元。然而，你可能会选择将第三行添加到任何其他持久化单元的配置中。本行注册DomainEventEntry(由JpaEventStore使用的类)到持久化上下文。注意Axon使用锁来防止两个线程访问相同的聚合。然而，如果在同一数据库上你有多个jvm，这不会帮助你。在这种情况下，你不得不依靠数据库来检测冲突。并发访问事件存储将导致违反主键约束（Key Constraint Violation），因为表允许聚合只能有一个任何序列号的事件，所以，用已有的序列号为现有聚合插入第二个事件将导致错误。JpaEventStorageEngine可以检测这个错误并把它转换成ConcurrencyException。然而，每个数据库系统以不同的方式报告此违规行为。如果你用JpaEventStore注册你的数据源，它将尝试检测数据库的类型，并找出错误代码是一个违反主键约束（Key Constraint Violation）。或者，你可能会提供一个PersistenceExceptionTranslator实例，如果一个给定的异常代表一个违反主键约束（Key Constraint Violation）它能分辨。如果没有提供数据源或PersistenceExceptionTranslator，从数据库驱动程序按原样抛出异常。默认情况下，JPA事件存储引擎需要一个EntityManagerProvider实现，返回EventStorageEngine使用的EntityManager实例。这还允许应用程序管理所用的持久化上下文。EntityManagerProvider的责任是提供一个正确的EntityManager实例。有几个EntityManagerProvider的实现可用，各有不同的需求。SimpleEntityManagerProvider仅在构建时返回EntityManager实例给它。这使得实现成为容器管理上下文一个简单的选择。ContainerManagedEntityManagerProvider作为一种选择，返回默认的持久化上下文，并且它的使用默认通过JPA事件存储。如果你有一个持久化单元称为“myPersistenceUnit”，你希望在JpaEventStore中使用，这就是EntityManagerProvider实现，可能看起来像:1234567891011121314public class MyEntityManagerProvider implements EntityManagerProvider &#123; private EntityManager entityManager; @Override public EntityManager getEntityManager() &#123; return entityManager; &#125; @PersistenceContext(unitName = &quot;myPersistenceUnit&quot;) public void setEntityManager(EntityManager entityManager) &#123; this.entityManager = entityManager; &#125;&#125;默认情况下，JPA事件存储把条目存储在DomainEventEntry和SnapshotEventEntry实体中。虽然在许多情况下这就足够了，你可能会遇到这些实体提供的元数据不够的情况。或者你可能想将不同的聚合类型的事件存储在不同的表。如果是这样,你可以扩展JpaEventStorageEngine。它包含了一些protected方法，你可以重写来调整其行为。警告注意持久化提供者，如Hibernate，在它们的EntityManager实现上使用一级缓存。通常，这意味着在查询中使用或返回的所有隶属于EntityManager的实体。它们只有在周围事务被提交或在事务中执行显式“清除”时才被清除。当查询在事务上下文中执行时尤其如此。要解决这个问题，请确保仅仅查询非实体对象。你可以使用JPA的“SELECT new SomeClass(parameters) FROM …”风格的查询来解决这个问题。或者，获取一批事件后调用EntityManager.flush()和EntityManager.clear()。未能这样做当加截大事件流时可能导致OutOfMemoryExceptions。JDBC Event Storage EngineJDBC事件存储引擎使用JDBC连接将事件存储在JDBC兼容的数据存储。通常，这些都是关系数据库。从理论上讲，任何一个JDBC驱动程序都可以用来支持JDBC事件存储引擎。类似于JPA，JDBC事件存储引擎将事件存储在条目中。默认情况下，每个事件存储在一个单独的条目中，对应表中的一行。一个表用于事件，另一个用于快照。JdbcEventStorageEngine使用ConnectionProvider来获取连接。通常，这些连接可以直接从数据源中获得。然而，Axon会将这些连接绑定到一个工作单元，以便在一个工作单元使用一个连接。这将确保一个单独的事务用于存储所有事件，即使在同一线程中嵌套多个工作单元。注意Spring用户建议使用SpringDataSourceConnectionProvider从数据源附加连接到现有的事务。MongoDB Event Storage EngineMongoDB是一个基于文档的NoSQL存储。其可伸缩特性使它适合用于事件存储。Axon提供了MongoEventStorageEngine,使用MongoDB作为数据库支持。它包含在Axon Mongo模块(Maven artifactId axon-mongo)。事件存储在两个独立的集合中：一个用于实际的事件流，一个用于快照。默认情况下，MongoEventStorageEngine将存储各自的事件在各自的文档。然而，它是可能改变StorageStrategy使用。Axon提供的选择是DocumentPerCommitStorageStrategy，为在一个单独的提交中存储所有事件，创建一个单独的文档(即在同一DomainEventStream)。在一个单独的文档中存储整个提交的好处在于提交是原子存储的。此外，它只需要对任意数量的事件进行一次往返。缺点是,它变得更加难以直接在数据库中查询事件。例如，当重构领域模型时，如果他们被包含在“commit document”中，很难从一个聚合“transfer”事件到另一个聚合。MongoDB不需要很多配置。它所需要的只是对一个存储事件集合的引用，然后你就可以开始了。在生产环境中，你可能想要对集合中的索引进行双重检查。Event Store UtilitiesAxon提供了一些事件存储引擎，可能在某些情况下是有用的。SequenceEventStorageEngine是围绕其它两个事件存储引擎的包装器。当读取时,它从这两个事件存储引擎中返回事件。附加事件只是附加到第二个事件存储引擎。出于性能原因使用事件存储两种不同的实现的情况下，这是有用的，例如。第一个是一个更大的，但较慢事件存储，而第二个是优化的快速读取和写入。还有一个常驻内存的存储事件EventStorageEngine实现：InMemoryEventStorageEngine。虽然它可能优于任何其他的事件存储，这并不意味着长期生产使用。然而，它在需要事件存储的short-lived工具或测试中非常有用,。Influencing the serialization process（影响序列化过程）事件存储需要为存储准备一种序列化事件的方法。默认情况下，Axon使用XStreamSerializer，其使用XStream序列化成XML事件。XStream是相当快的，比Java序列化更灵活。此外，XStream序列化的结果是人类可读的。对日志和调试而言非常有用。XStreamSerializer可以配置。你可以定义它应该用于某些包、类甚至字段的别名。除了可以缩短潜在的长名称之外，还可以在事件的类定义更改时使用别名。有关别名的更多信息，访问XStream网站。另外，Axon还提供了JacksonSerializer，使用Jackson将事件序列化为JSON。当它生成一个更紧凑的序列化形式，它要求类遵守Jackson所要求的约定(或配置)。注意使用Java代码(或其他JVM语言)配置序列化器是很容易的。然而，由于它调用方法的局限性，在Spring XML程序上下文看配置它并不那么简单。其中一个选项是创建一个FactoryBean，创建一个XStreamSerializer实例，并配置它的代码。检查 Spring 参考更多的信息。作者：勇赴链接：https://www.jianshu.com/p/7ffff660d9a1來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework-存储库","slug":"AxonFramework-存储库","date":"2018-08-31T02:50:48.000Z","updated":"2018-09-27T06:22:48.071Z","comments":true,"path":"2018/08/31/AxonFramework-存储库/","link":"","permalink":"https://blog.weechang.xyz/2018/08/31/AxonFramework-存储库/","excerpt":"存储库是提供对聚合访问的机制。存储库充当了用于保存数据的实际存储机制的网关。在CQRS中，存储库只需要能够根据他们的惟一标识符找到聚合。任何其他类型的查询，应该在查询数据库中执行。","text":"存储库是提供对聚合访问的机制。存储库充当了用于保存数据的实际存储机制的网关。在CQRS中，存储库只需要能够根据他们的惟一标识符找到聚合。任何其他类型的查询，应该在查询数据库中执行。在Axon Framework中,所有存储库必须实现Repository接口。这个接口规定了三种方法:load(identifier, version)， load(identifier)和newInstance(factoryMethod)。load方法允许你从存储库加载聚合。version可选参数是用来检测并发修改(见Advanced conflict detection and resolution)。newInstance用于注册新创建的聚合到存储库中。基于你潜在的持久性存储和审计需求，有一些基础实现提供大了部分存储库所需的基本功能。Axon Framework对保存聚合当前状态的存储库(见Standard Repositories)和那些存储聚合事件的存储库(见 Event Sourcing Repositories)进行了区分。注意，存储库接口没有声明delete(identifier)方法。删除聚合是通过在一个聚合内部调用AggregateLifecycle.markDeleted()方法完成的。删除聚合是一个与其他迁移一样的状态迁移，唯一的区别是它在许多情况下是不可逆的。你应该在聚合上创建自己的有意义的方法，来将聚合的状态设置为“已删除”。这也允许你注册你想要发布的任何事件。Standard repositories（标准存储库）标准存储库存储聚合的实际状态。在每次修改后，新的状态将覆盖旧的。这使得命令组件也可以使用应用程序的查询组件使用的相同信息。标准存储库存储聚合的实际状态。这可能取决于你正在创建的应用程序的类型，这是最简单的解决方案。如果是这样的话，Axon提供了一些帮助你实现这样一个存储库的构件。Axon为标准存储库提供了一个开箱即用的实现：GenericJpaRepository。它认为聚合是一个有效的JPA实体。它使用EntityManagerProvider配置，EntityManagerProvider提供EntityManager来管理实际的持久化，并且一个类指定聚合的实际类型存储在存储库中。当聚合调用静态AggregateLifecycle.apply()方法时，你也可以通过EventBus去发布事件。你也可以轻松实现自己的存储库。在这种情况下，最好从抽象类LockingRepository扩展。作为聚合的包装器类型，建议使用AnnotatedAggregate。看GenericJpaRepository的源码示例。Event Sourcing repositories（事件溯源存储库）聚合根能够根据事件重建它们的状态，也可以配置为通过事件溯源存储库加载。这些存储库不存储聚合本身，但存储聚合生成的一系列事件。基于这些事件，可以随时恢复聚合的状态。在AxonFramework中，EventSourcingRepository实现提供了任何事件溯源存储库所需的基本功能。这依赖于EventStore(见Implementing your own Event Store)，它抽象了实际的存储机制。根据情况，你可以提供一个聚合工厂。AggregateFactory指定了如何创建一个聚合实例。一旦创建了一个聚合，EventSourcingRepository可以使用从事件存储中加载的事件来初始化。Axon Framework自带了一些你可以使用的AggregateFactory实现。如果他们还不够，可以很容易创建你自己的实现。GenericAggregateFactoryGenericAggregateFactory是一种特别的AggregateFactory实现，可用于任何类型的事件溯源聚合根。GenericAggregateFactory创建存储库管理的聚合类型的一个实例。聚合类必须是非抽象的，声明一个默认的不进行初始化的无参构造函数化。GenericAggregateFactory适用于大多数场景，聚合不需要专门注入non-serializable资源。SpringPrototypeAggregateFactory根据你的架构选择，使用Spring将依赖项注入到聚合中可能是有用的。例如，你可以将查询库注入到你的聚合，以确保某些值的存在(或不存在)。注入依赖项到你的聚合，在定义了SpringPrototypeAggregateFactory的Spring上下文中，你需要配置一个聚合根的属性bean。不是使用构造函数创建的常规的实例，而是使用Spring应用程序上下文实例化你聚合。这也将在你的聚合中注入的任何依赖项。实现自己的AggregateFactory在某些情况下，GenericAggregateFactory不能提供你所需要的东西。例如，你可以有一个抽象的聚合类型与不同的场景的多个实现(例如，PublicUserAccount和BackOfficeAccount都扩展一个帐户)。而不是为每个聚合创建不同的存储库，你可以使用一个单独的存储库，并配置一个AggregateFactory意识到不同的实现。聚合工厂大部分的工作是创建未初始化的聚合实例。它必须使用一个给定的聚合标识符和流中的第一个事件。通常，这个事件是一个创建事件，其中包含关于预期聚合类型的提示。你可以使用这些信息来选择一个实现并调用其构造函数。确保没有事件被应用于构造函数；聚合必须未初始化。相对于简单的存储库直接加载聚合的实现，基于事件初始化聚合可能是一项耗时的工作,。CachingEventSourcingRepository提供一个可以从中加载聚合的缓存作者：勇赴链接：https://www.jianshu.com/p/585e95e31704來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework-分发事件","slug":"AxonFramework-分发事件","date":"2018-08-31T02:47:38.000Z","updated":"2018-09-29T07:47:11.333Z","comments":true,"path":"2018/08/31/AxonFramework-分发事件/","link":"","permalink":"https://blog.weechang.xyz/2018/08/31/AxonFramework-分发事件/","excerpt":"在某些情况下，有必要发布事件到外部系统,比如消息broker。","text":"在某些情况下，有必要发布事件到外部系统,比如消息broker。Spring AMQPAxon提供了开箱即用的支持从一个AMQP message broker中转递事件和传递事件到broker中，比如Rabbit MQ。将事件转发到AMQP EchangeSpringAMQPPublisher将事件转发给一个AMQP Exchange。它使用SubscribableMessageSource初始化，一般是EventBus或EventStore。从理论上讲，这可能是发布者可以订阅的任何事件源。要配置SpringAMQPPublisher，只需一个实例定义为Spring Bean。有一些setter方法允许你指定你预期的行为，如事务支持，publisher 确认(如果由broker支持)，和交换名称。默认的exchange名称为’Axon.EventBus’注意注意，exchanges不会被自动创建。你还必须声明队列、Exchanges 和你希望使用的Bindings 。检查Spring文档了解更多信息。从AMQP 队列中读取事件Spring已经广泛的支持从一个AMQP队列读取消息。然而,这需要与Axon“架桥”，以便这些消息可以从Axon处理，就像它们是常规事件消息一样。SpringAMQPMessageSource允许事件处理器从队列中读取消息，而不是事件存储或事件总线。它作为一个Spring AMQP和SubscribableMessageSource之间的适配器需要这些处理器。配置SpringAMQPMessageSource最简单的方法，是通过定义一个bean，重写默认的onMessage方法并使用@RabbitListener注解，如下:12345678910@Beanpublic SpringAMQPMessageSource myMessageSource(Serializer serializer) &#123; return new SpringAMQPMessageSource(serializer) &#123; @RabbitListener(queues = &quot;myQueue&quot;) @Override public void onMessage(Message message, Channel channel) throws Exception &#123; super.onMessage(message, channel); &#125; &#125;;&#125;Spring的@RabbitListener注解告诉Spring，这个方法需要被给定队列上的每个消息调用(myQueue的例子)。此方法简单地调用super.onMessage()方法，执行实际事件的发布到已经订阅它的所有处理器。订阅这个MessageSource的处理器，将正确的SpringAMQPMessageSource实例传递给订阅处理器的构造函数:12345// in an @Configuration file:@Autowiredpublic void configure(EventHandlingConfiguration ehConfig, SpringAmqpMessageSource myMessageSource) &#123; ehConfig.registerSubscribingEventProcessor(&quot;myProcessor&quot;, c -&gt; myMessageSource);&#125;请注意跟踪处理器与SpringAMQPMessageSource不兼容。异步事件处理异步处理事件推荐的方法是使用跟踪事件处理器。这个实现可以保证所有事件的处理，甚至在发生系统故障的情况下(假定事件已经被持久化)。然而,也有可能在SubscribingProcessor中异步处理事件。要做到这一点，SubscribingProcessor必须用EventProcessingStrategy配置。这种策略可以用来改变事件监听器的调用应如何管理。默认策略(DirectEventProcessingStrategy)在传递事件的线程中调用这些事件处理程序。这允许处理器使用现有的事务。其他Axon-provided strategy是AsynchronousEventProcessingStrategy。它使用一个Executor异步调用事件侦听器。尽管AsynchronousEventProcessingStrategy异步执行，某些事件按顺序处理仍然是可取的。SequencingPolicy定义事件是否必须按顺序处理，并行或两者的结合。策略返回给定事件的序列标识符。如果两个事件的策略返回一个相等的标识符,这意味着他们必须由事件处理程序按顺序处理。一个空序列标识符意味着事件可能与任何其他事件并行处理。Axon提供了一些可以使用的通用策略：FullConcurrencyPolicy会告诉Axon，事件处理程序可以处理所有并发事件。这意味着需要按特定顺序处理的事件之间没有关系。SequentialPolicy告诉Axon，所有活动必须按照顺序进行处理。处理事件的操作将在处理前一个事件完成时开始。SequentialPerAggregatePolicy将迫使领域事件从同一聚合顺序处理。然而，事件来自不同聚合可能并发处理。这通常是一个合适的政策，用于事件侦听器更新数据库中聚合的细节。除了这些提供的策略之外，你可以定义自己的策略。所有策略都必须实现SequencingPolicy接口。这个接口定义了一个方法getSequenceIdentifierFor，返回值为一个给定的事件序列标识符。返回相等序列标识符的事件必须按顺序处理。产生不同序列标识符的事件可以同时处理。出于性能原因，如果事件可以并行处理任何其他事件，则策略实现应该返回null。这样更快，因为Axon不必检查对事件处理的任何限制条件。当使用AsynchronousEventProcessingStrategy时建议明确定义一个ErrorHandler。默认的ErrorHandler传播异常，但在异步执行中没有什么可以传播的，除了Executor。这可能导致事件没有被处理。相反，建议使用一个ErrorHandler报告错误，并允许继续处理。ErrorHandler被配置在SubscribingEventProcessor的构造函数上，还提供了EventProcessingStrategy。作者：勇赴链接：https://www.jianshu.com/p/c333f2c05239來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework-事件发布和处理","slug":"AxonFramework-事件发布和处理","date":"2018-08-31T02:44:40.000Z","updated":"2018-09-29T07:47:10.910Z","comments":true,"path":"2018/08/31/AxonFramework-事件发布和处理/","link":"","permalink":"https://blog.weechang.xyz/2018/08/31/AxonFramework-事件发布和处理/","excerpt":"由应用程序生成的事件需要被分发到更新查询数据库的组件，搜索引擎或其他需要它们的资源：事件处理程序（Event Handlers）。事件总线（Event Bus）的职责是分发事件消息到所有感兴趣的组件。接收端，事件处理器（Event Processors）负责处理这些事件，其中包括相应的事件处理程序（Event Handlers）的调用。","text":"由应用程序生成的事件需要被分发到更新查询数据库的组件，搜索引擎或其他需要它们的资源：事件处理程序（Event Handlers）。事件总线（Event Bus）的职责是分发事件消息到所有感兴趣的组件。接收端，事件处理器（Event Processors）负责处理这些事件，其中包括相应的事件处理程序（Event Handlers）的调用。发布事件（Publishing Events）在绝大多数情况下，聚合将通过申请（applying）它们发布事件。然而，有时候也有必要发布一个事件(可能来自另一个组件)，直接到事件总线。发布一个事件，在EventMessage中简单封装描述事件的有效负载（payload）。GenericEventMessage.asEventMessage(Object)方法允许你将任何对象包装成EventMessage。如果传递的对象已经是EventMessage，它只是返回。事件总线（Event Bus）EventBus是分发事件到已订阅的事件处理器的机制。Axon 提供了两个事件总线的实现：SimpleEventBus和EmbeddedEventStore。两个实现都支持订阅和跟踪处理器(processor)，EmbeddedEventStore持久化事件，它允许你在以后的阶段重放它们。SimpleEventBus有一个易失性存储器，然后一旦事件已经发布到订阅组件上，就会“忘记”它们。当使用配置API时，默认情况下使用SimpleEventBus。配置EmbeddedEventStore则相反，需要提供一个StorageEngine的实现，它对事件进行实际存储。12Configurer configurer = DefaultConfigurer.defaultConfiguration();configurer.configureEmbeddedEventStore(c -&gt; new InMemoryEventStorageEngine());Event Processors事件处理程序（Event Handlers）定义了接收事件时执行的业务逻辑。事件处理器（Event Processors）负责解决该过程的技术方面的组件。它们启动一个工作单元，也可能一个事务，并且确保相关的数据在事件处理期间，可以正确附加到所有创建的消息上。事件处理器大致有两种形式：订阅和跟踪。订阅事件处理器订阅它们自己给事件源，并由发布机制管理的线程调用。另一方面，跟踪事件处理器使用自己管理的线程从源中取出它们的消息。将处理程序分配给处理器所有处理器都有一个名称，它跨JVM实例标识一个处理器实例。两个名称相同的处理器，可以被认为是同一处理器的两个实例。所有事件处理程序都被附加到一个处理器，它的名字是事件处理程序类的包名。例如, 下面的类：org.axonframework.example.eventhandling.MyHandler,org.axonframework.example.eventhandling.MyOtherHandlerorg.axonframework.example.eventhandling.module.MyHandler将触发两个处理器的创建：org.axonframework.example.eventhandling with 2 handlers, andorg.axonframework.example.eventhandling.module with a single handler配置API允许你为分配的类配置其他策略给处理器，甚至将特定实例分配给特定的处理器。配置处理器默认情况下，Axon将使用订阅事件处理器。这是有可能改变处理程序是如何分配和如何使用配置API的EventHandlingConfiguration类配置处理器的。EventHandlingConfiguration类定义了一些的方法，可用于定义处理器需要如何配置。registerEventProcessorFactory允许你定义一个默认的工厂方法，创建没有明确定义工厂的事件处理器。registerEventProcessor(String name, EventProcessorBuilder builder)定义了用于创建一个带有给定名称的处理器的工厂方法。注意，此种处理器只有当名称被选择作为任何可用的事件处理程序bean的处理器时才会创建。registerTrackingProcessor(String name)定义了一个带有给定名称的处理器，使用默认设置，应该被配置成一个跟踪事件处理器。它使用TransactionManager和TokenStore配置。usingTrackingProcessors()设置默认跟踪处理器，而不是订阅处理器。跟踪处理器不像订阅处理器，需要一个令牌存储来存储它们的进程。跟踪处理器通过其事件流接收的每个消息都伴随着一个令牌。这个令牌允许处理器在任何以后的点重新打开流，并在最后一个事件中提取它。配置API负责令牌存储，以及大多数其他组件处理器需要从全局配置实例。如果没有明确定义TokenStore ，在生产中不推荐使用InMemoryTokenStore。作者：勇赴链接：https://www.jianshu.com/p/217ac0d8822d來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework-分布式命令总线连接器","slug":"AxonFramework-分布式命令总线连接器","date":"2018-08-31T02:40:27.000Z","updated":"2018-09-29T07:47:11.278Z","comments":true,"path":"2018/08/31/AxonFramework-分布式命令总线连接器/","link":"","permalink":"https://blog.weechang.xyz/2018/08/31/AxonFramework-分布式命令总线连接器/","excerpt":"JGroupsConnectorJGroupsConnector使用(正如它的名字已经说明)JGroups作为底层发现和调度机制。描述JGroups的特性有太多的参考指南,请参阅JGroups用户指南以了解更多的细节。","text":"JGroupsConnectorJGroupsConnector使用(正如它的名字已经说明)JGroups作为底层发现和调度机制。描述JGroups的特性有太多的参考指南,请参阅JGroups用户指南以了解更多的细节。因为JGroups既处理节点的发现又处理它们之间的通信，所以JGroupsConnector既充当CommandBusConnector也充当CommandRouter。注意你可以在axon-distributed-commandbus-jgroups模块中，为DistributedCommandBus找到JGroups特定组件。JGroupsConnector有四个强制性配置元素：第一种是JChannel，它定义了JGroups协议栈。一般来说，用JGroups配置文件的引用构造JChannel。JGroups附带的默认配置,可以用作自己配置的依据。请记住，IP多路广播一般不工作在云服务中，像亚马逊。中这种类型的环境中， TCP Gossip通常是一个好的开端。集群名称定义了每个segment应登记到的集群的名称。具有相同的集群名称的Segment最终会探测到彼此，并在彼此间分发命令。“本地segment”是命令总线实现，分发命令去往本地的JVM。这些命令可能已通过其他JVM或从本地的一个实例分发。最后，序列化器是用来序列化之前通过线路发送的命令消息。注意当使用缓存时，当ConsistentHash更改以避免潜在的数据损坏时，它应该被清空（例如，当命令没有指定一个@TargetAggregateVersion和新成员快速加入和离开JGroup，修改聚合然而它还要缓存到其他地方）。最终，JGroupsConnector需要实际连接，按顺序分发消息到其他segment。这样做，调用connect()方法。123456789101112131415161718JChannel channel = new JChannel(&quot;path/to/channel/config.xml&quot;);CommandBus localSegment = new SimpleCommandBus();Serializer serializer = new XStreamSerializer();JGroupsConnector connector = new JGroupsConnector(channel, &quot;myCommandBus&quot;, localSegment, serializer);DistributedCommandBus commandBus = new DistributedCommandBus(connector, connector);// on one node:commandBus.subscribe(CommandType.class.getName(), handler);connector.connect();// on another node, with more CPU:commandBus.subscribe(CommandType.class.getName(), handler);commandBus.subscribe(AnotherCommandType.class.getName(), handler2);commandBus.updateLoadFactor(150); // defaults to 100connector.connect();// from now on, just deal with commandBus as if it is local...注意注意，并非所有的segment都必需具有相同类型的命令的命令处理器。你完全可以为不同的命令类型使用不同的segment。分布式命令总线总是选择一个节点分发命令到那个支持特定类型的命令。如果你使用Spring，你可能需要考虑使用JGroupsConnectorFactoryBean。它自动连接连接器当ApplicationContext启动后，并且在ApplicationContext关闭时完全的断开。此外,它为测试环境使用合理的默认值(但不应被视为生产准备)和自动装配配置。Spring Cloud ConnectorSpring Cloud连接器装置，用Spring Cloud来描述使用服务注册和发现机制来分配命令总线。因此，你可以自由选择使用哪一个Spring Cloud实现用来分发你的命令。实现的一个例子是 Eureka Discovery/Eureka 服务器组合。注意当前版本(Axon 3.0.4)SpringCloudCommandRouter使用ServiceInstance。Metadata 字段来通知所有系统中的节点，通过CommandNameFilter它可以处理命令。这是很重要的,Spring Cloud实现选择支持ServiceInstance.Metadata字段的使用。例如Spring Cloud Consul目前不支持该字段，因此SpringCloudCommandRouter并不是一个可行的解决方案。我们正在研究一个额外的解决方案，从中检索CommandNameFilter 。提供每个SpringCloud实现的描述将推动本参考指南。因此，我们参考他们各自的文件以获得进一步的信息。Spring Cloud连接器装置是一个SpringCloudCommandRouter和SpringHttpCommandBusConnector的组合，分别填充CommandRouter的地点和 DistributedCommandBus的CommandBusConnector。注意Spring Cloud连接器特定的组件DistributedCommandBus可以在axon-distributed-commandbus-springcloud模块中找到 。SpringCloudCommandRouter必须由以下提供的来创建：一个DiscoveryClient类型“discovery client”。这可以通过用@EnableDiscoveryClient注解你的Spring Boot应用程序来提供,将在你的类路径中寻找Spring Cloud 的实现。一个RoutingStrategy类型的”routing strategy”。目前axon-core模块提供了一些实现，但是一函数调用也可以满足要求。例如，如果你想路由命令基于“聚合标识符”，你可以使用AnnotationRoutingStrategy和注解有效载荷的字段，用@TargetAggregateIdentifier识别聚合。SpringHttpCommandBusConnector需要创建三个参数:一个CommandBus类型的“local command bus”。这是命令总线实现，它将分发命令到本地的JVM。这些命令可能是由其他JVM上的或本地的实例分发。RestOperations对象来执行一个命令消息的发布到另一个实例。最后一个Serializer类型的“序列serializer”。序列化器用于在命令发送到网络之前序列化命令消息。SpringCloudCommandRouter和SpringHttpCommandBusConnector应该都被用于创建DistributedCommandsBus。在Spring Java 配置中，看起来如下:12345678910111213141516171819202122232425262728293031323334353637// Simple Spring Boot App providing the `DiscoveryClient` bean@EnableDiscoveryClient@SpringBootApplicationpublic class MyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyApplication.class, args); &#125; // Example function providing a Spring Cloud Connector @Bean public CommandRouter springCloudCommandRouter(DiscoveryClient discoveryClient) &#123; return new SpringCloudCommandRouter(discoveryClient, new AnnotationRoutingStrategy()); &#125; @Bean public CommandBusConnector springHttpCommandBusConnector(@Qualifier(&quot;localSegment&quot;) CommandBus localSegment, RestOperations restOperations, Serializer serializer) &#123; return new SpringHttpCommandBusConnector(localSegment, restOperations, serializer); &#125; @Primary // to make sure this CommandBus implementation is used for autowiring @Bean public DistributedCommandBus springCloudDistributedCommandBus(CommandRouter commandRouter, CommandBusConnector commandBusConnector) &#123; return new DistributedCommandBus(commandRouter, commandBusConnector); &#125;&#125;// if you don&apos;t use Spring Boot Autoconfiguration, you will need to explicitly define the local segment:@Bean@Qualifier(&quot;localSegment&quot;)public CommandBus localSegment() &#123; return new SimpleCommandBus();&#125;注意注意，并非所有的segment都必需具有相同类型的命令的命令处理器。你完全可以为不同的命令类型使用不同的segment。分布式命令总线总是选择一个节点分发命令到那个支持特定类型的命令。作者：勇赴链接：https://www.jianshu.com/p/ccef9924f8d7來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework命令拦截器","slug":"AxonFramework-命令拦截器","date":"2018-08-31T02:29:32.000Z","updated":"2018-09-27T06:22:48.055Z","comments":true,"path":"2018/08/31/AxonFramework-命令拦截器/","link":"","permalink":"https://blog.weechang.xyz/2018/08/31/AxonFramework-命令拦截器/","excerpt":"使用命令总线的优点之一，是能够基于所有传入的命令采取相应的行动。例子是，不论哪种命令类型，你都希望去做日志记录或身份验证。这是使用拦截器来完成的。","text":"使用命令总线的优点之一，是能够基于所有传入的命令采取相应的行动。例子是，不论哪种命令类型，你都希望去做日志记录或身份验证。这是使用拦截器来完成的。有不同类型的拦截器：Dispatch拦截器和Handler拦截器。前者在命令被分发到命令处理程序之前被调用。在那时，它甚至不能确定该命令有任何处理器的存在。后者在命令处理程序被调用之前调用。Message Dispatch Interceptors（消息分发拦截器）当命令在命令总线上被分发时调用消息分发拦截器。例如，它们可以通过添加元数据来更改命令消息，或通过抛出异常来阻塞命令。这些拦截器总是在分发命令的线程上被调用。##Structural validation（结构性验证）如果它没有包含正确格式的所有必需的信息，那么处理命令是没有意义的,。事实上，一个命令缺乏信息应该尽可能早地被阻塞，甚至最好是任何事务开始之前。因此，拦截器应该检查所有传入命令的信息的可用性。这就是所谓的结构性验证。Axon Framework支持基于JSR 303 Bean Validation的验证。这允许你用像@NotEmpty和@Pattern这样的注解，去注解命令上的字段。你需要在你的类路径中include一个JSR 303实现(比如Hibernate-Validator)。然后，在命令总线上配置一个BeanValidationInterceptor，它会自动找到并配置你的验证器实现。虽然它使用合理的默认值，但你可以根据具体需要调整它。提示你想在一个无效的命令上使用尽可能少的资源。因此，该拦截器通常是位于拦截器链的最前端。在某些情况下，一个日志或审计拦截器可能需要放在前面，紧跟着它的是验证拦截器。BeanValidationInterceptor还实现了MessageHandlerInterceptor，也允许你把它配置为一个处理程序（Handler）拦截器。Message Handler Interceptors（消息处理程序拦截器）消息处理程序拦截器可以在命令处理之前和之后执行操作。拦截器甚至可以完全阻止命令处理，例如出于安全原因。拦截器必须实现MessageHandlerInterceptor接口。该接口声明了一个方法handle，它需要三个参数：命令消息，当前的UnitOfWork和InterceptorChain。InterceptorChain用于继续分发处理。与分发拦截器不同，处理程序拦截器在命令处理程序上下文中被调用。这意味着它们可以根据正在处理消息的工作单元附上相关数据。然后这个相关数据将被附加到在工作单元的上下文中被创建的消息。处理程序拦截器也通常用于管理围绕命令处理的事务。这么做，注册一个TransactionManagingInterceptor，使用TransactionManager依次配置启动和提交(或回滚)实际事务。Distributing the Command Bus(分布式命令总线)CommandBus的实现在早期声称只允许命令消息在单个JVM上分发。有时候，你想把不同JVM中的命令总线的多个实例作为一个。当返回任何结果时，在一个JVM命令总线上发出的命令应该无缝地传到到另一个JVM中的命令处理程序。这就是DistributedCommandBus（分布式命令总线）的由来。不像其他CommandBus的实现，DistributedCommandBus不调用任何处理器。它的作用是在不同的JVM的命令总线实现之间形成一座“桥”。每个JVM上的DistributedCommandBus实例称为“Segment”。注意虽然分布式命令总线本身是Axon Framework核心模块的一部分，但它需要的组件，你可以在其中一个以axon-distributed-commandbus -开头的模块中找到。如果你使用Maven，确保你有适当的依赖集。groupId和version与核心模块相同。DistributedCommandBus依赖于两个组件：一个是CommandBusConnector，实现JVM的之间的通信协议；一个是CommandRouter，为每个传入的命令选择目的地。这个路由器定义分布式总线命令的segment应该given一个命令，根据路由键计算得到路由策略。两个具有相同路由键的命令将始终路由到相同的segment，只要segment数量和配置没有改变。一般来说，用目标聚合的标识符作为路由键。提供两个RoutingStrategy的实现：MetaDataRoutingStrategy，它使用元数据属性在命令消息中查找路由键，而AnnotationRoutingStrategy，它使用注解在命令消息有效负载上的@TargetAggregateIdentifier来提取路由键。显然，你也可以提供自己的实现。默认情况下，当命令消息没有键能被解析时，RoutingStrategy实现将抛出一个异常时。这种行为可以改变，通过在MetaDataRoutingStrategy或AnnotationRoutingStrategy的构造函数中提供一个UnresolvedRoutingKeyPolicy。有三个可能的策略:ERROR:这是默认值，当路由键不可用时，会抛出一个异常。RANDOM_KEY：将返回一个随机值，当一个路由键不能从命令消息解析。这实际上意味着这些命令将被路由到命令总线的随机segment。STATIC_KEY:将返回一个静态键(现有的“未被解析的”)为未被解析的路由键。这实际上意味着所有这些命令将被路由到相同的segment，只要segment的配置不改变。作者：勇赴链接：https://www.jianshu.com/p/d603a00bc5cc來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework命令总线","slug":"AxonFramework-命令总线","date":"2018-08-31T02:25:51.000Z","updated":"2018-09-27T06:22:48.008Z","comments":true,"path":"2018/08/31/AxonFramework-命令总线/","link":"","permalink":"https://blog.weechang.xyz/2018/08/31/AxonFramework-命令总线/","excerpt":"命令总线是将命令分发给各自的命令Handler的机制。每个命令总是被精确发送到一个命令Handler。如果没有可用的命令Handler为已分发的命令，将会抛出NoHandlerForCommandException异常。对同一命令类型订阅多个命令Handler将导致订阅互相取代。在这种情况下，最后一个订阅获胜。","text":"命令总线是将命令分发给各自的命令Handler的机制。每个命令总是被精确发送到一个命令Handler。如果没有可用的命令Handler为已分发的命令，将会抛出NoHandlerForCommandException异常。对同一命令类型订阅多个命令Handler将导致订阅互相取代。在这种情况下，最后一个订阅获胜。分发命令CommandBus提供了两个方法去分发命令到它们各自的Handler：dispatch(commandMessage,callback)和dispatch(commandMessage)。第一个参数是一个包含要发送的实际命令的消息。第二个可选的参数接收一个回调，允许在命令处理完成时通知分发组件。这个回调有两个方法:onSuccess()和onFailure()，分别会在命令处理返回后被调用，或者当它抛出一个异常时调用。调用组件可能不采取在分发命令的同一线程中调用回调。如果调用线程在继续之前依赖于结果，你可以使用FutureCallback。这是一个Future(在java.concurrent包中定义)和Axon的CommandCallback的组合。或者，考虑使用命令网关。如果一个应用程序不直接对命令的结果感兴趣，可以使用dispatch(commandMessage) 方法。SimpleCommandBusSimpleCommandBus，顾名思义，最简单的实现。它在分发它们的线程中简单的处理命令。命令处理后，修改后的聚合在同一线程被保存和发布生成的事件。在大多数情况下，如web应用程序，该实现将符合你的需求。配置API中SimpleCommandBus是默认使用的实现。像大多数CommandBus实现一样，SimpleCommandBus允许拦截器进行配置。在命令总线上分发一个命令后调用CommandDispatchInterceptors。在实际的命令handler 方法之前调用CommandHandlerInterceptors，允许你修改或阻塞命令。有关更多信息，请参考命令处理器拦截器。因为所有命令处理都在同一线程中完成，这个实现仅限于JVM的边界。这个实现的性能是很好的，但不超凡。跨JVM边界，或使你的CPU cycles发挥最大的功效，看看其他CommandBus实现。AsynchronousCommandBus顾名思义，AsynchronousCommandBus实现从分发它们的线程异步执行命令。它使用一个Executor在不同的线程来执行实际的处理逻辑。默认情况下，AsynchronousCommandBus使用一个unbounded缓存的线程池。这意味着分发一个命令时会创建线程。完成处理命令的线程将被重新用于新命令。如果60秒线程没有处理命令，则会停止线程。或者，Executor实例可以提供不同的线程策略配置。注意，应用程序停止时应该关闭AsynchronousCommandBus，以确保任何等待线程正确关闭。关闭，调用shutdown()方法。这也将关闭任何Executor实例，如果它实现ExecutorService接口的话。DisruptorCommandBusSimpleCommandBus具有合理的性能特性，特别是当你经历了性能调优技巧。事实上，SimpleCommandBus需要锁来防止多个线程并发访问同一聚合，导致处理开销和锁争用。DisruptorCommandBus采用不同的方法进行多线程处理。不是多个线程每个都执行同样的处理，而是有多个线程，每个负责一件处理。DisruptorCommandBus使用Disruptor，一个小的并发编程框架，通过不同的方法对多线程进行处理来实现更好的性能。任务不是在调用线程中进行处理，而是将任务移交给两组线程进行处理，每组线程负责一部分处理。第一组的线程将执行命令handler，更改一个聚合的状态。第二组将存储并将事件发布到事件存储。虽然DisruptorCommandBus轻易优于SimpleCommandBus 4倍(!)，但有一些限制:DisruptorCommandBus仅支持事件溯源聚合。这个命令总线充当由Disruptor处理聚合的存储库。获取一个存储库的引用，使用createRepository(AggregateFactory)。一个命令只能导致一个聚合实例状态变化。当使用缓存时，它只允许给定的标识符为单个聚合。这意味着它是不可能有两个具有相同的标识符的不同类型的聚合。命令一般不会引发需要回滚工作单元的故障。当发生回滚时，DisruptorCommandBus不能保证命令按照它们被分发的顺序进行处理。此外，它需要重试其他命令，从而造成不必要的计算。在创建一个新的聚合实例时，命令更新所创建实例可能并不完全按照所提供的顺序进行。一旦创建了聚合，所有命令将按照它们被分发顺序执行。为了确保顺序，在创建命令上使用回调去等待正在创建的聚合。它不应该耗时超过几毫秒。构建一个DisruptorCommandBus实例，你需要一个EventStore。该组件在Repositories and Event Stores中有解释。或者，你可以提供一个DisruptorConfiguration实例，它允许你调整配置优化你的特定环境下的性能：Buffer size:在ringBuffer上注册传入命令的槽数。更高的值可能会增加吞吐量,但也导致更高的延迟。必须是2的次方数，默认为4096。ProducerType: 表示条目是由单线程或多线程生成的。默认为多线程。WaitStrategy：当处理器线程（三个线程负责的实际处理）需要等待对方时使用的策略。最好的WaitStrategy取决于机器上可用的处理器数量，和正在运行的其他进程的数量。如果低延迟是至关重要的，DisruptorCommandBus可以自己认领内核，你可以使用BusySpinWaitStrategy。为了使命令总线索取更少的CPU并且允许其他线程处理，使用YieldingWaitStrategy。最后，你可以使用SleepingWaitStrategy和BlockingWaitStrategy允许其他进程共享CPU。如果命令总线不需要进行专职处理，则后者是合适的。默认为BlockingWaitStrategy。Executor：设置Executor为DisruptorCommandBus提供线程。这个Executor必须能够提供至少4个线程。其中的3个线程，由DisruptorCommandBus的处理组件认领。额外的线程用于调用回调函数，并计划重试以防检测到错误的聚合状态。默认是CachedThreadPool提供线程从一个称为“DisruptorCommandBus”的线程组中。TransactionManager：定义了事务管理器，应该确保存储和事件发布以事务的方式执行。InvokerInterceptors:定义了在调用处理中使用的CommandHandlerInterceptors。这个处理调用实际的命令处理器方法。PublisherInterceptors:定义了在发布处理中使用的CommandHandlerInterceptors。这个发布处理存储和发布生成的事件。RollbackConfiguration:定义工作单元应该回滚的异常。默认配置为回滚未经检查的异常。RescheduleCommandsOnCorruptState:指示已经执行过命令但损坏的聚合(如:因为一个工作单元是回滚)是否应该重新计划。如果为假，回调的onFailure()方法将被调用。如果为的(默认),命令将被重新计划。CoolingDownPeriod:设置等待的秒数，以确保所有命令被处理。在冷却期间，不接受新命令，但是现有的命令仍然处理，并在必要时重新计划。冷却期间确保线程可供重新安排命令和调用回调之用。默认为1000(1秒)。缓存:设置缓存存储从Event Store中恢复的聚合实例。缓存用disruptor存储不活跃的聚合实例。InvokerThreadCount:给命令处理器的调用分配线程的数量。一个好的起始点是机器内核数量的一半。PublisherThreadCount:用于发布事件的线程数量。一个好的起始点是一半的内核数量，如果IO上花费大量的时间，可以增加。SerializerThreadCount:使用pre-serialize事件的线程数量。默认为1，但如果没有配置序列化器将被忽略。Serializer:用于执行pre-serialization的序列化器。当配置序列化器时，DisruptorCommandBus将包装所有生成的事件在一个SerializationAware消息上。附加有效负载和元数据的序列化形式，在发布到事件存储之前。作者：勇赴链接：https://www.jianshu.com/p/6aee33abd7f0來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework-测试带注解的Saga","slug":"AxonFramework-测试带注解的Saga","date":"2018-08-29T03:30:56.000Z","updated":"2018-09-29T07:47:11.202Z","comments":true,"path":"2018/08/29/AxonFramework-测试带注解的Saga/","link":"","permalink":"https://blog.weechang.xyz/2018/08/29/AxonFramework-测试带注解的Saga/","excerpt":"与命令处理组件类似，saga有一个明确定义的接口：它们只对事件作出响应。另一方面，saga通常具有时间概念，并且可以作为事件处理过程的一部分与其他组件交互。Axon Framework的测试支持模块包含帮助你编写saga测试的固件。","text":"与命令处理组件类似，saga有一个明确定义的接口：它们只对事件作出响应。另一方面，saga通常具有时间概念，并且可以作为事件处理过程的一部分与其他组件交互。Axon Framework的测试支持模块包含帮助你编写saga测试的固件。每个测试固件包含三个阶段，类似于前面部分描述的命令处理组件固件。given 某些事件(从某些聚合),when事件到达或时间流逝，expect某些行为或状态。“given ”和“when”阶段都接受事件作为它们交互的一部分。在“given”阶段，可能会忽略所有副作用，如生成的命令。在“when”阶段，另一方面，从被记录和被验证的saga生成事件和命令。123456FixtureConfiguration fixture = new SagaTestFixture(InvoicingSaga.class);fixture.givenAggregate(invoiceId).published(new InvoiceCreatedEvent()) .whenTimeElapses(Duration.ofDays(31)) .expectDispatchedCommandsMatching(Matchers.listWithAllOf(aMarkAsOverdueCommand())); // or, to match against the payload of a Command Message only .expectDispatchedCommandsMatching(Matchers.payloadsMatching(Matchers.listWithAllOf(aMarkAsOverdueCommand())));saga可以分发命令使用一个回调函数通知命令处理的结果。由于在测试中没有实际的命令处理完成，该行为使用CallbackBehavior对象定义。这个对象使用setCallbackBehavior()在固件上注册，并定义当一个命令被分发后，是否和如何必须调用回调函数。不是直接使用CommandBus，而是你还可以使用命令网关。见下文如何规定他们的行为。通常，saga将与资源交互。这些资源不是saga状态的一部分，但在saga加载和创建后被注入。测试固件允许你注册需要被注入到saga中的资源。要注册一个资源，只需用资源作为参数调用fixture.registerResource(Object)方法。固件将在saga上检测合适的setter方法或字段(带有@Inject注解)并用一个可用的资源调用它。提示注入模拟对象(例如Mockito或Easymock)到你的saga，可能是非常有益的。它允许你验证saga与外部资源的正确交互。命令网关为saga提供了一个更简单的方式来调度命令。使用自定义命令网关还可以更容易地创建模拟或桩来定义其在测试中的行为。然而，当提供一个模拟或桩时，实际的命令可能不不会被分发，因此无法验证测试固件中发送的命令。因此，固件提供了两个方法，让你注册命令网关和一个可选的模拟定义其行为:registerCommandGateway(Class)和registerCommandGateway(Class, Object)。这两种方法都返回一个given类的实例，表示要使用的网关。这个实例也注册为资源，使它具有资源注入的资格。当registerCommandGateway(Class)用来注册一个网关时，它分发命令到由固件管理的CommandBus。网关的行为主要是通过CallbackBehavior定义于固件。如果没有提供明确的CallbackBehavior，回调不调用，从而无法为网关提供任何返回值。当registerCommandGateway(Class, Object)是用来注册一个网关，第二个参数是用于定义网关的行为。测试固件试图尽可能消除系统时间迁延。这意味着它将会在测试执行时显得没有时间迁延。除非你显式地声明使用whenTimeElapses()。所有事件都将拥有测试固件创建那一刻的时间戳。在测试期间暂停时间，可以更容易地预测在什么时间计划发布事件。如果你的测试用例验证一个事件在30秒后计划发布，它将保持30秒，而不管实际调度和测试执行之间的时间。注意固件使用StubScheduler作为基于时间的活动，如调度事件和推进时间。固件将发送到saga实例的任何事件的时间戳设置为这个scheduler的时间。这意味着一旦固件开始，时间就“stopped”，并可能提前确定使用whenTimeAdvanceTo和whenTimeElapses方法。你还可以使用与测试固件无关的StubEventScheduler，如果你需要测试事件的调度。这个EventScheduler实现允许你验证哪个事件被安排在哪个时间，并且给你选择操纵时间的进展。你可以将时间提前到一个特定的时间，将时钟移动到一个特定的日期和时间，或者将时间提前到下一个计划的事件。所有这些操作将返回进度间隔内计划的事件。作者：勇赴链接：https://www.jianshu.com/p/49429788e7da來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework测试","slug":"AxonFramework-测试","date":"2018-08-29T02:30:35.000Z","updated":"2018-09-29T07:47:11.052Z","comments":true,"path":"2018/08/29/AxonFramework-测试/","link":"","permalink":"https://blog.weechang.xyz/2018/08/29/AxonFramework-测试/","excerpt":"CQRS最大的好处之一，尤其是事件溯源就事件和命令而言，单纯地表达测试是可能的。这两个功能组件，事件和命令对领域专家或业务所有者都有明确的含义。这不仅意味着测试表达就事件和命令而言有明确的功能含义，这也意味着他们不依靠任何实现选择。","text":"CQRS最大的好处之一，尤其是事件溯源就事件和命令而言，单纯地表达测试是可能的。这两个功能组件，事件和命令对领域专家或业务所有者都有明确的含义。这不仅意味着测试表达就事件和命令而言有明确的功能含义，这也意味着他们不依靠任何实现选择。本章描述的特性需要axon-test模块,可通过配置maven依赖(使用axon-test和test&lt;/scope)或通过完整包下载。本章中描述的固件可用于任何测试框架，如JUnit和TestNG。命令组件测试在任何CQRS基础架构中命令处理组件通常是最复杂的。比其他组件更复杂，这也意味着该组件有额外的与测试相关的需求。虽然更复杂，但是命令的API处理组件相当容易。它有一个命令进来，然后事件出去。在某些情况下，可能有一个查询作为命令执行的一部分。除此之外，命令和事件是API的唯一部分。这意味着可以在事件和命令的基础上完整地定义测试场景。典型地，以：given过去的某些事件，when 执行这个命令，expect 这些事件将被发布和/或存储Axon Framework提供了一个测试固件，使你能够做到这一点。AggregateTestFixture允许你配置某些基础设施，包括必要的命令处理器和存储库，并以given-when-then形式的事件和命令来表达你的场景。下面的示例展示了用JUnit 4对given-when-then测试固件的使用：123456789101112131415161718192021222324252627public class MyCommandComponentTest &#123; private FixtureConfiguration fixture; @Before public void setUp() &#123; fixture = new AggregateTestFixture(MyAggregate.class); &#125; @Test public void testFirstFixture() &#123; fixture.given(new MyEvent(1)) .when(new TestCommand()) .expectSuccessfulHandlerExecution() .expectEvents(new MyEvent(2)); /* These four lines define the actual scenario and its expected result. The first line defines the events that happened in the past. These events define the state of the aggregate under test. In practical terms, these are the events that the event store returns when an aggregate is loaded. The second line defines the command that we wish to execute against our system. Finally, we have two more methods that define expected behavior. In the example, we use the recommended void return type. The last method defines that we expect a single event as result of the command execution. /* &#125;&#125;given-when-then测试固件定义了三个阶段：配置、执行和验证。每个阶段由不同的接口表示：分别是，FixtureConfiguration, TestExecutor 和 ResultValidator。固件类的静态newGivenWhenThenFixture()方法提供了对第一个的引用，进而可能提供验证，等等。注意为了最好地利用这些阶段之间的迁移，最好使用这些方法提供的流式接口，如上面的示例所示。在配置阶段（即在提供第一个“given”之前），你提供了执行测试所需的构件。作为固件的一部分提供事件总线、命令总线和事件存储的专用版本。有accessor方法来获得对它们的引用。任何命令处理器不直接在聚合上注册，需要显式地使用registerAnnotatedCommandHandler 方法配置。除了带注解的命令处理器外，你还可以配置各种组件和设置，定义应该如何设置测试周围的基础设施。一旦固件配置好，你就可以定义“given”事件。测试固件将用DomainEventMessage包装这些事件。如果“given”事件实现消息，消息的有效负载和元数据将被纳入DomainEventMessage，否则given事件作为有效负载。DomainEventMessage 的序列号顺序，从0开始。或者，你也可以为“given”场景提供命令。在这种情况下，在执行实际的测试命令时，这些命令生成的事件将被用于事件源聚合。使用“givenCommands(…)”方法提供命令对象。执行阶段允许你提供一个针对命令处理组件执行的命令。对调用处理程序的行为(无论是在聚合或外部处理程序)进行监控，并与在验证阶段注册的预期进行比较。注意在执行测试过程中，Axon试图检测测试中的所有在聚合上的非法状态的更改。它通过将聚合的状态与命令执行后的聚合状态进行比较，如果它从所有“given”和存储的事件溯源。如果状态不相同，这意味着状态变化发生在聚合事件处理器方法之外。比较时将忽略静态和瞬态字段，因为它们通常包含对资源的引用。可以使用setReportIllegalStateChange方法在固件的配置中切换检测。最后一个阶段是验证阶段，允许你检查命令处理组件的活动。这完全是根据返回值和事件来完成的。测试固件允许你验证命令处理程序的返回值。你可以显式地定义预期的返回值，或者简单地要求成功返回该方法。你也可以表达任何你期望的CommandHandler抛出的异常。另一个组件是对已发布事件的验证。有两种匹配预期事件的方法。第一是通过事件实例，它需要与实际的事件是行逐字的比较。将预期事件的所有属性与实际事件中的对应对象进行比较（使用equals()）。如果其中一个属性不相等，则测试失败，并生成一个广泛的错误报告。表达期望的另一种方式是使用的匹配器(Hamcrest库提供的)。匹配器接口规定了两个方法matches(Object)和describeTo(Description)。第一个返回一个布尔值，指示是否匹配或不匹配。第二个让你表达你的期望。例如，一个“GreaterThanTwoMatcher”可以添加“任何值大于2的事件“的描述。描述允许创建关于测试用例失败的错误消息。创建事件列表的匹配器可能是繁琐和容易出错的工作。为了简化问题，Axon提供了一组匹配器允许你提供一组特定于事件的匹配器，并告诉Axon应该如何匹配列表。下面是可用的事件列表匹配器和他们的目的的概述：List with all of: Matchers.listWithAllOf(event matchers…)如果所有的事件匹配器与真实事件列表中至少一个事件匹配，该匹配器将成功。不管是否有多个匹配器匹配相同的事件，或如果列表中一个事件不匹配任何匹配器。List with any of: Matchers.listWithAnyOf(event matchers…)如果一个或多个事件匹配器与实际的事件列表中一个或多个事件匹配，该匹配器将成功。一些匹配器甚至一个也不匹配，而另一个匹配多个。Sequence of Events: Matchers.sequenceOf(event matchers…)使用此匹配器来验证实际事件匹配器和提供的事件匹配器有相同的顺序。如果匹配器与后一个事件相匹配，与前一个匹配器匹配的事件相匹配，该匹配器将成功。这意味着可能出现不匹配事件的“gaps”。如果评估事件之后，更多的匹配器是可用的，他们都是匹配“null”。它是由事件的匹配器来决定是否接受。Exact sequence of Events: Matchers.exactSequenceOf(event matchers…)“事件的序列”匹配器的变化不允许不匹配事件的空隙。这意味着每个匹配器必须与事件后面的事件相匹配，与前一个匹配器匹配的事件相匹配。每个匹配器都应该与它前一个匹配器相对应的事件的后续一个事件相匹配为了方便起见,提供了一些普遍需要的事件匹配器。他们与单个事件实例相匹配:Equal Event: Matchers.equalTo(instance…)验证given对象在语义上等于given事件，这个匹配器将比较实际和预期的对象的所有字段的值使用一个null-safe相等方法。这意味着可以比较事件，即使它们不实现equals方法。存储在given参数字段上的对象用equals进行比较，要求他们正确实现。No More Events: Matchers.andNoMore() or Matchers.nothing()仅与空值匹配，这个匹配器可以作为最后一个匹配器添加到事件的准确顺序匹配器,以确保没有不匹配的事件依然存在。由于匹配器传递一个事件消息列表，有时你只是想验证消息的有效负载。有匹配器来帮助你:Payload Matching: Matchers.messageWithPayload(payload matcher)验证消息的有效负载匹配给定的有效载荷匹配器。Payloads Matching: Matchers.payloadsMatching(list matcher)验证消息的有效负载匹配给定的有效载荷匹配器。给定的匹配器必须匹配列表包含的每个消息的有效负载。有效负载匹配匹配器通常用作外匹配器,以防止重复有效负载匹配器。下面是一个简单的代码示例，以显示这些匹配器的使用。在这个例子中,我们预期共有两个事件发布。第一个事件必须是一个“ThirdEvent”，第二个是“aFourthEventWithSomeSpecialThings”。可能没有第三个事件，因为那样”andNoMore”匹配器会失败。12345678910111213141516171819202122fixture.given(new FirstEvent(), new SecondEvent()) .when(new DoSomethingCommand(&quot;aggregateId&quot;)) .expectEventsMatching(exactSequenceOf( // we can match against the payload only: messageWithPayload(equalTo(new ThirdEvent())), // this will match against a Message aFourthEventWithSomeSpecialThings(), // this will ensure that there are no more events andNoMore() ));// or if we prefer to match on payloads only: .expectEventsMatching(payloadsMatching( exactSequenceOf( // we only have payloads, so we can equalTo directly equalTo(new ThirdEvent()), // now, this matcher matches against the payload too aFourthEventWithSomeSpecialThings(), // this still requires that there is no more events andNoMore() ) ));作者：勇赴链接：https://www.jianshu.com/p/2e893c9d48bf來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework-Saga的基础设施","slug":"AxonFramework-Saga的基础设施","date":"2018-08-29T02:17:20.000Z","updated":"2018-09-29T07:47:11.227Z","comments":true,"path":"2018/08/29/AxonFramework-Saga的基础设施/","link":"","permalink":"https://blog.weechang.xyz/2018/08/29/AxonFramework-Saga的基础设施/","excerpt":"事件需要被重定向到适当的saga实例。为此,一些基础设施类是必需的。最重要的组件是SagaManager和SagaRepository。","text":"事件需要被重定向到适当的saga实例。为此,一些基础设施类是必需的。最重要的组件是SagaManager和SagaRepository。Saga Manager与处理事件的任何组件一样，processing也是由事件处理器完成的。然而，因为saga不是单例实例处理事件，但是有独特的生命周期，它们需要管理。Axon通过AnnotatedSagaManager来支持生命周期管理，这是提供给一个事件Processor来执行处理器的实际的调用。它的初始化使用saga的类型来管理，也使用可以存储和恢复的SagaRepository这种saga类型。一个AnnotatedSagaManager只能管理一个saga类型。当使用配置API时，Axon将对大多数组件使用合理的默认设置。不管怎样，强烈建议定义一个SagaStore的实现使用。SagaStore是在某处物理存储saga实例的机制，AnnotatedSagaRepository(默认)要求它们使用SagaStore去存储和检索saga实例。12345678Configurer configurer = DefaultConfigurer.defaultConfiguration();configurer.registerModule( SagaConfiguration.subscribingSagaManager(MySagaType.class) // Axon defaults to an in-memory SagaStore, defining another is recommended .configureSagaStore(c -&gt; new JpaSagaStore(...)));// alternatively, it is possible to register a single SagaStore for all Saga types:configurer.registerComponent(SagaStore.class, c -&gt; new JpaSagaStore(...));saga存储库和saga存储SagaRepository负责存储和检索saga，使用SagaManager。它能够通过标识符和关联值检索特定的saga实例。然而，有一些特殊的要求。因为在saga中的并发处理是一个非常微妙的过程，存储库必须确保每个概念的saga实例（具有相同的标识符）只有一个实例存在于JVM。Axon提供了 AnnotatedSagaRepository 实现，允许saga实例的查找，同时保证在同一时间只有一个saga实例被访问。它使用一个SagaStore执行saga实例实际的持久化。实现的选择主要取决于应用程序使用的存储引擎。Axon提供了JdbcSagaStore、InMemorySagaStore JpaSagaStore 和MongoSagaStore。在某些情况下,应用程序受益于缓存Saga实例。在这种情况下，有一个CachingSagaStore包装另一个实现添加缓存行为。请注意，CachingSagaStore 是一 个write-through 缓存，这意味着保存操作总是立即转发到后备存储器，以确保数据安全。JpaSagaStoreJpaSagaStore使用JPA来存储状态和关联saga的值。saga本身并不需要任何JPA注解；Axon将使用序列化器序列化saga(类似于事件序列化，你可以使用JavaSerializer或XStreamSerializer)。JpaSagaStore通过EntityManagerProvider来配置,它提供对EntityManager实例的访问。这种抽象允许使用应用程序管理和容器管理EntityManagers。根据情况,你可以定义序列化器去序列化saga实例。Axon默认为XStreamSerializer。JdbcSagaStoreJdbcSagaStore使用原来的JDBC存储saga实例及其关联值。类似于JpaSagaStore，saga实例不需要知道他们是如何存储的。序列化使用序列化器。用DataSource 或ConnectionProvider初始化JdbcSagaStore 。虽然不是必需的，用ConnectionProvider初始化时，建议在UnitOfWorkAwareConnectionProviderWrapper包装实现。它将检查已经打开的数据库连接的当前工作单元，以确保工作单元中的所有活动都是在单个连接上完成的。不像JPA，JdbcSagaRepository使用普通的SQL语句，存储和检索信息。这可能意味着某些操作依赖于数据库特有的SQL方言。情况也可能是这样，某些数据库供应商提供了你希望使用的非标准特性。允许这个，你可以提供自己的SagaSqlSchema。SagaSqlSchema接口定义的存储库的所有操作要在底层数据库上执行。它允许你定制为它们执行的SQL语句。默认是GenericSagaSqlSchema。其他可用的实现是PostgresSagaSqlSchema,Oracle11SagaSqlSchema 和HsqlSagaSchema。MongoSagaStoreMongoSagaStore存储saga实例和它们的关联到MongoDB数据库中。MongoSagaStore存储在单个集合中的所有saga到MongoDB数据库中。每个saga实例创建一个文档。MongoSagaStore还确保在任何时候，在单个JVM中任何唯一的saga只有一个saga实例存在。这样可以确保不因并发问题而丢失任何状态更改。使用MongoTemplate和一个可选的序列化器初始化MongoSagaStore。MongoTemplate提供了一个对集合的引用存储Sagas。Axon 提供了DefaultMongoTemplate，DefaultMongoTemplate获取MongoClient实例，还获取数据库名称和集合的名称存储Sagas。数据库名称和集合的名称可以省略。在这种情况下，他们分别默认为“axonframework”和“sagas”。缓存如果使用一个支持的saga存储的数据库，保存和加载Saga 实例可能是相对昂贵的操作。特别是在很短的时间段内多次调用同一个saga实例的情况下，缓存对应用程序的性能是有利的。Axon 提供了CachingSagaStore实现。这个SagaStore包装实际的存储。加载saga或关联值时，CachingSagaStore将首先查阅其缓存，优于委托给包装的存储库。当存储信息时，所有调用总是被委托，以确保后备存储器总是有一个与saga的状态一致的视图。配置缓存,简单包装任何SagaStore到CachingSagaStore中。CachingSagaStore的构造函数接受三个参数:分别是，包装的存储库、用于关联值的缓存和saga的实例。后两个参数可以引用相同或不同的缓存。这取决于你的具体的程序的逐出需求。作者：勇赴链接：https://www.jianshu.com/p/57bd121412fa來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework跟踪最后期限","slug":"AxonFramework-跟踪最后期限","date":"2018-08-29T02:11:46.000Z","updated":"2018-09-27T06:22:48.040Z","comments":true,"path":"2018/08/29/AxonFramework-跟踪最后期限/","link":"","permalink":"https://blog.weechang.xyz/2018/08/29/AxonFramework-跟踪最后期限/","excerpt":"当有事发生时，很容易使一个saga采取行动。毕竟，有一个事件要通知saga。但是如果你想让你的saga，在什么事情都没发生的情况下做些什么呢？这就是最后期限。在发票中，通常是几周，而信用卡支付的确认可能在几秒钟内。","text":"当有事发生时，很容易使一个saga采取行动。毕竟，有一个事件要通知saga。但是如果你想让你的saga，在什么事情都没发生的情况下做些什么呢？这就是最后期限。在发票中，通常是几周，而信用卡支付的确认可能在几秒钟内。在Axon中，你可以使用一个EventScheduler计划发布一个事件。在发票的例子中，你希望发票在30内付清。saga将在发送CreateInvoiceCommand后，安排一个InvoicePaymentDeadlineExpiredEvent在30天后发布。计划一个事件后EventScheduler返回ScheduleToken。这个令牌可以用来取消计划，例如已收到发票的付款。Axon提供了两种EventScheduler实现:一个纯Java和一个使用Quartz 2作为调度机制支持。这个纯java实现的EventScheduler使用ScheduledExecutorService去计划事件发布。虽然这个计划器的定时非常可靠，但它是一个纯内存实现。一旦JVM关闭，所有的计划都将丢失。这使得这种实现不适合长期限的计划。SimpleEventScheduler 需要配置一个EventBus和一个SchedulingExecutorService（看java.util.concurrent.Executors类的静态方法的helper方法）。QuartzEventScheduler是一个更可靠，企业信得过的实现。使用Quartz 作为底层调度机制，它提供了更强大的功能，如持久性、集群和失败的管理。这意味着事件发布将被保证。可能会晚一点，但会发布。需要配置一个Quartz调度器和EventBus。另外，你可以设置以组的名称进行计划，默认为”AxonFramework-Events”一个或多个组件将监听计划的事件。这些组件可能依赖于绑定到调用它们的线程的事务。计划的事件由EventScheduler管理的线程发布。管理事务在这些线程上，你可以配置一个TransactionManager或UnitOfWorkFactory创建一个事务绑定工作单元。注意Spring用户可以使用quartzeventschedulerfactorybean或simpleeventschedulerfactorybean进行更简单的配置。它允许你直接设置PlatformTransactionManager。注入资源saga一般做的不仅仅是维护基于事件的状态。它们与外部的组件进行交互。要做到这一点，他们需要访问处理组件所需的资源。通常，这些资源实际上并不是saga状态的一部分，也不应该持久化。但是，一旦重新构建一个saga，在事件被路由到该实例之前，必须注入这些资源。为了这个目的有了ResourceInjector。它使用SagaRepository将资源注入到一个saga。Axon提供了SpringResourceInjector用应用程序上下文中的资源注入带注解的字段和方法，和一个SimpleResourceInjector，注册已经注册的资源到用@Inject注解的方法和字段。提示由于资源与saga不应该被持久化，所以务必向这些字段添加临时关键字。这将防止序列化机制尝试将这些字段的内容写入存储库。存储库将在saga被反序列化之后自动重新注入所需的资源。Simpleresourceinjector允许一个预先指定的资源集合被注射。它扫描saga的(setter)方法和字段，以找到被@Inject注解的那个。当使用配置API，Axon将默认为the ConfigurationResourceInjector。它将注入配置中可用的任何资源。组件像EventBus、EventStore CommandBus和CommandGateway默认情况下是可用的,但你也可以使用configurer.registerComponent()注册自己的组件。Springresourceinjector使用Spring的依赖注入机制注入资源聚合。这意味着，如果需要，可以使用setter注入或直接字段注入。要注入的方法或字段需要注解，以便Spring识别它为依赖项。例如@Autowired。作者：勇赴链接：https://www.jianshu.com/p/02e3636fc735來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework事件处理","slug":"AxonFramework-事件处理","date":"2018-08-27T06:47:54.000Z","updated":"2018-09-29T07:47:10.821Z","comments":true,"path":"2018/08/27/AxonFramework-事件处理/","link":"","permalink":"https://blog.weechang.xyz/2018/08/27/AxonFramework-事件处理/","excerpt":"","text":"saga中的事件处理非常接近一个普通的事件监听器。上述的对于方法和参数解析的规则在这里是有效的。不过,有一个主要区别。虽然存在事件监听器只有单个实例处理所有传入事件，但也存在一个saga有多个实例，每个实例都对不同的事件感兴趣。例如,关于Order的id为1的管理业务Saga对Order“2”的事件不感兴趣，反之亦然。Axon不会将所有事件都发布给所有saga实例（这将是对资源的完全浪费），而是只发布与saga相关联的属性的事件。这个通过使用AssociationValues完成。一个AssociationValue由key和value组成。key代表标识符使用的类型，例如“orderId”或“order”。value表示前面例子中相应“1”或“2”值。带@SagaEventHandler注解的方法被评估的顺序与带@EventHandler的相同。如果处理器方法的参数与传入的事件匹配，那么方法就匹配，如果saga有一个定义在处理器方法上的association属性。@SagaEventHandler注解有两个attribute,其中associationProperty是最重要的。这是传入事件上property的名称，应该用来寻找相关的saga。association值的key是property的名称。这个值是由property的getter方法返回的值。例如,考虑一个带”String getOrderId()”方法传入事件,返回“123”。如果一个带@SagaEventHandler(associationProperty = orderId)注解的方法接受这个事件,这个事件被路由到所有已经与带一个键为orderId和值为“123”的AssociationValues关联的saga。这可能是一个,多个,甚至没有。有时,想要关联的属性的名称不是想要使用的关联的名称。例如,你有一个销售订单相匹配购买订单的saga。你可以有一个包含“buyOrderId”和“sellOrderId”的事务对象。如果你想要的saga将“orderId”作为关联的值，你可以定义一个不同的keyName 在@SagaEventHandler注解中。它将变成@SagaEventHandler(associationProperty=”sellOrderId”, keyName=”orderId”)。管理关联当一个saga事务管理跨多个域的概念，如订单、发货,、发票，等等，saga需要与这些概念的实例关联。一个关联需要两个参数：key，识别关联的类型(订单、发货等)和一个value，该值表示该概念的标识符。在以下几个方面完成用概念关联到saga。第一，当新创建一个saga时将调用一个用@StartSaga注解的事件处理器时，它将自动与@SagaEventHandler方法中标识的关联。所有其他的关联用SagaLifecycle.associateWith(String key, String/Number value)方法创建。用SagaLifecycle.removeAssociationWith(String key, String/Number value)方法去移除一个特定的关联。想象一下为一个围绕着订单的事务而已经被创建的一个saga。saga自动关联订单，方法被@StartSaga注解。saga是负责创建该订单的发票，并告诉航运创建一个载货量。一旦货物到达和发票支付,交易完成后,saga被关闭。这是一个saga的代码：12345678910111213141516171819202122232425262728293031323334public class OrderManagementSaga &#123;private boolean paid = false;private boolean delivered = false;@Injectprivate transient CommandGateway commandGateway;@StartSaga@SagaEventHandler(associationProperty = &quot;orderId&quot;)public void handle(OrderCreatedEvent event) &#123; // client generated identifiers ShippingId shipmentId = createShipmentId(); InvoiceId invoiceId = createInvoiceId(); // associate the Saga with these values, before sending the commands associateWith(&quot;shipmentId&quot;, shipmentId); associateWith(&quot;invoiceId&quot;, invoiceId); // send the commands commandGateway.send(new PrepareShippingCommand(...)); commandGateway.send(new CreateInvoiceCommand(...));&#125;@SagaEventHandler(associationProperty = &quot;shipmentId&quot;)public void handle(ShippingArrivedEvent event) &#123; delivered = true; if (paid) &#123; end(); &#125;&#125;@SagaEventHandler(associationProperty = &quot;invoiceId&quot;)public void handle(InvoicePaidEvent event) &#123; paid = true; if (delivered) &#123; end(); &#125;&#125;// ...&#125;通过允许客户端生成标识符，可以很容易地与一个概念相关联，而不需要请求响应类型命令。在发布命令之前，我们将事件与这些概念关联起来。通过这种方式，我们也保证捕捉到作为该命令的一部分生成的事件。一旦发票付清，货物到达，saga也将结束。作者：勇赴链接：https://www.jianshu.com/p/297622466ca9來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework管理复杂的业务事务","slug":"AxonFramework-管理复杂的业务事务","date":"2018-08-27T06:43:56.000Z","updated":"2018-09-27T06:22:48.040Z","comments":true,"path":"2018/08/27/AxonFramework-管理复杂的业务事务/","link":"","permalink":"https://blog.weechang.xyz/2018/08/27/AxonFramework-管理复杂的业务事务/","excerpt":"并不是每个命令都能够在一个ACID事务中完全执行。现金转账事务是一个很常见频繁出现的例子，用来作为论据。通常认为，把钱从一个账户转移到另一个账户，绝对需要原子性和一致性。其实并非如此，相反，这是完全不可能的。如果钱从A银行的帐户转移到B银行的帐户怎么办？A银行要获得B银行数据库的锁吗？如果转账正在进行的时候，A银行已经扣除了金额,但B银行并没收到它，这不是很奇怪吗?事实上不是，这是“正在进行”。另一方面,如果在向B银行的帐户中存资金时出现错误，A银行的客户就想要他的钱回退。所以我们需要某种形式的最终一致性。","text":"并不是每个命令都能够在一个ACID事务中完全执行。现金转账事务是一个很常见频繁出现的例子，用来作为论据。通常认为，把钱从一个账户转移到另一个账户，绝对需要原子性和一致性。其实并非如此，相反，这是完全不可能的。如果钱从A银行的帐户转移到B银行的帐户怎么办？A银行要获得B银行数据库的锁吗？如果转账正在进行的时候，A银行已经扣除了金额,但B银行并没收到它，这不是很奇怪吗?事实上不是，这是“正在进行”。另一方面,如果在向B银行的帐户中存资金时出现错误，A银行的客户就想要他的钱回退。所以我们需要某种形式的最终一致性。虽然ACID事务在某些情况下不是必需的甚至是不可能的，但仍然需要某种形式的事务管理。通常，这些事务称为BASE事务：基本的可用性，软性状态，最终一致性。 与ACID相反，BASE事务无法轻松回滚。 要回滚，需要采取补偿措施来恢复作为事务一部分发生的任何事情。 在汇款的例子中，如果没有把钱存入B银行，将把钱退还给A银行。在CQRS中，Sagas可用于管理这些BASE事务。 他们对事件做出响应，并可能调度命令，调用外部应用程序等。在领域驱动设计的上下文中，将Sagas用作多个限界上下文之间的协调机制并不罕见。Saga一个saga是一种特殊类型的事件监听器：用来管理业务事务。一些事务可能运行数天甚至数周，而另一些则在几毫秒内完成。在Axon中，saga的每个实例负责管理一个业务事务。这意味着saga维护状态必须管理事务，持续或采取补偿动作回滚已经被采取任何动作。通常情况下，与常规的事件监听器相反，saga有一个起点和终点，都由事件触发。虽然saga的起点通常是非常明确的，但可能有多种方式结束一个saga。在Axon中,Sagas是定义了一个或多个@SagaEventHandler方法的类。与常规事件处理器不同，在任何时间可能存在多个saga的实例。Saga由一个Processor管理(跟踪或订阅)，Processor通过事件致力于处理特定saga类型。生命周期一个单独的saga实例负责管理一个单独的事务。这意味着你需要能够标示一个saga生命周期的开始和结束。在一个saga中，事件处理器用@SagaEventHandler注解。如果一个特定的事件标志着开始一个事务，在同一个方法上添加另一个注解:@StartSaga。这个注解将创建一个新的saga，并且当匹配事件后布后调用它的事件处理器方法。默认情况下,只有在找不到匹配的saga时才能开启一个新的saga。你也可以强行创建一个新的saga实例，通过把@StartSaga注解上的forceNew属性设置为true。结束一个saga可以以两种方式完成。如果一个特定的事件总是标示saga生命周期的结束，在saga上用@EndSaga注解事件的处理器。在调用处理器后，saga的生命周期将结束。作为一种选择,你可以调用end()从saga内部去结束生命周期。这允许你有条件地结束saga。作者：勇赴链接：https://www.jianshu.com/p/9c8d7fb623a0來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework在聚合中处理命令","slug":"AxonFramework-在聚合中处理命令","date":"2018-08-27T06:04:52.000Z","updated":"2018-09-29T07:47:11.103Z","comments":true,"path":"2018/08/27/AxonFramework-在聚合中处理命令/","link":"","permalink":"https://blog.weechang.xyz/2018/08/27/AxonFramework-在聚合中处理命令/","excerpt":"建议在包含处理状态命令的聚合中直接定义命令处理器，因为命令处理器有可能需要该集合的状态来执行其任务。","text":"建议在包含处理状态命令的聚合中直接定义命令处理器，因为命令处理器有可能需要该集合的状态来执行其任务。要在一个聚合上定义一个命令处理器,只需用@CommandHandler注解命令处理方法即可。带@CommandHandler注解方法的规则和其他处理方法都是一样的。然而,命令不仅通过他们的有效载荷(payload)进行路由。命令消息携带一个名字,该名称默认为命令对象的完全限定类名。默认情况下,带@CommandHandler注解的方法允许以下参数类型:第一个参数是命令消息的有效载荷。它的类型也可能是Message或CommandMessage，如果@CommandHandler 注解明确定义命令处理器的名称。默认情况下，命令名是命令的有效载荷的完全限定类名。用@MetaDataValue注解的参数，将用注解上的键对元数据值进行解析。如果需要为false（默认值），则在元数据值不存在时传递NULL。如果需要为True，在元数据值不存在时，该解析器将不匹配并阻止该方法被调用。参数的类型元数据将注入整个CommandMessage的元数据。UnitOfWork类型的参数获取当前工作单元注入。这允许命令处理器注册的行为在工作单元的特定阶段执行，或获得与它注册的资源的访问。Message或CommandMessage类型的参数，将得到完整的消息，包括有效载荷和元数据。如果方法需要多个元数据字段或包装消息的其他属性，则此方法非常有用。为了使Axon知道哪一个聚合类型的实例应该处理命令消息，命令对象的属性传送聚合标识符，必须用@TargetAggregateIdentifier注解。注解可以放置在任何字段或访问器方法上（例如getter）。创建聚合实例的命令不需要标识目标聚合标识符，虽然建议标注聚合标识符。如果你喜欢使用另一个机制路由命令，这种行为可以通过提供一个自定义CommandTargetResolver来重写。这个类应该返回聚合标识符和预期的版本(如果有的话)基于给定的命令。注意当@CommandHandler注解放在一个聚合的构造函数上时，相应的命令将创建一个新的聚合实例，并将它添加到存储库。这些命令不需要针对特的定聚合实例。因此，这些命令不需要任何@TargetAggregateIdentifier或@TargetAggregateVersion注解，也不会调用自定义CommandTargetResolver。当一个命令创建一个聚合实例时，该命令的回调函数在命令执行成功执行后，将得到聚合标识符。12345678910111213141516171819202122public class MyAggregate &#123; @AggregateIdentifier private String id; @CommandHandler public MyAggregate(CreateMyAggregateCommand command) &#123; apply(new MyAggregateCreatedEvent(IdentifierFactory.getInstance().generateIdentifier())); &#125; // no-arg constructor for Axon MyAggregate() &#123; &#125; @CommandHandler public void doSomething(DoSomethingCommand command) &#123; // do something... &#125; // code omitted for brevity. The event handler for MyAggregateCreatedEvent must set the id field&#125;public class DoSomethingCommand &#123; @TargetAggregateIdentifier private String aggregateId; // code omitted for brevity&#125;Axon的配置API可用于配置聚合。例如:1234567Configurer configurer = ...// to use defaults:configurer.configureAggreate(MyAggregate.class);// allowing customizations:configurer.configureAggregate(AggregateConfigurer.defaultConfiguration(MyAggregate.class).configureCommandTargetResolver(c -&gt; new CustomCommandTargetResolver()));@CommandHandler注释并不局限于聚合根。把所有命令处理器放在根里，有时会导致聚合根中存在大量的方法,而它们中的许多只简单地调用转发给底层实体之一。如果是这样,你可以把@CommandHandler注解在一个底层的实体的方法上。Axon找到这些带注释的方法,聚合根中声明的实体字段必须用@AggregateMember标明。注意,命令处理器只检查带注解的字段的声明类型。如果一个字段值为空时传入命令到实体,就会抛出一个异常。1234567891011121314151617181920212223242526public class MyAggregate &#123; @AggregateIdentifier private String id; @AggregateMember private MyEntity entity; @CommandHandler public MyAggregate(CreateMyAggregateCommand command) &#123; apply(new MyAggregateCreatedEvent(...); &#125; // no-arg constructor for Axon MyAggregate() &#123; &#125; @CommandHandler public void doSomething(DoSomethingCommand command) &#123; // do something... &#125; // code omitted for brevity. The event handler for MyAggregateCreatedEvent must set the id field // and somewhere in the lifecycle, a value for &quot;entity&quot; must be assigned to be able to accept // DoSomethingInEntityCommand commands.&#125;public class MyEntity &#123; @CommandHandler public void handleSomeCommand(DoSomethingInEntityCommand command) &#123; // do something &#125;&#125;请注意，在聚合中每个命令必须只对应一个处理器。这意味着你不能用@CommandHandler标注多个实体(either root nor not，包含是根和不是根的所有实体)来处理相同的命令类型。如果你需要有条件地路由命令到一个实体,这些实体的父类应该处理命令,并根据apply的条件转发该命令。字段的运行时类型不需要精确地声明类型。然而，@CommandHandle方法只检查被@AggregateMember标记的字段的声明类型。也可以用@AggregateMember去注释包含实体的集合和Map。在后一种情况下，map的值有望包含实体，而键包含一个用作它们引用的值。作为一个命令需要被路由到正确的实例，这些实例必须被正确地标识。它们的“ID”字段必须用@ EntityId标记。命令的属性将用于查找该消息应被路由到的实体，默认为被标识的字段的名称。例如，当标记一个名为“myentityid”字段，命令必须具有相同名称的属性。这意味着必须提供个getmyentityid或myentityid()方法。如果字段的名称和路由属性不同，你可以提供一个值显式使用 @EntityId(routingKey = “customRoutingProperty”)。如果在带注解的集合和Map中没有实体能被找到，Axon会抛出一个IllegalStateException异常。显然,聚合不能够在那个时间点上处理命令。注意字段声明的集合或Map应该包含适当的泛型,允许Axon识别实体的类型包含在集合或Map中。如果不可能添加泛型在声明中(例如因为你已经使用了一个自定义泛型类型的实现),你必须指定实体的类型，用于entityType属性@AggregateMember注解。外部命令处理器在某些情况下,想要直接向一个聚合实例路由命令是不可能。在这种情况下,可以注册一个命令处理器对象。命令处理器对象是一个简单的(常规的)对象，是带@CommandHandle注解的方法。与集合的情况不同，命令处理器对象只有单个实例，该对象处理其方法中声明的所有命令类型。1234567891011121314public class MyAnnotatedHandler &#123;@CommandHandlerpublic void handleSomeCommand(SomeCommand command, @MetaDataValue(&quot;userId&quot;) StringuserId) &#123;// whatever logic here&#125;@CommandHandler(commandName = &quot;myCustomCommand&quot;)public void handleCustomCommand(SomeCommand command) &#123;// handling logic here&#125;&#125;// To register the annotated handlers to the command bus:Configurer configurer = ...configurer.registerCommandHandler(c -&gt; new MyAnnotatedHandler());作者：勇赴链接：https://www.jianshu.com/p/64ddd5a8f517來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework聚合事件溯源","slug":"AxonFramework-聚合事件溯源","date":"2018-08-27T05:56:57.000Z","updated":"2018-09-29T07:47:11.352Z","comments":true,"path":"2018/08/27/AxonFramework-聚合事件溯源/","link":"","permalink":"https://blog.weechang.xyz/2018/08/27/AxonFramework-聚合事件溯源/","excerpt":"除了存储一个聚合的当前状态，还可以根据过去发布的事件恢复一个聚合的状态。为此，所有状态的更改必须由一个事件来表示。","text":"除了存储一个聚合的当前状态，还可以根据过去发布的事件恢复一个聚合的状态。为此，所有状态的更改必须由一个事件来表示。主要部分，事件溯源聚合类似于“有规律”聚合：他们必须声明一个标识符并可以使用apply函数发布事件。然而，事件溯源聚合中状态的变化(也就字段的任何变化)必须在@EventSourcingHandler注解的方法中被排他地执行。这包括设置聚合标识符。注意,聚合标识必须被设置在聚合发布的第一个事件的@EventSourcingHandler上，这通常是创建事件。事件溯源聚合的聚合根还必须包含一个无参的构造函数，Axon Framework使用这个构造函数创建一个空的聚合实例，在使用过去的事件之前初始化它。没有提供这种构造函数加载聚合时将导致异常。123456789101112131415161718public class MyAggregateRoot &#123; @AggregateIdentifier private String aggregateIdentifier; // fields containing state... @CommandHandler public MyAggregateRoot(CreateMyAggregate cmd) &#123; apply(new MyAggregateCreatedEvent(cmd.getId())); &#125; // constructor needed for reconstruction protected MyAggregateRoot() &#123; &#125; @EventSourcingHandler private void handleMyAggregateCreatedEvent(MyAggregateCreatedEvent event) &#123; // make sure identifier is always initialized properly this.aggregateIdentifier = event.getMyAggregateIdentifier(); // ... update state &#125;&#125;带@EventSourcingHandler注解的方法使用特定的规则来解析。这些规则对于带@EventHandler注解的方法也同样适合，并在Defining Event Handlers这一章节中彻底解释。注意事件处理器(Event handler)的方法可以是私有的，只要JVM的安全设置允许Axon Framework改变方法的可访问性。这使你能够清楚地分离聚合的公共API，该方法从处理事件的内部逻辑中公开生成事件的方法。大多数的IDE有一个选项来忽略“未使用的私有方法”的警告为特定注解的方法。或者,你可以添加一个@SuppressWarnings(UnusedDeclaration)注解到方法,以确保你不意外地删除事件处理器方法。有时候，特别是当聚合结构的增长远远超过两个实体时，对同一聚合的其他实体中事件发布的影响更明显。然而，由于重构聚合状态时事件处理器方法也会被调用，所以必须采取特殊的预防措施。在事件溯源处理器方法内可以apply()新事件。这使得实体B可以apply一个事件来响应实体A做的一些事情成为可能。Axond重演历史事件时将忽略apply()调用。注意,在这种情况下，内部apply()调用事件只发布给实体，在所有实体收到第一个事件后。如果有更多的事件需要公布，在apply一个内部事件后的实体状态的基础上，可以用apply(…).andThenApply(…)你还可以使用静态AggregateLifecycle.isLive()方法来检查聚合是否“存活”。基本上,一个聚合如果已经完成重演历史事件会被认为是存活的。当重演这些事件时，isLive()将返回false。在处理新生成的事件时，使用islive()方法是唯一可以执行的活动。复杂的聚合结构复杂的业务逻辑通常需要多个带聚合根的聚合来提供支持。在这种情况下，重要的是把复杂性分布在聚合内的多个实体中。当使用事件溯源时，不仅聚合根需要使用事件来触发状态转换，而且聚合内的实体也如此。注意一个常见的误解，聚合的实体不应该包含任何属性访问方法来暴露状态。这并非如此。事实上，在同一聚合内的实体向其他的实体暴露状态，可能会使一个聚合受益很多。然而，建议不要向外部暴露聚合的状态。Axon在复杂的聚合结构中提供了对事件溯源的支持。实体，就像聚合根，简单的对象。子实体的字段声明必须使用@AggregateMember来注解。这个注释告诉Axon被注解的字段，包含一个应该对命令和事件处理程序进行检查的类。当一个实体(包括聚合根)应用一个事件时，它首先是由聚合根处理，然后向下通过所有带@AggregateMember注解的字段到其子实体。可能包含子实体的字段必须用@AggregateMember注解，此注释可用于多种字段类型：字段直接引用的实体类型;内部包含一个迭代器字段(包括所有集合,例如,列表,等等);内部包含java.util.Map字段的值。作者：勇赴链接：https://www.jianshu.com/p/7b88c5077006來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework命令模型","slug":"AxonFramework-命令模型","date":"2018-08-21T06:00:06.000Z","updated":"2018-09-29T07:47:10.848Z","comments":true,"path":"2018/08/21/AxonFramework-命令模型/","link":"","permalink":"https://blog.weechang.xyz/2018/08/21/AxonFramework-命令模型/","excerpt":"在一个基于CQRS的应用程序中，领域模型(由Eric Evans和Martin Fowler定义)可以是一个非常强大的机制，来驾驭在验证和执行状态的变化时所涉及的复杂性，虽然典型的领域模型提供了大量的构建块，但当在CQRS中应用命令处理时有一个构件起着主导性的作用：聚合。","text":"在一个基于CQRS的应用程序中，领域模型(由Eric Evans和Martin Fowler定义)可以是一个非常强大的机制，来驾驭在验证和执行状态的变化时所涉及的复杂性，虽然典型的领域模型提供了大量的构建块，但当在CQRS中应用命令处理时有一个构件起着主导性的作用：聚合。应用程序中的一个状态的改变，始于一个命令。命令不但是表达意图(描述你想要做什么)的组合，而且是基于这一意图采取行动所需的信息。命令模型用于处理传入的命令，以验证并定义它的结果。在这个模型中，一个命令处理器负责处理某种类型的命令，并根据它包含的信息采取行动。聚合聚合是一个总是保持一致性状态的实体或一组实体。聚合根是聚合树顶部负责维护这个一致性状态的对象。这使得聚合主要构件在任何基于CQRS应用中实现命令模型。注意“聚合”指的是埃文斯在领域驱动设计中所定义的聚合:”作为数据变更的一个单元来处理的一组相关联的对象。在外部只能引用聚合的聚合根对象。在聚合边界内使用一组一致性规则。”例如，“联系人”聚合可以包含两个实体：联系人和地址。若要保持整个聚合处于一致性状态，向联系人添加地址时应通过联系人实体完成。在这种情况下，联系人实体是约定的聚合根。在Axon中，聚合由聚合标识符标识。这可能是任何对象，但也有一些标识符良好实现的指导原则。标识符必须:实现equals和hashCode来保证与其他实例进行相等比较，实现一个提供一致结果的toString()方法(相等的标识符，toString()方法的结果也应该相等),并且最好是可序列化的。当聚合使用不兼容标识符时，测试固件（见测试）将验证这些条件并使测试失败。 字符串类型的标识符，UUID和数值类型都适用。 不要使用原始类型作为标识符，因为它们不允许进行延迟初始化。在某些情况下，Axon可能会错误地假设原始类型的默认值是标识符的值。注意一个经过深思熟虑的好实践是使用随机生成的标识符，而不是使用序列。使用序列会大大降低应用程序的可伸缩性，因为机器需要保持彼此最后一次使用的最新的序列号。UUID冲突的机率非常地小(假如你生成8.2乘以10的11次方个UUID，冲突的机率也只有10的负15次方)。此外，聚合应小心地使用函数式标识符。因为它们有变化的倾向，使得它很难适应相应的应用程序。聚合的实现聚合总是通过一个称为聚合根的实体访问。通常，这个实体的名称和聚合完全一样。例如,Order聚合可能由Order实体引用几个Orderline实体组合而成。Order 和Orderline一起形成聚合。一个聚合是一个合乎规范的对象,其中包含状态和和改变这个状态的方法。虽然根据CQRS原则并不完全正确，也可能通过访问器方法暴露出聚合的状态。聚合根必须声明一个包含聚合标识符的字段。这个标识符字段必须最迟在第一个事件发布时初始化。这个标识符字段必须由@AggregateIdentifier来注解。如果你在聚合上使用JPA注解，Axon也可以使用由JPA提供的@Id注解。聚合可以使用AggregateLifecycle.apply()方法来注册发布的事件。与EventBus不同，这些信息需要被包装在一个EventMessage中，apply()允许你直接传递负载对象。123456789101112131415161718@Entity // Mark this aggregate as a JPA Entitypublic class MyAggregate &#123; @Id // When annotating with JPA @Id, the @AggregateIdentifier annotation is not necessary private String id; // fields containing state... @CommandHandler public MyAggregate(CreateMyAggregateCommand command) &#123; // ... update state apply(new MyAggregateCreatedEvent(...)); &#125; // constructor needed by JPA protected MyAggregate() &#123; &#125;&#125;通过定义一个带@EventHandler注解的方法，聚合内的实体能监听聚合发布的事件。当一个EventMessage发布时这些方法将被调用（在任何外部处理器被发布之前）。作者：勇赴链接：https://www.jianshu.com/p/6cfc9ab399b2來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework配置","slug":"AxonFramework-配置","date":"2018-08-20T10:34:05.000Z","updated":"2018-09-27T06:22:48.008Z","comments":true,"path":"2018/08/20/AxonFramework-配置/","link":"","permalink":"https://blog.weechang.xyz/2018/08/20/AxonFramework-配置/","excerpt":"获得一个默认的配置是非常容易的：Configuration config = DefaultConfigurer.defaultConfiguration().buildConfiguration();","text":"获得一个默认的配置是非常容易的：Configuration config = DefaultConfigurer.defaultConfiguration().buildConfiguration();这个配置为分发消息提供了在线程上处理消息、分发它们的实现。显然，这种配置不会很有用。你必须将你的命令模型对象和事件处理器注册到该配置中。为此,通过.defaultConfiguration()方法返回配置实例。Configurer configurer = DefaultConfigurer.defaultConfiguration();配置提供了多种允许你注册这些组件的方法。在每个组件的相应章节有如何配置这些组件的详细描述。组件一般形式的注册,如下:Configurer configurer = DefaultConfigurer.defaultConfiguration();configurer.registerCommandHandler(c -&gt; doCreateComponent());注意registerCommandBus中lambda表达式的调用。这个表达式的参数c是描述完整配置的配置对象。如果组件需要其他组件正常运行，则可以使用此配置来检索它们。例如,注册一个需要序列化器的命令处理程序configurer.registerCommandHandler(c -&gt; new MyCommandHandler(c.serializer());不是所有的组件都有其明确的accesor方法。检索一个配置中的组件,使用：configurer.registerCommandHandler(c -&gt; new MyCommandHandler(c.getComponent(MyOtherComponent.class));该组件必须和配置一起注册,使用configurer.registerComponent(componentType, builderFunction) .builder函数将接受配置对象作为输入参数。使用Spring设置配置使用Spring时,不需要显式地使用配置。相反,你可以简单地把@EnableAxon设置到一个Spring @configuration类上。Axon将使用Spring应用程序上下文来定位构件的特定实现，并为那些不存在的提供默认值。因此,取代在配置中注册构件,你只需要在Spring应用程序上下文中让@Bean可用即可。作者：勇赴链接：https://www.jianshu.com/p/7fcbc0dcc39c來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework工作单元","slug":"AxonFramework-工作单元","date":"2018-08-20T05:17:12.000Z","updated":"2018-09-29T07:47:11.253Z","comments":true,"path":"2018/08/20/AxonFramework-工作单元/","link":"","permalink":"https://blog.weechang.xyz/2018/08/20/AxonFramework-工作单元/","excerpt":"工作单元是Axon Framework的一个重要的概念,虽然在大多数情况下你可能不太直接与它交互。消息的处理被视为一个独立单元。工作单元的目的是在处理一条消息(命令或事件)期间去协调行为的执行。组件可以在工作单元每一个阶段执行注册行为,如onPrepareCommit或onCleanup。","text":"工作单元是Axon Framework的一个重要的概念,虽然在大多数情况下你可能不太直接与它交互。消息的处理被视为一个独立单元。工作单元的目的是在处理一条消息(命令或事件)期间去协调行为的执行。组件可以在工作单元每一个阶段执行注册行为,如onPrepareCommit或onCleanup。你可能不太需要直接访问工作单元，主要使用Axon提供的构件来访问。不管出于什么原因，如果你需要访问它，有几种方式可以获得它。处理器可以在处理函数中通过一个参数来接收工作单元。如果你使用注解，你可以添加一个UnitOfWork类型参数到你被注解的函数。在其他地方,你可以通过调用CurrentUnitOfWork.get()把工作单元绑定到当前线程。注意，如果没有把工作单元绑定到当前线程，这个方法将抛出一个异常。使用CurrentUnitOfWork.isStarted()可检测它是否可用。需要访问当前工作单元的一个原因是，在消息处理过程中附加需要多次重复使用的资源，或者，如果创建资源时需要在工作单元结束时进行清理工作。在这种情况下,unitOfWork.getOrComputeResource()和生命周期回调方法,如onRollback(),afterCommit()和onCleanup()，允许你在工作单元处理期间，注册资源和声明行为。注意注意工作单元只是变化的缓存，不是事务的替代品。尽管当工作单位被提交时，所有的阶段更改都被提交，但它的提交不是原子性的。这意味着，当提交失败时一些变化可能会被持久化，而另一些则没有。最佳实践要求命令不应该包含多个行为。如果你坚持这种做法，一个工作单元只包含一个单一的行为，从而将使其被安全使用。如果你的工作单元中有更多的行为，那么你可以考虑将一个事务附加到工作单元的提交。当工作单元提交时，使用unitOfWork.onCommit(. .)注册一个行为。*你的处理器可以抛出一个异常作为处理消息的结果。默认情况下,未经检测的异常将导致UnitOfWork回滚所有的更改。结果是 ，预定的副作用被撤消。Axon 提供了一些开箱即用的回滚策略:RollbackConfigurationType.NEVER ,总是提交工作单元。RollbackConfigurationType.ANY_THROWABLE ,当异常发生时总是回滚。RollbackConfigurationType.UNCHECKED_EXCEPTIONS，错误和运行时异常回滚。RollbackConfigurationType.RUNTIME_EXCEPTION ,运行时异常回滚（但不是错误）当使用Axon 组件处理消息时，将自动为你管理工作单元的生命周期。如果你选择不使用这些组件，但实现自己的处理，则需要以编程方式启动和提交(或回滚)工作单元。在大多数情况下，DefaultUnitOfWork将为你提供你所需要的功能。它在单线程中处理进程。在一个工作单元上下文中执行一个任务，可以new一个DefaultUnitOfWork并简单地调用UnitOfWork.execute(Runnable)或UnitOfWork.executeWithResult(Callable)函数。典型的用法如下:1234567891011// then, either use the autocommit approach: uow.executeWithResult(() -&gt; ... logic here);// or manually commit or rollback: try &#123; // business logic comes here uow.commit();&#125; catch (Exception e) &#123; uow.rollback(e); // maybe rethrow...&#125;```一个工作单元了解各个阶段。每当它进展到不同的阶段时，就会通知UnitOfWork监听器。活动阶段:这是开始工作单元的地方。工作单元通常在当前线程中的这个阶段被注册(通过CurrentUnitOfWork.set(UnitOfWork))。随后，消息通常在此阶段由消息处理器处理。提交阶段:在处理完消息之后，但是在提交工作单元之前，将调用onPrepareCommit监听器。如果一个工作单元被绑定到一个事务中，那么将调用onCommit监听器来提交任何的支持事务。当提交成功时，将调用afterCommit监听器。如果在提交或任何步骤之前失败，将调用onRollback监听器。如果可用，则消息处理器的结果包含在工作单元的ExecutionResult中。清理阶段:在此阶段，该工作单元(如锁)所持有的任何资源都将被释放。如果多个工作单元被嵌套，那么清理阶段将被推迟到外部的单元工作都准备好清理为止。消息处理过程可以被认为是一个原子过程;它要么完全被处理，要么完全不被处理。Axon Framework使用工作单元来跟踪消息处理器执行的操作。在处理器完成后，Axon 将尝试提交在工作单元中注册的操作。将事务绑定到工作单元是可能的。许多组件，例如CommandBus的实现和所有异步处理事件处理器，都允许你配置事务管理器（Transaction Manager）。然后，该事务管理器将被用于创建事务，以绑定到用于管理消息处理的工作单元。当应用程序组件在消息处理的不同阶段需要资源时，比如，数据库连接或实体管理器(EntityManager)，这些资源能作者：勇赴链接：https://www.jianshu.com/p/3814c293f4fc來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"ElasticSearch查询报错fielddata=true","slug":"ElasticSearch查询报错fielddata-true","date":"2018-08-17T09:01:18.000Z","updated":"2018-09-29T07:47:11.079Z","comments":true,"path":"2018/08/17/ElasticSearch查询报错fielddata-true/","link":"","permalink":"https://blog.weechang.xyz/2018/08/17/ElasticSearch查询报错fielddata-true/","excerpt":"记录下ElasticSearch查询报错的解决方案，今天在java中查询ElasticSearch的数据发生报错。","text":"记录下ElasticSearch查询报错的解决方案，今天在java中查询ElasticSearch的数据发生报错。1java.lang.IllegalArgumentException: Fielddata is disabled on text fields by default. Set fielddata=true on [pkgts_date] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory.百度了一下。特汇总解决方法。首先，看到这个报错。很自然的就去将pkgts_date字段设置 fielddata=true.但是这样会占用比较多的内存。导致性能下降。因此找到了另外的解决方法。遇到这个错误是因为你尝试对一个text类型的字段做排序，而text类型的字段是要分词的。 一来词典很大，性能会很差；二来排序结果是词典里的词，而并非整个text的内容。 出于这2点原因，ES5.x以后对于text类型默认禁用了fielddata，防止对text字段一些错误的操作（排序，聚合，script)而给heap造成很大的压力。如果一定有对该字段按照文本字母序做排序的需求，可以将该字段定义为multi-filed，例如:1234567891011121314151617PUT my_index&#123; &quot;mappings&quot;: &#123; &quot;my_type&quot;: &#123; &quot;properties&quot;: &#123; &quot;city&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;raw&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125; &#125; &#125; &#125;&#125;上面的city是text类型，适合做全文搜索，然后排序的时候可以用其keyword类型即city.raw。 这样排序结果是正确的，并且keyword字段是通过doc values排序的，内存消耗远小于fielddata。","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://blog.weechang.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://blog.weechang.xyz/tags/日常记录/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://blog.weechang.xyz/tags/ElasticSearch/"}]},{"title":"AxonFramework消息、命令和事件","slug":"AxonFramework-消息、命令和事件","date":"2018-08-17T08:38:47.000Z","updated":"2018-09-27T06:22:48.055Z","comments":true,"path":"2018/08/17/AxonFramework-消息、命令和事件/","link":"","permalink":"https://blog.weechang.xyz/2018/08/17/AxonFramework-消息、命令和事件/","excerpt":"消息传送的概念消息是Axon的核心概念之一。组件之间的所有通信都使用消息对象完成。这为这些组件提供了位置透明性，在必要时需要能够进行扩展和分发这些组件。尽管所有这些消息都实现了消息接口，但不同类型的消息及其处理方式之间有明显的区别。所有消息包含payload、元数据和唯一标识符。消息的payload是消息的功能说明。该对象的类名组合与它所携带的数据，描述了消息的应用程序的含义。元数据允许你描述正在发送消息的上下文。例如，你可以存储跟踪信息，以允许跟踪消息的来源或原因。你还可以存储信息以描述正在执行命令的安全上下文。","text":"消息传送的概念消息是Axon的核心概念之一。组件之间的所有通信都使用消息对象完成。这为这些组件提供了位置透明性，在必要时需要能够进行扩展和分发这些组件。尽管所有这些消息都实现了消息接口，但不同类型的消息及其处理方式之间有明显的区别。所有消息包含payload、元数据和唯一标识符。消息的payload是消息的功能说明。该对象的类名组合与它所携带的数据，描述了消息的应用程序的含义。元数据允许你描述正在发送消息的上下文。例如，你可以存储跟踪信息，以允许跟踪消息的来源或原因。你还可以存储信息以描述正在执行命令的安全上下文。注意注意所有消息都是不可变的。将数据存储在一个消息中，实际上意味着在前一个消息的基础上，创建一个添加了额外信息的新消息。这保证了消息在多线程和分布式环境中使用是安全的。命令命令描述改变应用程序状态的意图。命令用一个CommandMessage来包装POJO（最好是只读的）来实现。命令总是有一个确切的目的地。虽然发送者并不关心由哪个组件来处理命令或该组件驻留在哪里，但它可能对它的结果感兴趣。这就是命令总线上发送命令消息后，允许返回结果的原因。事件事件是描述应用程序中已经发生的事情的对象。聚合是事件的典型来源。当聚合中发生重要的事情时，它将引发一个事件。在Axon Framework中，事件可以是任何对象。非常希望你能确保所有的事件都是可序列化的。当事件被分发时，Axon把他们包装在一个EventMessage中。实际使用的消息类型取决于事件的来源。当一个事件是由一个聚合引发时，它被包装在DomainEventMessage（继承自EventMessage）中。所有其他事件都被包装在一个EventMessage中。除了像唯一标识这种常见的消息属性，EventMessage还包含一个时间戳。DomainEventMessage额外包含类型和聚合的标识符，它还在聚合的事件流中包含事件的序号,以允许重现事件的顺序。注意尽管DomainEventMessage总包含一个对聚合标识符的引用,你也应该包括实际事件本身的标识符。EventStore通过DomainEventMessage中的标识符来存储事件，标识符可能并不总是会提供一个可靠值用于其他目标。原始事件对象存储为EventMessage的payload。紧挨着的payload,你可以将信息存储在一个事件消息的元数据中。元数据的目的是存储关于事件的额外信息,而不是业务信息。审计信息就是一个典型的例子。它可以让你看到在哪些情况下，一个事件会被引发，比如用户帐户触发进程，或处理事件的机器名称。注意一般来说，你不应该基于事件消息的元数据中的信息进行业务决策。如果是这样的话，你可能有附加的信息，而不是事件本身的一部分信息。元数据通常用于报告、审计和跟踪。虽然不是强制性的，但让领域事件不可变是一种很好的做法，最好是将所有字段声明为final并在构造函数中初始化。如果事件构造太麻烦可考虑使用建造者模式(Builder pattern )。注意虽然领域事件在技术上表示状态的变化,你也应该试图在事件中捕捉状态意图。一个好的实践是使用一个抽象的领域事件实现来捕获某些状态已经改变了这一事实,并使用一个抽象类具体的sub-implementation来表示变化的意图。例如,你可以有一个AddressChangedEvent抽象类，并用实现ContactMovedEvent和AddressCorrectedEvent这两个子类来达到捕获状态变化的意图。一些监听器不关心这些意图(例如,数据库更新事件监听器)，将监听抽象类型。其他关心这些意图监听器，它们将监听具体的子类(例如发送一个地址变更确认电子邮件给消费者)。当在事件总线分发事件时,你需要把它包装在一个事件消息中。GenericEventMessage是一个允许你将你的事件包装到一个消息的实现。你可以使用构造函数,或静态方法：asEventMessage()。 后者检查给出的参数是否已经实现了消息接口，如果是这样，它直接返回（如果它实现了EventMessage），或者返回一个使用给定消息的payload和元数据来实例化的GenericEventMessage。如果一个事件通过聚合发布，Axon将自动把事件包装在一个DomainEventMessage中，包含聚合的标识符,类型和序列号。作者：勇赴链接：https://www.jianshu.com/p/e7abb5a228e9來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework架构概述","slug":"AxonFramework-架构概述","date":"2018-08-17T08:33:12.000Z","updated":"2018-09-27T06:22:48.087Z","comments":true,"path":"2018/08/17/AxonFramework-架构概述/","link":"","permalink":"https://blog.weechang.xyz/2018/08/17/AxonFramework-架构概述/","excerpt":"CQRS本身是一个非常简单的模式。它只规定了处理命令的应用程序的组件应该与处理查询 的组件分离。 虽然这种分离本身非常简单，但它与其他模式结合时提供了许多非常强大的功能。Axon 提供的构件更容易实现不同的模式与CQRS的结合。","text":"CQRS本身是一个非常简单的模式。它只规定了处理命令的应用程序的组件应该与处理查询 的组件分离。 虽然这种分离本身非常简单，但它与其他模式结合时提供了许多非常强大的功能。Axon 提供的构件更容易实现不同的模式与CQRS的结合。下图显示了一个示例，一个基于CQRS的事件驱动的架构图示。 左侧显示的是UI组件, 通过 两种方式与应用程序的其余部分进行交互：它向应用程序发送命令 (显示在顶端的部分), 并从应用程序中查询信息 (显示在底端的部分)。Command(命令)通常用简单的对象表示，这些对象包含命令处理器执行所需的所有数据。一个命令通过它的名字来表达它的意图。在Java术语中，这意味着使用类名来确定需要做什么，命令的字段提供了执行该操作所需的信息。Command Bus接受命令并路由它们到命令处理器(Command handler) 。每个命令处理器响应特定类型的命令，并根据命令的内容执行逻辑。 然而，在某些情况下，你也希望不顾实际的命令类型去执行逻辑，如验证、日志或权限。Command handler(命令处理器)从仓储中恢复领域对象(聚合)并执行方法来改变它们的状态。这些聚合通常包含真实的业务逻辑并负责维护自身的不变性。聚合的状态变化导致了领域事件的产生,领域事件和聚合都从领域模型中来。repositories(仓储)负责提供访问聚合。通常情况下，这些仓储的优化设计是仅通过其唯一标识符来查找聚合。一些仓储将存储聚合自身的状态(例如，使用对象关系映射，ORM)， 而另一些则存储聚合的状态的更改到Event Store中，仓储还负责对其备份数据库中的聚合进行更改。Axon提供了直接持久化聚合（使用对象关系映射，ORM）和事件溯源(event sourcing)两种方式.Event bus(事件总线)分派事件到所有感兴趣的事件监听器(Event listener)中。可以同步或异 步完成。异步事件调度允许命令执行返回和移交控制给用户，这些事件在后台被分派和处理，不必等待事件处理完成，这样应用程序就会响应得更快。同步事件处理，另一方面，更简单，是 一个合适的默认选项。 默认情况下,同步处理将在同一事务中处理事件监听器和命令处理 器。Event listener(事件监听器)接收并处理事件。一些处理器将更新用于查询的数据源，而其他处理器则将消息发送到外部系统。你可能会注意到了,命令处理器只对组件所做的更改感兴趣，却完全察觉不到它们的存在。这意味着它可以非侵入地扩展应用程序的新功能， 你需要做的就只是添加一个事件监听器。事件让应用程序中的所有组件松散耦合。在某些情况下,事件处理需要把新的命令发送到应用程序。这方面例子，例如，当接收到一 个订单，这可能意味着客户的账户应当扣除购买商品所需的金额，并必须通知装运方准备打包这批商品。在许多应用中，逻辑将变得更加复杂:如果客户没有及时支付呢?你会马上发货还是等待付款？saga(长事务处理)是CQRS的概念，它负责管理这些复杂的商业事务。在用户界面和数据源之间的瘦数据层，为实际的查询实现提供了一个明确定义的接口。这个数据层通常返回包含查询结果的只读DTO对象。这些DTO的内容通常是由用户界面的需求驱 动的。在大多数情况下,他们直接映射到用户界面的一个特定的视图(也称为table-per-view)。Axon不提供任何应用程序这部分的构件。主要的原因是这非常简单，并且与分层架构并没有太大的区别。Axon模块结构Axon Framework由多个针对CQRS特定问题域的模块组成。根据项目的具体需求，你需要包括一个或多个这些模块。从Axon2.1起,所有模块兼容OSGi。这意味着它们在manifest文件包含所需的头文件,并声明它们导入和导出的包。目前,只有Slf4J bundle(1.7.0 &lt;= 版本&lt; 2.0.0)是必需的。所有其他导入的都被标记为可选,尽管你很可能需要这些。主模块Axon的主要模块已经过完全的测试，强大到足以在苛刻的生产环境中使用。所有这些模 块的maven groupId都是org.axonframework。核心模块顾名思义是Axon的核心组件。如果你使用single-node设置,这个模块可能会提供给你需要的所有组件。其他所有的Axon模块依赖这个模块，所以它必须在classpath中可用。测试模块包含有你可以使用的测试固件来测试基于Axon的组件，比如你的命令处理器、聚 合和Sagas。你通常在运行时不需要这个模块，只需在测试过程中添加到classpath。分布式CommandBus包含了可用于在多个节点发送命令的实现。它配备了JGroups和Spring Cloud连接器，来连接这些节点。AMQP模块提供的组件，允许你打造一个基于AMQP的EventBus，并使用message broker作为分配机制。这允许保证事件送达，即使事件处理器节点暂时不可用。Spring模块允许Axon组件在Spring程序上下文中配置。它还提供了一些针对Spring框架的构件的实现，例如用于在Spring消息信道上发布和检索Axon事件的适配器。MongoDB是一个基于文档的NoSQL数据库，Mongo模块实现事件和saga的存储，并用MongoDB数据库存储事件流和saga。几个AxonFramework组件提供监控信息。Metrics模块提供基于Codehale的基本实现来收集监控信息。与Axon API一起工作QRS是一种架构模式，它不可能提供一个适合所有项目的单一解决方案。显然，Axon Framework并不试图提供这样的解决方案。相反，Axon提供了遵循最佳实践的实现和将每一个实现都调整到符合你的特定需求的手段。几乎所有基础设施构件都提供检查点(如拦截器,解析器等)，允许你向这些构件添 加application-specific行为。大多数情况下，Axon将为那些适合大多数用例的检查点提供实现，如果需要，你可以简单地实现自己的。非基础设施对象，如消息，通常是不可变的。这确保了这些对象在多线程环境中是安全的， 没有副作用的。为了确保定制的最大化，所有Axon组件都使用接口定义。抽象类和具体的实现类提供了帮助你的方式，但框架对你没有任何要求，它总是允许使用该接口构建任何完全自定义实现的构件。Spring的支持Axon Framework对Spring提供了广泛的支持，但不强制你使用Spring来使用Axon。所有的组件都可以以编程方式配置，并且不需要把Spring放在classpath中。然而，如果你使用Spring、使 用Spring的annotation，很多的配置会变得更加容易。作者：勇赴链接：https://www.jianshu.com/p/943f5b3ab139來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"AxonFramework简介","slug":"AxonFramework-简介","date":"2018-08-17T08:19:19.000Z","updated":"2018-09-27T06:22:48.008Z","comments":true,"path":"2018/08/17/AxonFramework-简介/","link":"","permalink":"https://blog.weechang.xyz/2018/08/17/AxonFramework-简介/","excerpt":"Axon是一个轻量级框架，能够帮助开发者通过在架构层面构建可扩展和可伸缩的应用。(注：以DDD面向领域驱动设计为基础的CQRS框架)","text":"Axon是一个轻量级框架，能够帮助开发者通过在架构层面构建可扩展和可伸缩的应用。(注：以DDD面向领域驱动设计为基础的CQRS框架)Axon Framework背景、发展简史随着时间的发展，软件的需求也在不断增长。公司都希望自己的(web)应用程序和自身业务共同发展。这就意味着不仅仅是工程和代码变得更复杂，也意味着功能不断地新增、更改和移除。它令人沮丧的是,一个看似易于实现的功能，却要求开发团队改动整个应用程 序。此外，如今的web程序的目标是针对潜在的数十亿用户，这便使可伸缩性成了必要的条件。虽然有很多的应用和框架围绕着可扩展性问题进行处理，例如GigaSpaces(类似Microsoft Azure) 和 Terracotta(分布式缓存线性扩展平台),它们都存在着一个根本的缺陷。他们通过要求开发人员在开发应用时，使用分层体系架构，来试图解决可扩展性问题。在某些情况下，他们甚至会阻止或严格限制使用一个真正的领域模型，强迫所有领域逻辑都放到服务中。虽然可以很快地构建一个应用程序，最终，这种做法将导致复杂性的增加和开发速度减慢。命令查询职责分离(CQRS)模式解决了这些问题，大幅改变了应用程序的架构。CQRS不是将分离的逻辑分到不同的层 ,逻辑的分离是以改变应用程序的状态或查询为依据。这意味着，执行命令(行为有可能更改应用程序的状态)和查询应用程序数据是由不同的组件执行。这种分离事实上最重要的原因是，他们各自有不同的技术和非技术的要求。当命令执行后，查询组件利用事件同步或异步地进行更新。该更新机制通过事件来完成，正是这种架构如此的可扩展，可伸缩，最终会更易于维护。注意一个完整的CQRS解释不在本文的范围之内。如果你想了解更多关于CQRS的信息, 请访问 Axon Framework的网站: www.axonframework.org。它包含了背景知识的链接。由于CQRS与主导当今软件局面的分层架构有着根本上的不同，开发人员试图找到自己实现这个架构的方式，但往往会掉入各种陷阱。这就是了Axon Framework 产生的原因：帮助开发人员实现CQRS，并让他们只专注于业务逻辑。Axon是什么?Axon Framework 通过支持开发者应用命令查询职责分离(CQRS)架构模式,来帮助构建可伸缩、可扩展和可维护的应用程序。它通过提供最重要的构建块的实现来实现，如：聚合、仓储以及事件总线(事件的调度机制)。此外，Axon提供了对注解(annotation)的支持,它允许你构建聚合和事件监听器而不用将你的代码捆绑到Axon特有的逻辑。这使你能够专注于业务逻辑, 而不是数据传输(the plumbing)，并帮助你使代码更容易隔离测试。Axon不会试图以任何方式隐藏CQRS架构或任何组件。因此，根据团队规模，明智的选择是，每 个团队中有一个或多个对CQRS有着透彻了解的开发人员。不管怎么样,Axon帮助保证把事件交付给正确的事件监听器，并按正确的顺序并发处理它们。这些多线程问题通常很难处理,导致难以跟踪Bug、应用程序完全失去响应。当你的时间紧迫,你可能甚至不想去关心这些问 题。Axon的代码是经过完全测试的,以防止这些类型错误的出现。Axon Framework由多个模块(jar)组成，这些模块提供工具和组件来构建可伸缩的基础设施。Axon核心模块为不同的组件提供了基本的API，并为单JVM的应用程序解决方案提供了简单实现。其他模块提供专业的组件，来解决可伸缩性和高性能的问题。何时使用Axon?并不是每一个应用程序都会从Axon中获益。简单的CRUD (Create, Read, Update, Delete) 应用程序、没有横向扩展预期的应用程序，可能无法从CQRS或Axon中受益。具有以下一个或多个特点的应用程序可能会从CQRS和Axon中受益:在相当长的一段时间内可能会扩展新的功能。例如，一个网上商店可能初期仅仅是一 个订单进度跟踪系统。后期，可能会扩展到对库存信息的管理，确保物品售出后及时的更新 库存。随后，财务人员可能需要销售的财务统计数据等等。虽然很难预测软件项目未来会如何发展，但是大多数类型的应用程序都清楚地呈现为这样。应用程序有一个比较高的读写比，这意味着数据只写几次，但却要读很多次。由于查 询的数据源与用于命令验证的数据源不同，因此才有可能对数据源的快速查询提供优 化。重复数据不再是一个问题，因为当数据改变时，事件也会被发布。应用程序需要不同格式的展示数据，许多应用程序目前不仅仅只停留在显示数据到网 页上。 某些应用程序,例如,每月邮件通知所发生的与用户有关的变化，搜索引擎也是一个例子。他们使用相同的应用程序数据,但在某种意义上这是优化的快速搜索。 报表工具随着时间的变化汇总信息，这同样是同一数据的不同格式。使用Axon，每个数据源都可以彼此独立地实时或定时更新。当应用程序面对不同的受众，清晰地隔离组件时，它也能从Axon中获益。例如网上商 店。员工会在网站上更新产品信息和可用性，同时客户可以下单和查询他们的订单状 态。通过Axon，这些组件可以部署在不同的服务器上，并使用不同的策略进行扩展。 通过事件机制，Axon将分发事件到部署在不同服务器上的订阅组件，使其保持最新的 数据状态。与其他应用程序集成可能是繁琐的工作。严格使用命令和事件定义应用程序的API， 会使它更容易与外部应用程序集成。任何应用程序都可以发送命令或监听应用程序生 成的事件。作者：勇赴链接：https://www.jianshu.com/p/15484ed1fbde來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/categories/AxonFramework/"}],"tags":[{"name":"AxonFramework","slug":"AxonFramework","permalink":"https://blog.weechang.xyz/tags/AxonFramework/"}]},{"title":"【Java学习之从头开始】Java集合-1——HashTable类","slug":"Java集合-1——HashTable类","date":"2018-07-31T06:00:29.000Z","updated":"2018-09-29T07:43:49.425Z","comments":true,"path":"2018/07/31/Java集合-1——HashTable类/","link":"","permalink":"https://blog.weechang.xyz/2018/07/31/Java集合-1——HashTable类/","excerpt":"一、简介和HashMap一样，HashTable 也是一个散列表，它存储的内容是键值对(key-value)映射。HashTable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。HashTable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，HashTable中的映射不是有序的。","text":"一、简介和HashMap一样，HashTable 也是一个散列表，它存储的内容是键值对(key-value)映射。HashTable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。HashTable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，HashTable中的映射不是有序的。1.1 成员变量1234567891011121314// 是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的&quot;key-value键值对&quot;都是存储在Entry数组中的。 private transient Entry&lt;?,?&gt;[] table;// 是Hashtable的大小，它是Hashtable保存的键值对的数量。 private transient int count;// 是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=&quot;容量*加载因子&quot;。private int threshold;// 就是加载因子。 private float loadFactor;// 是用来实现fail-fast机制的private transient int modCount = 0;1.2 构造函数1234567891011// 默认构造函数。public Hashtable() // 指定“容量大小”的构造函数public Hashtable(int initialCapacity) // 指定“容量大小”和“加载因子”的构造函数public Hashtable(int initialCapacity, float loadFactor) // 包含“子Map”的构造函数public Hashtable(Map&lt;? extends K, ? extends V&gt; t)1.3 常用API1234567891011121314151617181920212223242526272829303132333435363738394041424344// 将此哈希表清空，使其不包含任何键。 synchronized void clear()synchronized Object clone()// 测试此映射表中是否存在与指定值关联的键。 boolean contains(Object value) // 测试指定对象是否为此哈希表中的键。 synchronized boolean containsKey(Object key)// 如果此 Hashtable 将一个或多个键映射到此值，则返回 true。 synchronized boolean containsValue(Object value)synchronized Enumeration&lt;V&gt; elements()synchronized Set&lt;Entry&lt;K, V&gt;&gt; entrySet()synchronized boolean equals(Object object)synchronized V get(Object key)synchronized int hashCode()synchronized boolean isEmpty()synchronized Set&lt;K&gt; keySet()synchronized Enumeration&lt;K&gt; keys()synchronized V put(K key, V value)synchronized void putAll(Map&lt;? extends K, ? extends V&gt; map)synchronized V remove(Object key)synchronized int size()synchronized String toString()synchronized Collection&lt;V&gt; values()// 增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素。 protected void rehash()二、HashTable遍历方式2.1 遍历HashTable的键值对第一步：根据entrySet()获取HashTable的“键值对”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。1234567891011// 假设table是Hashtable对象// table中的key是String类型，value是Integer类型Integer integ = null;Iterator iter = table.entrySet().iterator();while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue();&#125;2.2 通过Iterator遍历HashTable的键第一步：根据keySet()获取HashTable的“键”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。1234567891011// 假设table是Hashtable对象// table中的key是String类型，value是Integer类型String key = null;Integer integ = null;Iterator iter = table.keySet().iterator();while (iter.hasNext()) &#123; // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)table.get(key);&#125;2.3 通过Iterator遍历HashTable的值第一步：根据value()获取HashTable的“值”的集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。12345678// 假设table是HashTable对象// table中的key是String类型，value是Integer类型Integer value = null;Collection c = table.values();Iterator iter= c.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125;2.4 通过Enumeration遍历HashTable的键第一步：根据keys()获取HashTable的集合。第二步：通过Enumeration遍历“第一步”得到的集合。1234Enumeration enu = table.keys();while(enu.hasMoreElements()) &#123; System.out.println(enu.nextElement());&#125;2.5 通过Enumeration遍历HashTable的值第一步：根据elements()获取HashTable的集合。第二步：通过Enumeration遍历“第一步”得到的集合。1234Enumeration enu = table.elements();while(enu.hasMoreElements()) &#123; System.out.println(enu.nextElement());&#125;PS:本文章相关代码均已上传至 GitHub 查看详情","categories":[{"name":"Java集合","slug":"Java集合","permalink":"https://blog.weechang.xyz/categories/Java集合/"}],"tags":[{"name":"Java集合","slug":"Java集合","permalink":"https://blog.weechang.xyz/tags/Java集合/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.weechang.xyz/tags/HashTable/"}]},{"title":"【Java学习之从头开始】Java集合-0——HashMap类","slug":"Java集合-0——HashMap类","date":"2018-07-30T09:05:03.000Z","updated":"2018-09-29T09:28:04.770Z","comments":true,"path":"2018/07/30/Java集合-0——HashMap类/","link":"","permalink":"https://blog.weechang.xyz/2018/07/30/Java集合-0——HashMap类/","excerpt":"一、原理实现hashMap的本质是一个数组，数组中每一个元素称为一个Node，Node中存放的是hash值与链表（或红黑树）的键值对。hashMap的存储过程如下:根据 key 计算出它的哈希值 h。假设Node的个数为 n，那么这个键值对应该放在第 (h % n) 个Node中。","text":"一、原理实现hashMap的本质是一个数组，数组中每一个元素称为一个Node，Node中存放的是hash值与链表（或红黑树）的键值对。hashMap的存储过程如下:根据 key 计算出它的哈希值 h。假设Node的个数为 n，那么这个键值对应该放在第 (h % n) 个Node中。如果该Node中已经有了键值对，就使用拉链法解决冲突。hashMap还有一个重要的属性: 负载因子(load factor)，它用来衡量hashMap的 空/满 程度，一定程度上也可以体现查询的效率，计算公式为:负载因子 = 总键值对数 / Node个数负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，hashMap将自动扩容。hashMap在自动扩容时，一般会创建两倍于原来个数的Node，因此即使 key 的hashMap不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。hashMap的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个Node中的链表长度并不发生改变，因此也就不能提高hashMap的查询性能。基于以上总结，细心的读者可能会发现hashMap的两个问题:如果hashMap中本来Node就比较多，扩容时需要重新哈希并移动数据，性能影响较大。如果哈希函数设计不合理，hashMap在极端情况下会变成线性表，性能极低。于是针对这种问题，java8中采用了红黑树与链表相互转换的方式来解决。当Node中的键值对大于8的时候，链表结构将变为树形结构。该方式能够在一定程度上解决链表的查询效率问题，但是最好的解决方案还是在hash函数的设计上，尽量减少hash冲突。根据概率论分析，理想状态下，hashMap中的Node满足泊松分布当负载因子为 0.75 时，上述公式中 λ 约等于 0.5，因此箱子中元素个数和概率的关系如下:数量概率00.6065306610.3032653320.0758163330.0126360640.0015795250.0001579560.0000131670.0000009480.00000006二、简介2.1 成员变量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 默认初始容量 - 必须是2的幂。 * 个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * * 最大容量。 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * 默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。 */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * 使用树而不是链表的计数阈值。 *如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。 * 这个值表示当某个链表长度大于 8 时，有可能会转化成树。 * 备注：从JDK1.8开始，HashMap容量在大于一定值后，底层将会由链表结构转为树形结构 */static final int TREEIFY_THRESHOLD = 8;/** * 当容量小于该值时，将由树状结构转为链表结构 */static final int UNTREEIFY_THRESHOLD = 6;/** * 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。 * 这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。 */static final int MIN_TREEIFY_CAPACITY = 64;// 数组，该数组用于存储不同的hash值与链表的对应关系transient Node&lt;K,V&gt;[] table;// 单向链表，该链表用于处理哈希冲突Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;// hashMap长度int size;// 用来实现fail-fast机制的。 int modCount; // HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=&quot;容量*加载因子&quot;，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 int threshold; // 加载因子 final float loadFactor;三、常用方法3.1 构造方法1234567891011121314151617/*** @param initialCapacity 初始大小* @param loadFactor 扩容因子*/public HashMap(int initialCapacity, float loadFactor)/***@param initialCapacity 初始大小*/public HashMap(int initialCapacity)public HashMap()/***@param m Map子类*/public HashMap(Map &lt; ? extends K, ? extends V&gt; m)3.2 对外方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*** 清空hashMap* 通过将所有Node置空实现*/public void clear()/*** 是否存在键为key的键值对*/public boolean containsKey(Object key)/*** 是否存在值为value的键值对*/public boolean containsValue(Object value)/*** 获取所有的键值对*/public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()/*** 获取所有键值对 值的集合*/public Collection&lt;V&gt; values()/*** 获取所有键值对 键的集合*/public Set&lt;K&gt; keySet()/*** 根据键值对的键获取值*/public V get(Object key)/*** put 一个键值对*/public V put(K key, V value)/***将&quot;m&quot;的全部元素都添加到HashMap中*/public void putAll(Map&lt;? extends K, ? extends V&gt; m)/***移除键为key的元素*/public V remove(Object key)四、HashMap的遍历4.1 遍历HashMap的键值对第一步：根据entrySet()获取HashMap的“键值对”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。1234567891011// 假设map是HashMap对象// map中的key是String类型，value是Integer类型Integer integ = null;Iterator iter = map.entrySet().iterator();while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue();&#125;4.2 遍历HashMap的键第一步：根据keySet()获取HashMap的“键”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。1234567891011// 假设map是HashMap对象// map中的key是String类型，value是Integer类型String key = null;Integer integ = null;Iterator iter = map.keySet().iterator();while (iter.hasNext()) &#123; // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key);&#125;4.3 遍历HashMap的值第一步：根据value()获取HashMap的“值”的集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。12345678// 假设map是HashMap对象// map中的key是String类型，value是Integer类型Integer value = null;Collection c = map.values();Iterator iter= c.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125;PS:本文章相关代码均已上传至 GitHub 查看详情","categories":[{"name":"Java集合","slug":"Java集合","permalink":"https://blog.weechang.xyz/categories/Java集合/"}],"tags":[{"name":"Java集合","slug":"Java集合","permalink":"https://blog.weechang.xyz/tags/Java集合/"},{"name":"HashMap","slug":"HashMap","permalink":"https://blog.weechang.xyz/tags/HashMap/"}]},{"title":"手把手教学，教你把你的个人项目推送到maven中央仓库","slug":"手把手教学，教你把你的个人项目推送到maven中央仓库","date":"2018-07-20T08:43:08.000Z","updated":"2018-09-29T09:28:04.795Z","comments":true,"path":"2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/","link":"","permalink":"https://blog.weechang.xyz/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/","excerpt":"前言最近闲下来了，想要自己造点小轮子用，方便自己在不同项目使用，同时想偷懒，不想每次都在项目里面copy代码。于是想到了重要仓库这个东西，把自己的代码托管到github（虽然现在的github已经不再单纯），然后发布jar包到maven中央仓库，以后每个项目都只用引入maven依赖就可以了。同时还能方便好基友们使用，万一哪一天好基友高兴就献身了呢，想想就有点小激动呢。好了废话不多说，下面正式开始手把手教学活动。","text":"前言最近闲下来了，想要自己造点小轮子用，方便自己在不同项目使用，同时想偷懒，不想每次都在项目里面copy代码。于是想到了重要仓库这个东西，把自己的代码托管到github（虽然现在的github已经不再单纯），然后发布jar包到maven中央仓库，以后每个项目都只用引入maven依赖就可以了。同时还能方便好基友们使用，万一哪一天好基友高兴就献身了呢，想想就有点小激动呢。好了废话不多说，下面正式开始手把手教学活动。附上小轮子传送门给感兴趣的小伙伴将项目发布到maven仓库需要以下几步:1.在sonatype中创建issue2.使用gpg生成秘钥3.配置Maven进行deploy和release1 在sonatype中创建issue首先我们需要在https://issues.sonatype.org/secure/Dashboard.jspa中新建一个issues。如果没有sonatype账号的话，分分钟注册一个创建完成后就是如下图示这个时候只需要耐心等待工作人员审核就行了，因为我的domain问题，经历了二次审核，但是都很快，一般提交后两个小时内就会有结果。当issues状态变为Resolved就可以继续下一步操作了。2 使用gpg生成秘钥2.1 安装选择对应的OS版本进行下载安装即可，下载地址传送门：https://www.gnupg.org/download/index.html2.2 生成key首先查看安装成功没有--version``` （MAC 和 Linux系统需要 gpg2 --version）12345678910通过 ```gpg --gen-key``` 生成key，也可以通过UI界面生成和管理key&#123;% asset_img 生成key.png 手把手教学，教你把你的个人项目推送到maven中央仓库 %&#125;运行后gpg要求你选择加密算法，过期时间等等，这些直接选择默认值即可。通过对比发现，gpg 2.0以上的版本运行gpg --gen-key命令 会跳过这些步骤。之后gpg要求你输入姓名，邮箱以及关键的Passphrase，依次输入即可。然后gpg为你生成了一对秘钥。通过```gpg --list-keys```查看生成的key列表&#123;% asset_img 秘钥列表.png 手把手教学，教你把你的个人项目推送到maven中央仓库 %&#125;这里可以看到我的公钥是：34754DFE562C10E1A09907B7F4797C9A95E36DB6，记住这个key，下面我们需要用到。## 2.3 上传公钥生成秘钥后，我们需要把公钥上传到服务器上。运行以下命令：```gpg2 --keyserver hkp://pool.sks-keyservers.net --send-keys 34754DFE562C10E1A09907B7F4797C9A95E36DB6（刚才生成的公钥）3 配置Maven3.1 配置maven setting.xml需要在本地的maven配置server 和 profile 两个地方，啰嗦的话就不多少了，直接上配置：12345&lt;server&gt; &lt;id&gt;ossrh&lt;/id&gt; &lt;username&gt;第一步注册的用户名&lt;/username&gt; &lt;password&gt;第一步注册的密码&lt;/password&gt;&lt;/server&gt;12345678910 &lt;profile&gt; &lt;id&gt;ossrh&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;gpg.executable&gt;gpg(MAC 和 Linux用户使用gpg2)&lt;/gpg.executable&gt; &lt;gpg.passphrash&gt;生成密钥时输入的密码&lt;/gpg.passphrash&gt; &lt;/properties&gt;&lt;/profile&gt;3.2 配置项目的pom.xml具体的配置可以查看小轮子里面的pom设置 https://github.com/weechang/JUtil/blob/master/pom.xml首先需要添加指向sonatype仓库的1234567891011&lt;distributionManagement&gt; &lt;snapshotRepository&gt; &lt;id&gt;ossrh&lt;/id&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;repository&gt; &lt;id&gt;ossrh&lt;/id&gt; &lt;name&gt;Maven Central Staging Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt;继续配置pfofiles,添加各种推送、DOC、加密的插件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;release&lt;/id&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.sonatype.plugins&lt;/groupId&gt; &lt;artifactId&gt;nexus-staging-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;extensions&gt;true&lt;/extensions&gt; &lt;configuration&gt; &lt;serverId&gt;ossrh&lt;/serverId&gt; &lt;nexusUrl&gt;https://oss.sonatype.org/&lt;/nexusUrl&gt; &lt;autoReleaseAfterClose&gt;true&lt;/autoReleaseAfterClose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-javadocs&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;sign-artifacts&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;sign&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt;&lt;/profiles&gt;然后还可以添加一些开发者信息和license信息，具体的就不多说了。具体可以参考小轮子的配置3.3 部署到中央仓库运行以下代码进行deploymvn clean deploy -P release如下图表示成功部署到中央仓库因为我们在pom中添加了自动发布插件，所以可以不用管理，直接到中央仓库去查看就能看到你发布的项目了PS:在部署过成功可能会遇到401的问题，具体请参考传送门 https://stackoverflow.com/questions/24830610/why-am-i-getting-a-401-unauthorized-error-in-maven","categories":[{"name":"开源之路","slug":"开源之路","permalink":"https://blog.weechang.xyz/categories/开源之路/"}],"tags":[{"name":"手把手教学","slug":"手把手教学","permalink":"https://blog.weechang.xyz/tags/手把手教学/"},{"name":"maven中央仓库","slug":"maven中央仓库","permalink":"https://blog.weechang.xyz/tags/maven中央仓库/"}]},{"title":"【Java学习之从头开始】Java基础-1——String类","slug":"java基础-1——String类","date":"2018-06-08T05:59:02.000Z","updated":"2018-09-29T07:47:10.788Z","comments":true,"path":"2018/06/08/java基础-1——String类/","link":"","permalink":"https://blog.weechang.xyz/2018/06/08/java基础-1——String类/","excerpt":"一、简介1.1 成员变量12345678910public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; private final char value[]; private int hash; // Default to 0 private static final long serialVersionUID = -6849794470754667710L; private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];&#125;从源码可以看出，String底层是通过一个不可变的字符串常量来进行维护的。所以只要一个字符改变就会生成一个新的String类型对象。","text":"一、简介1.1 成员变量12345678910public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; private final char value[]; private int hash; // Default to 0 private static final long serialVersionUID = -6849794470754667710L; private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];&#125;从源码可以看出，String底层是通过一个不可变的字符串常量来进行维护的。所以只要一个字符改变就会生成一个新的String类型对象。1.2 构造方法1234567891011121314String()String(String original)String(char value[])String(char value[], int offset, int count)String(int[] codePoints, int offset, int count)String(byte bytes[], int offset, int length, String charsetName)String(byte bytes[], int offset, int length, Charset charset)String(byte bytes[], String charsetName)String(byte bytes[], Charset charset)String(byte bytes[], int offset, int length)String(byte bytes[])String(StringBuffer buffer)String(StringBuilder builder)String(char[] value, boolean share)二、创建方式的区别2.1 直接赋值方式String str = “str”; //直接赋值方式创建对象是在方法区的常量池2.2 构造方法创建String str = “str”;//通过构造方法创建字符串对象是在堆内存1234567891011121314151617181920public class JavaString &#123; /** * 创建方式的比较 */ public void createMethod() &#123; String str1 = &quot;str&quot;; String str2 = new String(&quot;str&quot;); String str3 = str1; String str4 = str2; System.out.println(str1 == str2); // false System.out.println(str1 == str3); // true System.out.println(str2 == str4); // true System.out.println(str1 == str4); // false &#125; public static void main(String[] args) &#123; JavaString javaString = new JavaString(); javaString.createMethod(); &#125;&#125;2.3 内存分析在字符串中，如果采用直接赋值的方式（String str=”str”）进行对象的实例化，则会将匿名对象“str”放入字符串常量池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象。这样，所有直接赋值的String对象，如果利用相同的“str”，则String对象==返回true；PS：字符串还可以采用手工入池的方式12345678/** * 字符串手工入池 */public void intern()&#123; String str1 = new String(&quot;str&quot;).intern(); String str2 = &quot;str&quot;; System.out.println(str1 == str2); // true&#125;2.4 区别1）直接赋值（String str = “str”）：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。2）构造方法（String str= new String(“str”);）:会开辟两块堆内存空间（具体原因阐述见此处），其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public String intern();方法进行手工入池。PS:String类对象一旦声明则不可以改变；而改变的只是地址，原来的字符串还是存在的，并且产生垃圾。三、字符串常量池3.1 字符串常量池概述1）常量池表（Constant_Pool table）Class文件中存储所有常量（包括字符串）的table。这是Class文件中的内容，还不是运行时的内容，不要理解它是个池子，其实就是Class文件中的字节码指令。2）运行时常量池（Runtime Constant Pool） JVM内存中方法区的一部分，这是运行时的内容这部分内容（绝大部分）是随着JVM运行时候，从常量池转化而来，每个Class对应一个运行时常量池上一句中说绝大部分是因为：除了 Class中常量池内容，还可能包括动态生成并加入这里的内容3）字符串常量池（String Pool）这部分也在方法区中，但与Runtime Constant Pool不是一个概念，String Pool是JVM实例全局共享的，全局只有一个JVM规范要求进入这里的String实例叫“被驻留的interned string”，各个JVM可以有不同的实现，HotSpot是设置了一个哈希表StringTable来引用堆中的字符串实例，被引用就是被驻留。3.2 亨元模式其实字符串常量池这个问题涉及到一个设计模式，叫“享元模式”，顾名思义 - - - &gt; 共享元素模式也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素Java中String部分就是根据享元模式设计的，而那个存储元素的地方就叫做“字符串常量池 - String Pool”3.3 详细分析举例：12int x = 10;String y = &quot;hello&quot;;1)首先，10和”hello”会在经过javac（或者其他编译器）编译过后变为Class文件中constant_pool table的内容2)当我们的程序运行时，也就是说JVM运行时，每个Classconstant_pool table中的内容会被加载到JVM内存中的方法区中各自Class的Runtime Constant Pool。3)一个没有被String Pool包含的Runtime Constant Pool中的字符串（这里是”hello”）会被加入到String Pool中（HosSpot使用hashtable引用方式），步骤如下： 一是：在Java Heap中根据”hello”字面量create一个字符串对象二是：将字面量”hello”与字符串对象的引用在hashtable中关联起来，键 - 值 形式是：”hello” = 对象的引用地址。另外来说，当一个新的字符串出现在Runtime Constant Pool中时怎么判断需不需要在Java Heap中创建新对象呢？策略是这样：会先去根据equals来比较Runtime Constant Pool中的这个字符串是否和String Pool中某一个是相等的（也就是找是否已经存在），如果有那么就不创建，直接使用其引用；反之，如上3。如此，就实现了享元模式，提高的内存利用效率。举例：使用String s = new String(“hello”); 会创建2个对象。首先，出现了字面量”hello”，那么去String Pool中查找是否有相同字符串存在，因为程序就这一行代码所以肯定没有，那么就在Java Heap中用字面量”hello”首先创建1个String对象。接着，new String(“hello”)，关键字new又在Java Heap中创建了1个对象，然后调用接收String参数的构造器进行了初始化。最终s的引用是这个String对象。四、常用方法4.1 基本操作1234567891011// 获取字符串的长度int length()// 返回指定字符在该字符串中第一次出现的位置，若无则返回-1int indexOf(int ch)// 返回指定字符在该字符串中最后一次出现的位置，若无则返回-1int lastIndexOf(int ch)// 返回指定位置的字符，其中index取值范围为（0~字符长度-1）char charAt(int index)4.2 转换操作1234567891011// 转换为字符数组char[] toCharArray()// 将传入值转换为String （常见入参为Integer、Long、Double等）String valueOf(xxx)// 转换为小写String toLowerCase()// 转换为大写String toUpperCase()4.3 替换操作12345// 使用 replacement替换原字符串中所有的targetString replace(CharSequence target, CharSequence replacement)// 替换字符串中的所有空格String trim()4.4 截取操作12345// 根据 regex 将原字符串拆分为 数组String[] split(String regex)// 截取 beginIndex 到 endIndex之间的字符串String substring(int beginIndex, int endIndex)4.5判断操作1234567891011121314151617// 判断值是否相等boolean equals(Object anObject)// 忽略大小写的判断boolean equalsIgnoreCase(String anotherString)// 是否以prefix 开头startsWith(String prefix)// 是否以prefix 结尾endsWith(String prefix)// 是否包含 sboolean contains(CharSequence s)// 是否是空字符串boolean isEmpty()#五、String、StringBuffer、StringBuilder5.1 异同点同：三者底层都是通过字符数组来进行维护的。异：StringStringBufferStringBuilder是否可变×√√线程安全√√×5.2 效率比较通常情况下：StringBuilder &gt; StringBuffer &gt; StringPS:本文章相关代码均已上传至 GitHub 查看详情","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://blog.weechang.xyz/categories/Java基础/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://blog.weechang.xyz/tags/Java基础/"},{"name":"String","slug":"String","permalink":"https://blog.weechang.xyz/tags/String/"}]},{"title":"【Java学习之从头开始】Java基础-0——Object类","slug":"java基础-0——Object类","date":"2018-06-07T10:39:22.000Z","updated":"2018-09-29T07:47:11.027Z","comments":true,"path":"2018/06/07/java基础-0——Object类/","link":"","permalink":"https://blog.weechang.xyz/2018/06/07/java基础-0——Object类/","excerpt":"从这篇文章起就正式开始Java学习之旅了。java中，万物皆对象，所以第一篇先学习Java的Object类，循序渐进。","text":"从这篇文章起就正式开始Java学习之旅了。java中，万物皆对象，所以第一篇先学习Java的Object类，循序渐进。一、getClass()1public final native Class&lt;?&gt; getClass();返回此Object的运行时类类型。如： class io.github.weechang.java.base.JavaObject。不可重写，要调用的话，一般和getName()联合使用，如getClass().getName(); // io.github.weechang.java.base.JavaObject二、hashCode()1public native int hashCode();返回该对象的哈希值。如：123961122该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。如HashSet、HashMap。如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。三、equals()123public boolean equals(Object obj) &#123; return (this == obj);&#125;Object中的equals方法是直接判断this和obj是否是同一对象，所谓同一对象就是指内存中同一块存储单元，如果this和obj指向的是同一块内存对象，则返回true,如果this和obj指向的不是同一块内存，则返回false。1234注意：即便是内容完全相等的两块不同的内存对象，也返回false。 如果是同一块内存，则object中的equals方法返回true,如果是不同的内存，则返回false 如果希望不同内存但相同内容的两个对象equals时返回true,则我们需要重写父类的equal方法 Java中一部分类已经重写了object中的equals方法（这样就是比较内容是否相等了），如基本的包装类型 Integer、Long、Boolean等，还有String。四、clone()1protected native Object clone() throws CloneNotSupportedException;保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。Java里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法（实现深复制）。4.1 clone与copy的区别在通常操作中，我们常采用的赋值方式为 User u1 = new User(); User u2 = u1;此时，User u2 = u1这种赋值方式就称为copy。此时的赋值只是简单地将u1所指向的内存地址赋值给了u2,所以此时u1、u2引用的是同一块内存空间。所以对u1或者u2任意对象的操作如u1.setId(2);都会带来另一对象的值的改变，此时可以发现u2.getId() 返回值也为2。若我们不希望带来这样的改变，就需要用到clone.User u2 = u1.clone();等价于User u2 = new User(); u2.setId(u1.getId());copy：只是简单地将内存地址进行引用，实则两者是同一对象,任一对象值的改变，会带来另一对象值的改变。clone: 两者是不同内存地址的对象，两者值只有在初始clone时一致，一个对象值的改变，不会带来另一对象值的改变。4.2 Shallow Clone与Deep CloneObject在对某个对象实施仅仅是简单地执行域对域的copy，这就是Shallow Clone。若User中存在一属性为 Date birthDay，此时u1与U2的引诱关系图如下：此时，除了基本数据类型是值的clone外，非基本数据类型都只是引用的clone。所以此时clone对象与原对象存在一部分相同的引用。此时任一对象的非基本类型的值改变，会导致另一对象的值的改变。若要解决此问题就需要Deep Clone。针对User 对象可以对clone方法进行改造，如下：123456@Overrideprotected Object clone() throws CloneNotSupportedException &#123; User cloned = (User) super.clone(); cloned.birthDay = (Date) birthDay.clone(); return cloned;&#125;五、toString()123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125;返回值为 字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。如 ：io.github.weechang.java.base.obj.User@762efe5d六、notify()1public final native void notify();该方法唤醒在该对象上等待的某个线程七、notifyAll()1public final native void notifyAll();该方法唤醒在该对象上等待的所有线程。八、wait()123public final void wait() throws InterruptedException &#123; wait(0);&#125;1public final native void wait(long timeout) throws InterruptedException;12345678910111213141516171819/***@param timeout 等待该线程终止的时间最长为timeout毫秒。 *@param nanos 等待时间为 timeout毫秒+nanos纳秒*/public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(&quot;timeout value is negative&quot;); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125;wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。九、finalize()1protected void finalize() throws Throwable &#123; &#125;该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。Java允许在类中定义一个名为finalize()的方法。它的工作原理是：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法。并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。1234关于垃圾回收，有三点需要记住： 1、对象可能不被垃圾回收。只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。 2、垃圾回收并不等于“析构”。 3、垃圾回收只与内存有关。使用垃圾回收的唯一原因是为了回收程序不再使用的内存。123finalize()的用途： 无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。 不过这种情况一般发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式。PS:本文章相关代码均已上传至 GitHub 查看详情","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://blog.weechang.xyz/categories/Java基础/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://blog.weechang.xyz/tags/Java基础/"},{"name":"Object","slug":"Object","permalink":"https://blog.weechang.xyz/tags/Object/"}]}]}