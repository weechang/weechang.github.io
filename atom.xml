<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>耒耒耒耒耒</title>
  
  <subtitle>张未的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.weechang.xyz/"/>
  <updated>2018-08-20T05:27:26.611Z</updated>
  <id>https://blog.weechang.xyz/</id>
  
  <author>
    <name>耒耒耒耒耒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AxonFramework工作单元</title>
    <link href="https://blog.weechang.xyz/2018/08/20/AxonFramework%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/"/>
    <id>https://blog.weechang.xyz/2018/08/20/AxonFramework工作单元/</id>
    <published>2018-08-20T05:17:12.000Z</published>
    <updated>2018-08-20T05:27:26.611Z</updated>
    
    <content type="html"><![CDATA[<p>工作单元是Axon Framework的一个重要的概念,虽然在大多数情况下你可能不太直接与它交互。消息的处理被视为一个独立单元。工作单元的目的是在处理一条消息(命令或事件)期间去协调行为的执行。组件可以在工作单元每一个阶段执行注册行为,如onPrepareCommit或onCleanup。</p><a id="more"></a><p>你可能不太需要直接访问工作单元，主要使用Axon提供的构件来访问。不管出于什么原因，如果你需要访问它，有几种方式可以获得它。处理器可以在处理函数中通过一个参数来接收工作单元。如果你使用注解，你可以添加一个UnitOfWork类型参数到你被注解的函数。在其他地方,你可以通过调用CurrentUnitOfWork.get()把工作单元绑定到当前线程。注意，如果没有把工作单元绑定到当前线程，这个方法将抛出一个异常。使用CurrentUnitOfWork.isStarted()可检测它是否可用。</p><p>需要访问当前工作单元的一个原因是，在消息处理过程中附加需要多次重复使用的资源，或者，如果创建资源时需要在工作单元结束时进行清理工作。在这种情况下,unitOfWork.getOrComputeResource()和生命周期回调方法,如onRollback(),afterCommit()和onCleanup()，允许你在工作单元处理期间，注册资源和声明行为。</p><blockquote><p><b>注意</b><br>注意工作单元只是变化的缓存，不是事务的替代品。尽管当工作单位被提交时，所有的阶段更改都被提交，但它的提交不是原子性的。这意味着，当提交失败时一些变化可能会被持久化，而另一些则没有。最佳实践要求命令不应该包含多个行为。如果你坚持这种做法，一个工作单元只包含一个单一的行为，从而将使其被安全使用。如果你的工作单元中有更多的行为，那么你可以考虑将一个事务附加到工作单元的提交。当工作单元提交时，使用unitOfWork.onCommit(. .)注册一个行为。*</p></blockquote><p>你的处理器可以抛出一个异常作为处理消息的结果。默认情况下,未经检测的异常将导致UnitOfWork回滚所有的更改。结果是 ，预定的副作用被撤消。</p><p>Axon 提供了一些开箱即用的回滚策略:</p><ul><li>RollbackConfigurationType.NEVER ,总是提交工作单元。</li><li>RollbackConfigurationType.ANY_THROWABLE ,当异常发生时总是回滚。</li><li>RollbackConfigurationType.UNCHECKED_EXCEPTIONS，错误和运行时异常回滚。</li><li>RollbackConfigurationType.RUNTIME_EXCEPTION ,运行时异常回滚（但不是错误）</li></ul><p>当使用Axon 组件处理消息时，将自动为你管理工作单元的生命周期。如果你选择不使用这些组件，但实现自己的处理，则需要以编程方式启动和提交(或回滚)工作单元。</p><p>在大多数情况下，DefaultUnitOfWork将为你提供你所需要的功能。它在单线程中处理进程。在一个工作单元上下文中执行一个任务，可以new一个DefaultUnitOfWork并简单地调用UnitOfWork.execute(Runnable)或UnitOfWork.executeWithResult(Callable)函数。典型的用法如下:</p><pre>// then, either use the autocommit approach: uow.executeWithResult(() -> ... logic here);// or manually commit or rollback: try {    // business logic comes here    uow.commit();} catch (Exception e) {    uow.rollback(e);    // maybe rethrow...}```</pre> <p>一个工作单元了解各个阶段。每当它进展到不同的阶段时，就会通知UnitOfWork监听器。</p><p><strong>活动阶段:</strong>这是开始工作单元的地方。工作单元通常在当前线程中的这个阶段被注册(通过CurrentUnitOfWork.set(UnitOfWork))。随后，消息通常在此阶段由消息处理器处理。</p><p><strong>提交阶段:</strong>在处理完消息之后，但是在提交工作单元之前，将调用onPrepareCommit监听器。如果一个工作单元被绑定到一个事务中，那么将调用onCommit监听器来提交任何的支持事务。当提交成功时，将调用afterCommit监听器。如果在提交或任何步骤之前失败，将调用onRollback监听器。如果可用，则消息处理器的结果包含在工作单元的ExecutionResult中。</p><p><strong>清理阶段:</strong>在此阶段，该工作单元(如锁)所持有的任何资源都将被释放。如果多个工作单元被嵌套，那么清理阶段将被推迟到外部的单元工作都准备好清理为止。</p><p>消息处理过程可以被认为是一个原子过程;它要么完全被处理，要么完全不被处理。Axon Framework使用工作单元来跟踪消息处理器执行的操作。在处理器完成后，Axon 将尝试提交在工作单元中注册的操作。</p><p>将事务绑定到工作单元是可能的。许多组件，例如CommandBus的实现和所有异步处理事件处理器，都允许你配置事务管理器（Transaction Manager）。然后，该事务管理器将被用于创建事务，以绑定到用于管理消息处理的工作单元。</p><p>当应用程序组件在消息处理的不同阶段需要资源时，比如，数据库连接或实体管理器(EntityManager)，这些资源能</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/3814c293f4fc" target="_blank" rel="noopener">https://www.jianshu.com/p/3814c293f4fc</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作单元是Axon Framework的一个重要的概念,虽然在大多数情况下你可能不太直接与它交互。消息的处理被视为一个独立单元。工作单元的目的是在处理一条消息(命令或事件)期间去协调行为的执行。组件可以在工作单元每一个阶段执行注册行为,如onPrepareCommit或onCleanup。&lt;/p&gt;
    
    </summary>
    
      <category term="DDD" scheme="https://blog.weechang.xyz/categories/DDD/"/>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/DDD/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
      <category term="DDD" scheme="https://blog.weechang.xyz/tags/DDD/"/>
    
      <category term="CQRS" scheme="https://blog.weechang.xyz/tags/CQRS/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch查询报错fielddata=true</title>
    <link href="https://blog.weechang.xyz/2018/08/17/ElasticSearch%E6%9F%A5%E8%AF%A2%E6%8A%A5%E9%94%99fielddata-true/"/>
    <id>https://blog.weechang.xyz/2018/08/17/ElasticSearch查询报错fielddata-true/</id>
    <published>2018-08-17T09:01:18.000Z</published>
    <updated>2018-08-17T09:04:10.509Z</updated>
    
    <content type="html"><![CDATA[<p>记录下ElasticSearch查询报错的解决方案，今天在java中查询ElasticSearch的数据发生报错。</p><a id="more"></a><pre>java.lang.IllegalArgumentException: Fielddata is disabled on text fields by default. Set fielddata=true on [pkgts_date] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory.</pre><p>百度了一下。特汇总解决方法。<br>首先，看到这个报错。很自然的就去将pkgts_date字段设置  fielddata=true.但是这样会占用比较多的内存。导致性能下降。因此找到了另外的解决方法。<br>遇到这个错误是因为你尝试对一个text类型的字段做排序，而text类型的字段是要分词的。 一来词典很大，性能会很差；二来排序结果是词典里的词，而并非整个text的内容。 出于这2点原因，ES5.x以后对于text类型默认禁用了fielddata，防止对text字段一些错误的操作（排序，聚合，script)而给heap造成很大的压力。<br>如果一定有对该字段按照文本字母序做排序的需求，可以将该字段定义为multi-filed，例如:</p><pre>    PUT my_index    {      "mappings": {        "my_type": {          "properties": {            "city": {              "type": "text",              "fields": {                "raw": {                   "type":  "keyword"                }              }            }          }        }      }    }</pre><p>上面的city是text类型，适合做全文搜索，然后排序的时候可以用其keyword类型即city.raw。  这样排序结果是正确的，并且keyword字段是通过doc values排序的，内存消耗远小于fielddata。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下ElasticSearch查询报错的解决方案，今天在java中查询ElasticSearch的数据发生报错。&lt;/p&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="ElasticSearch" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/ElasticSearch/"/>
    
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="ElasticSearch" scheme="https://blog.weechang.xyz/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework消息、命令和事件</title>
    <link href="https://blog.weechang.xyz/2018/08/17/AxonFramework%E6%B6%88%E6%81%AF%E3%80%81%E5%91%BD%E4%BB%A4%E5%92%8C%E4%BA%8B%E4%BB%B6/"/>
    <id>https://blog.weechang.xyz/2018/08/17/AxonFramework消息、命令和事件/</id>
    <published>2018-08-17T08:38:47.000Z</published>
    <updated>2018-08-20T05:24:29.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息传送的概念"><a href="#消息传送的概念" class="headerlink" title="消息传送的概念"></a>消息传送的概念</h1><p>消息是Axon的核心概念之一。组件之间的所有通信都使用消息对象完成。这为这些组件提供了位置透明性，在必要时需要能够进行扩展和分发这些组件。</p><p>尽管所有这些消息都实现了消息接口，但不同类型的消息及其处理方式之间有明显的区别。所有消息包含payload、元数据和唯一标识符。消息的payload是消息的功能说明。该对象的类名组合与它所携带的数据，描述了消息的应用程序的含义。元数据允许你描述正在发送消息的上下文。例如，你可以存储跟踪信息，以允许跟踪消息的来源或原因。你还可以存储信息以描述正在执行命令的安全上下文。</p><a id="more"></a><blockquote><p><b>注意</b><br>注意所有消息都是不可变的。将数据存储在一个消息中，实际上意味着在前一个消息的基础上，创建一个添加了额外信息的新消息。这保证了消息在多线程和分布式环境中使用是安全的。</p></blockquote><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>命令描述改变应用程序状态的意图。命令用一个CommandMessage来包装POJO（最好是只读的）来实现。</p><p>命令总是有一个确切的目的地。虽然发送者并不关心由哪个组件来处理命令或该组件驻留在哪里，但它可能对它的结果感兴趣。这就是命令总线上发送命令消息后，允许返回结果的原因。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>事件是描述应用程序中已经发生的事情的对象。聚合是事件的典型来源。当聚合中发生重要的事情时，它将引发一个事件。在Axon Framework中，事件可以是任何对象。非常希望你能确保所有的事件都是可序列化的。</p><p>当事件被分发时，Axon把他们包装在一个EventMessage中。实际使用的消息类型取决于事件的来源。当一个事件是由一个聚合引发时，它被包装在DomainEventMessage（继承自EventMessage）中。所有其他事件都被包装在一个EventMessage中。除了像唯一标识这种常见的消息属性，EventMessage还包含一个时间戳。DomainEventMessage额外包含类型和聚合的标识符，它还在聚合的事件流中包含事件的序号,以允许重现事件的顺序。</p><blockquote><p><b>注意</b><br>尽管DomainEventMessage总包含一个对聚合标识符的引用,你也应该包括实际事件本身的标识符。EventStore通过DomainEventMessage中的标识符来存储事件，标识符可能并不总是会提供一个可靠值用于其他目标。</p></blockquote><p>原始事件对象存储为EventMessage的payload。紧挨着的payload,你可以将信息存储在一个事件消息的元数据中。元数据的目的是存储关于事件的额外信息,而不是业务信息。审计信息就是一个典型的例子。它可以让你看到在哪些情况下，一个事件会被引发，比如用户帐户触发进程，或处理事件的机器名称。</p><blockquote><p><b>注意</b><br>一般来说，你不应该基于事件消息的元数据中的信息进行业务决策。如果是这样的话，你可能有附加的信息，而不是事件本身的一部分信息。元数据通常用于报告、审计和跟踪。</p></blockquote><p>虽然不是强制性的，但让领域事件不可变是一种很好的做法，最好是将所有字段声明为final并在构造函数中初始化。如果事件构造太麻烦可考虑使用建造者模式(Builder pattern )。</p><blockquote><p><b>注意</b><br>虽然领域事件在技术上表示状态的变化,你也应该试图在事件中捕捉状态意图。一个好的实践是使用一个抽象的领域事件实现来捕获某些状态已经改变了这一事实,并使用一个抽象类具体的sub-implementation来表示变化的意图。例如,你可以有一个AddressChangedEvent抽象类，并用实现ContactMovedEvent和AddressCorrectedEvent这两个子类来达到捕获状态变化的意图。一些监听器不关心这些意图(例如,数据库更新事件监听器)，将监听抽象类型。其他关心这些意图监听器，它们将监听具体的子类(例如发送一个地址变更确认电子邮件给消费者)。<br><img src="/2018/08/17/AxonFramework消息、命令和事件/state_change.jpg" title="State change"></p></blockquote><p>当在事件总线分发事件时,你需要把它包装在一个事件消息中。GenericEventMessage是一个允许你将你的事件包装到一个消息的实现。你可以使用构造函数,或静态方法：asEventMessage()。 后者检查给出的参数是否已经实现了消息接口，如果是这样，它直接返回（如果它实现了EventMessage），或者返回一个使用给定消息的payload和元数据来实例化的GenericEventMessage。如果一个事件通过聚合发布，Axon将自动把事件包装在一个DomainEventMessage中，包含聚合的标识符,类型和序列号。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/e7abb5a228e9" target="_blank" rel="noopener">https://www.jianshu.com/p/e7abb5a228e9</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;消息传送的概念&quot;&gt;&lt;a href=&quot;#消息传送的概念&quot; class=&quot;headerlink&quot; title=&quot;消息传送的概念&quot;&gt;&lt;/a&gt;消息传送的概念&lt;/h1&gt;&lt;p&gt;消息是Axon的核心概念之一。组件之间的所有通信都使用消息对象完成。这为这些组件提供了位置透明性，在必要时需要能够进行扩展和分发这些组件。&lt;/p&gt;
&lt;p&gt;尽管所有这些消息都实现了消息接口，但不同类型的消息及其处理方式之间有明显的区别。所有消息包含payload、元数据和唯一标识符。消息的payload是消息的功能说明。该对象的类名组合与它所携带的数据，描述了消息的应用程序的含义。元数据允许你描述正在发送消息的上下文。例如，你可以存储跟踪信息，以允许跟踪消息的来源或原因。你还可以存储信息以描述正在执行命令的安全上下文。&lt;/p&gt;
    
    </summary>
    
      <category term="DDD" scheme="https://blog.weechang.xyz/categories/DDD/"/>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/DDD/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
      <category term="DDD" scheme="https://blog.weechang.xyz/tags/DDD/"/>
    
      <category term="CQRS" scheme="https://blog.weechang.xyz/tags/CQRS/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework架构概述</title>
    <link href="https://blog.weechang.xyz/2018/08/17/AxonFramework%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
    <id>https://blog.weechang.xyz/2018/08/17/AxonFramework架构概述/</id>
    <published>2018-08-17T08:33:12.000Z</published>
    <updated>2018-08-17T08:36:04.821Z</updated>
    
    <content type="html"><![CDATA[<p>CQRS本身是一个非常简单的模式。它只规定了处理命令的应用程序的组件应该与处理查询 的组件分离。 虽然这种分离本身非常简单，但它与其他模式结合时提供了许多非常强大的功能。Axon 提供的构件更容易实现不同的模式与CQRS的结合。</p><a id="more"></a><p>下图显示了一个示例，一个基于CQRS的事件驱动的架构图示。 左侧显示的是UI组件, 通过 两种方式与应用程序的其余部分进行交互：它向应用程序发送命令 (显示在顶端的部分), 并从应用程序中查询信息 (显示在底端的部分)。</p><img src="/2018/08/17/AxonFramework架构概述/cqrs.jpg" title="CQRS架构图"><p>Command(命令)通常用简单的对象表示，这些对象包含命令处理器执行所需的所有数据。一个命令通过它的名字来表达它的意图。在Java术语中，这意味着使用类名来确定需要做什么，命令的字段提供了执行该操作所需的信息。</p><p>Command Bus接受命令并路由它们到命令处理器(Command handler) 。每个命令处理器响应特定类型的命令，并根据命令的内容执行逻辑。 然而，在某些情况下，你也希望不顾实际的命令类型去执行逻辑，如验证、日志或权限。</p><p>Command handler(命令处理器)从仓储中恢复领域对象(聚合)并执行方法来改变它们的状态。这些聚合通常包含真实的业务逻辑并负责维护自身的不变性。聚合的状态变化导致了领域事件的产生,领域事件和聚合都从领域模型中来。</p><p>repositories(仓储)负责提供访问聚合。通常情况下，这些仓储的优化设计是仅通过其唯一标识符来查找聚合。一些仓储将存储聚合自身的状态(例如，使用对象关系映射，ORM)， 而另一些则存储聚合的状态的更改到Event Store中，仓储还负责对其备份数据库中的聚合进行更改。</p><p>Axon提供了直接持久化聚合（使用对象关系映射，ORM）和事件溯源(event sourcing)两种方式.</p><p>Event bus(事件总线)分派事件到所有感兴趣的事件监听器(Event listener)中。可以同步或异 步完成。异步事件调度允许命令执行返回和移交控制给用户，这些事件在后台被分派和处理，不必等待事件处理完成，这样应用程序就会响应得更快。同步事件处理，另一方面，更简单，是 一个合适的默认选项。 默认情况下,同步处理将在同一事务中处理事件监听器和命令处理 器。</p><p>Event listener(事件监听器)接收并处理事件。一些处理器将更新用于查询的数据源，而其他处理器则将消息发送到外部系统。你可能会注意到了,命令处理器只对组件所做的更改感兴趣，却完全察觉不到它们的存在。这意味着它可以非侵入地扩展应用程序的新功能， 你需要做的就只是添加一个事件监听器。事件让应用程序中的所有组件松散耦合。</p><p>在某些情况下,事件处理需要把新的命令发送到应用程序。这方面例子，例如，当接收到一 个订单，这可能意味着客户的账户应当扣除购买商品所需的金额，并必须通知装运方准备打包这批商品。在许多应用中，逻辑将变得更加复杂:如果客户没有及时支付呢?你会马上发货还是等待付款？saga(长事务处理)是CQRS的概念，它负责管理这些复杂的商业事务。</p><p>在用户界面和数据源之间的瘦数据层，为实际的查询实现提供了一个明确定义的接口。这个数据层通常返回包含查询结果的只读DTO对象。这些DTO的内容通常是由用户界面的需求驱 动的。在大多数情况下,他们直接映射到用户界面的一个特定的视图(也称为table-per-view)。</p><p>Axon不提供任何应用程序这部分的构件。主要的原因是这非常简单，并且与分层架构并没有太大的区别。</p><h1 id="Axon模块结构"><a href="#Axon模块结构" class="headerlink" title="Axon模块结构"></a>Axon模块结构</h1><p>Axon Framework由多个针对CQRS特定问题域的模块组成。根据项目的具体需求，你需要包括一个或多个这些模块。<br>从Axon2.1起,所有模块兼容OSGi。这意味着它们在manifest文件包含所需的头文件,并声明它们导入和导出的包。目前,只有Slf4J bundle(1.7.0 &lt;= 版本&lt; 2.0.0)是必需的。所有其他导入的都被标记为可选,尽管你很可能需要这些。</p><h1 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h1><p>Axon的主要模块已经过完全的测试，强大到足以在苛刻的生产环境中使用。所有这些模 块的maven groupId都是org.axonframework。</p><p>核心模块顾名思义是Axon的核心组件。如果你使用single-node设置,这个模块可能会提供给你需要的所有组件。其他所有的Axon模块依赖这个模块，所以它必须在classpath中可用。</p><p>测试模块包含有你可以使用的测试固件来测试基于Axon的组件，比如你的命令处理器、聚 合和Sagas。你通常在运行时不需要这个模块，只需在测试过程中添加到classpath。</p><p>分布式CommandBus包含了可用于在多个节点发送命令的实现。它配备了JGroups和Spring Cloud连接器，来连接这些节点。</p><p>AMQP模块提供的组件，允许你打造一个基于AMQP的EventBus，并使用message broker作为分配机制。这允许保证事件送达，即使事件处理器节点暂时不可用。</p><p>Spring模块允许Axon组件在Spring程序上下文中配置。它还提供了一些针对Spring框架的构件的实现，例如用于在Spring消息信道上发布和检索Axon事件的适配器。</p><p>MongoDB是一个基于文档的NoSQL数据库，Mongo模块实现事件和saga的存储，并用MongoDB数据库存储事件流和saga。</p><p>几个AxonFramework组件提供监控信息。Metrics模块提供基于Codehale的基本实现来收集监控信息。</p><h1 id="与Axon-API一起工作"><a href="#与Axon-API一起工作" class="headerlink" title="与Axon API一起工作"></a>与Axon API一起工作</h1><p>QRS是一种架构模式，它不可能提供一个适合所有项目的单一解决方案。显然，Axon Framework并不试图提供这样的解决方案。相反，Axon提供了遵循最佳实践的实现和将每一个实现都调整到符合你的特定需求的手段。</p><p>几乎所有基础设施构件都提供检查点(如拦截器,解析器等)，允许你向这些构件添 加application-specific行为。大多数情况下，Axon将为那些适合大多数用例的检查点提供实现，如果需要，你可以简单地实现自己的。</p><p>非基础设施对象，如消息，通常是不可变的。这确保了这些对象在多线程环境中是安全的， 没有副作用的。</p><p>为了确保定制的最大化，所有Axon组件都使用接口定义。抽象类和具体的实现类提供了帮助你的方式，但框架对你没有任何要求，它总是允许使用该接口构建任何完全自定义实现的构件。</p><h1 id="Spring的支持"><a href="#Spring的支持" class="headerlink" title="Spring的支持"></a>Spring的支持</h1><p>Axon Framework对Spring提供了广泛的支持，但不强制你使用Spring来使用Axon。所有的组件都可以以编程方式配置，并且不需要把Spring放在classpath中。然而，如果你使用Spring、使 用Spring的annotation，很多的配置会变得更加容易。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/943f5b3ab139" target="_blank" rel="noopener">https://www.jianshu.com/p/943f5b3ab139</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CQRS本身是一个非常简单的模式。它只规定了处理命令的应用程序的组件应该与处理查询 的组件分离。 虽然这种分离本身非常简单，但它与其他模式结合时提供了许多非常强大的功能。Axon 提供的构件更容易实现不同的模式与CQRS的结合。&lt;/p&gt;
    
    </summary>
    
      <category term="DDD" scheme="https://blog.weechang.xyz/categories/DDD/"/>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/DDD/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
      <category term="DDD" scheme="https://blog.weechang.xyz/tags/DDD/"/>
    
      <category term="CQRS" scheme="https://blog.weechang.xyz/tags/CQRS/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework简介</title>
    <link href="https://blog.weechang.xyz/2018/08/17/AxonFramework%E7%AE%80%E4%BB%8B/"/>
    <id>https://blog.weechang.xyz/2018/08/17/AxonFramework简介/</id>
    <published>2018-08-17T08:19:19.000Z</published>
    <updated>2018-08-20T05:24:29.732Z</updated>
    
    <content type="html"><![CDATA[<p>Axon是一个轻量级框架，能够帮助开发者通过在架构层面构建可扩展和可伸缩的应用。(注：以DDD面向领域驱动设计为基础的CQRS框架)<br><a id="more"></a></p><h1 id="Axon-Framework背景、发展简史"><a href="#Axon-Framework背景、发展简史" class="headerlink" title="Axon Framework背景、发展简史"></a>Axon Framework背景、发展简史</h1><p>随着时间的发展，软件的需求也在不断增长。公司都希望自己的(web)应用程序和自身业务共同发展。这就意味着不仅仅是工程和代码变得更复杂，也意味着功能不断地新增、更改和移除。它令人沮丧的是,一个看似易于实现的功能，却要求开发团队改动整个应用程 序。此外，如今的web程序的目标是针对潜在的数十亿用户，这便使可伸缩性成了必要的条件。</p><p>虽然有很多的应用和框架围绕着可扩展性问题进行处理，例如GigaSpaces(类似Microsoft Azure) 和 Terracotta(分布式缓存线性扩展平台),它们都存在着一个根本的缺陷。他们通过要求开发人员在开发应用时，使用分层体系架构，来试图解决可扩展性问题。在某些情况下，他们甚至会阻止或严格限制使用一个真正的领域模型，强迫所有领域逻辑都放到服务中。虽然可以很快地构建一个应用程序，最终，这种做法将导致复杂性的增加和开发速度减慢。</p><p>命令查询职责分离(CQRS)模式解决了这些问题，大幅改变了应用程序的架构。CQRS不是将分离的逻辑分到不同的层 ,逻辑的分离是以改变应用程序的状态或查询为依据。这意味着，执行命令(行为有可能更改应用程序的状态)和查询应用程序数据是由不同的组件执行。这种分离事实上最重要的原因是，他们各自有不同的技术和非技术的要求。当命令执行后，查询组件利用事件同步或异步地进行更新。该更新机制通过事件来完成，正是这种架构如此的可扩展，可伸缩，最终会更易于维护。</p><blockquote><p><b>注意</b><br>一个完整的CQRS解释不在本文的范围之内。如果你想了解更多关于CQRS的信息, 请访问 Axon Framework的网站: <a href="http://www.axonframework.org。它包含了背景知识的链接。" target="_blank" rel="noopener">www.axonframework.org。它包含了背景知识的链接。</a></p></blockquote><p>由于CQRS与主导当今软件局面的分层架构有着根本上的不同，开发人员试图找到自己实现这个架构的方式，但往往会掉入各种陷阱。这就是了Axon Framework 产生的原因：帮助开发人员实现CQRS，并让他们只专注于业务逻辑。</p><h1 id="Axon是什么"><a href="#Axon是什么" class="headerlink" title="Axon是什么?"></a>Axon是什么?</h1><p>Axon Framework 通过支持开发者应用命令查询职责分离(CQRS)架构模式,来帮助构建可伸缩、可扩展和可维护的应用程序。它通过提供最重要的构建块的实现来实现，如：聚合、仓储以及事件总线(事件的调度机制)。此外，Axon提供了对注解(annotation)的支持,它允许你构建聚合和事件监听器而不用将你的代码捆绑到Axon特有的逻辑。这使你能够专注于业务逻辑, 而不是数据传输(the plumbing)，并帮助你使代码更容易隔离测试。</p><p>Axon不会试图以任何方式隐藏CQRS架构或任何组件。因此，根据团队规模，明智的选择是，每 个团队中有一个或多个对CQRS有着透彻了解的开发人员。不管怎么样,Axon帮助保证把事件交付给正确的事件监听器，并按正确的顺序并发处理它们。这些多线程问题通常很难处理,导致难以跟踪Bug、应用程序完全失去响应。当你的时间紧迫,你可能甚至不想去关心这些问 题。Axon的代码是经过完全测试的,以防止这些类型错误的出现。</p><p>Axon Framework由多个模块(jar)组成，这些模块提供工具和组件来构建可伸缩的基础设施。Axon核心模块为不同的组件提供了基本的API，并为单JVM的应用程序解决方案提供了简单实现。其他模块提供专业的组件，来解决可伸缩性和高性能的问题。</p><h1 id="何时使用Axon"><a href="#何时使用Axon" class="headerlink" title="何时使用Axon?"></a>何时使用Axon?</h1><p>并不是每一个应用程序都会从Axon中获益。简单的CRUD (Create, Read, Update, Delete) 应用程序、没有横向扩展预期的应用程序，可能无法从CQRS或Axon中受益。</p><p>具有以下一个或多个特点的应用程序可能会从CQRS和Axon中受益:</p><ul><li><p>在相当长的一段时间内可能会扩展新的功能。例如，一个网上商店可能初期仅仅是一 个订单进度跟踪系统。后期，可能会扩展到对库存信息的管理，确保物品售出后及时的更新 库存。随后，财务人员可能需要销售的财务统计数据等等。虽然很难预测软件项目未来会如何发展，但是大多数类型的应用程序都清楚地呈现为这样。</p></li><li><p>应用程序有一个比较高的读写比，这意味着数据只写几次，但却要读很多次。由于查 询的数据源与用于命令验证的数据源不同，因此才有可能对数据源的快速查询提供优 化。重复数据不再是一个问题，因为当数据改变时，事件也会被发布。</p></li><li><p>应用程序需要不同格式的展示数据，许多应用程序目前不仅仅只停留在显示数据到网 页上。 某些应用程序,例如,每月邮件通知所发生的与用户有关的变化，搜索引擎也是一个例子。他们使用相同的应用程序数据,但在某种意义上这是优化的快速搜索。 报表工具随着时间的变化汇总信息，这同样是同一数据的不同格式。使用Axon，每个数据源都可以彼此独立地实时或定时更新。</p></li><li><p>当应用程序面对不同的受众，清晰地隔离组件时，它也能从Axon中获益。例如网上商 店。员工会在网站上更新产品信息和可用性，同时客户可以下单和查询他们的订单状 态。通过Axon，这些组件可以部署在不同的服务器上，并使用不同的策略进行扩展。 通过事件机制，Axon将分发事件到部署在不同服务器上的订阅组件，使其保持最新的 数据状态。</p></li><li><p>与其他应用程序集成可能是繁琐的工作。严格使用命令和事件定义应用程序的API， 会使它更容易与外部应用程序集成。任何应用程序都可以发送命令或监听应用程序生 成的事件。</p></li></ul><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/15484ed1fbde" target="_blank" rel="noopener">https://www.jianshu.com/p/15484ed1fbde</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Axon是一个轻量级框架，能够帮助开发者通过在架构层面构建可扩展和可伸缩的应用。(注：以DDD面向领域驱动设计为基础的CQRS框架)&lt;br&gt;
    
    </summary>
    
      <category term="DDD" scheme="https://blog.weechang.xyz/categories/DDD/"/>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/DDD/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
      <category term="DDD" scheme="https://blog.weechang.xyz/tags/DDD/"/>
    
      <category term="CQRS" scheme="https://blog.weechang.xyz/tags/CQRS/"/>
    
  </entry>
  
  <entry>
    <title>六元一个的私有博客系统，了解一下？</title>
    <link href="https://blog.weechang.xyz/2018/08/02/%E5%85%AD%E5%85%83%E4%B8%80%E4%B8%AA%E7%9A%84%E7%A7%81%E6%9C%89%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F/"/>
    <id>https://blog.weechang.xyz/2018/08/02/六元一个的私有博客系统，了解一下？/</id>
    <published>2018-08-02T06:33:09.000Z</published>
    <updated>2018-08-02T07:16:52.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神说要有光，于是便有了光"><a href="#神说要有光，于是便有了光" class="headerlink" title="神说要有光，于是便有了光"></a>神说要有光，于是便有了光</h1><p>写代码的，偶尔都想装点逼，想要自己写点博客。刚开始还能在各大社区写，比如说CSDN，开源中国，博客园什么的。但是越写就会越觉得，那些博客平台都不是自己想要的，虽然大平台，能够提高在搜索引擎的收录，但是我看着别人的博客，我也想要有一个自建的博客系统。于是开始了自建博客的入坑之旅，在这儿给大伙分享一下我的自建博客历程。</p><a id="more"></a><h1 id="本文包括一下步骤"><a href="#本文包括一下步骤" class="headerlink" title="本文包括一下步骤"></a>本文包括一下步骤</h1><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>因为自己不是很懂，网上找的资料也很分散。所以整个历程大概经历了四天左右才把自己的博客系统搞好。首先需要准备以下资源</p><ol><li>github账号（应该都有吧，没有的自己去注册一个）<a href="https://www.github.com" target="_blank">传送门</a></li><li>选择一个你喜欢的hexo主题，这个网上太多了。可以去<a href="http://hexo.io/themes/" target="_blank">hexo官网</a>，或者<a href="https://github.com/search?q=hexo" target="_blank">github</a>上看看</li><li>准备一个nodeJS环境，具体怎么搞，可以度娘一下 <a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank">windows传送门</a>，<a herf="https://www.cnblogs.com/BinXu/p/6050850.html" target="_blank">Mac 传送门</a></li><li>一个阿里云账号（如果使用github提供的域名的话，这个可以省了）</li></ol><p># </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;神说要有光，于是便有了光&quot;&gt;&lt;a href=&quot;#神说要有光，于是便有了光&quot; class=&quot;headerlink&quot; title=&quot;神说要有光，于是便有了光&quot;&gt;&lt;/a&gt;神说要有光，于是便有了光&lt;/h1&gt;&lt;p&gt;写代码的，偶尔都想装点逼，想要自己写点博客。刚开始还能在各大社区写，比如说CSDN，开源中国，博客园什么的。但是越写就会越觉得，那些博客平台都不是自己想要的，虽然大平台，能够提高在搜索引擎的收录，但是我看着别人的博客，我也想要有一个自建的博客系统。于是开始了自建博客的入坑之旅，在这儿给大伙分享一下我的自建博客历程。&lt;/p&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="手把手教学" scheme="https://blog.weechang.xyz/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6/"/>
    
      <category term="GitHub Pages" scheme="https://blog.weechang.xyz/tags/GitHub-Pages/"/>
    
  </entry>
  
  <entry>
    <title>【Java学习之从头开始】Java基础-3——HashTable类</title>
    <link href="https://blog.weechang.xyz/2018/07/31/java%E5%9F%BA%E7%A1%80-3%E2%80%94%E2%80%94HashTable%E7%B1%BB/"/>
    <id>https://blog.weechang.xyz/2018/07/31/java基础-3——HashTable类/</id>
    <published>2018-07-31T06:00:29.000Z</published>
    <updated>2018-07-31T09:30:46.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>和HashMap一样，HashTable 也是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashTable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。<br>HashTable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，HashTable中的映射不是有序的。<br><a id="more"></a></p><h2 id="1-1-成员变量"><a href="#1-1-成员变量" class="headerlink" title="1.1 成员变量"></a>1.1 成员变量</h2><pre>    // 是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的"key-value键值对"都是存储在Entry数组中的。     private transient Entry<?,?>[] table;    // 是Hashtable的大小，它是Hashtable保存的键值对的数量。     private transient int count;    // 是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值="容量*加载因子"。    private int threshold;    // 就是加载因子。     private float loadFactor;    // 是用来实现fail-fast机制的    private transient int modCount = 0;</pre><h2 id="1-2-构造函数"><a href="#1-2-构造函数" class="headerlink" title="1.2 构造函数"></a>1.2 构造函数</h2><pre>    // 默认构造函数。    public Hashtable()     // 指定“容量大小”的构造函数    public Hashtable(int initialCapacity)     // 指定“容量大小”和“加载因子”的构造函数    public Hashtable(int initialCapacity, float loadFactor)     // 包含“子Map”的构造函数    public Hashtable(Map<? extends K, ? extends V> t)</pre><h2 id="1-3-常用API"><a href="#1-3-常用API" class="headerlink" title="1.3 常用API"></a>1.3 常用API</h2><pre>    // 将此哈希表清空，使其不包含任何键。     synchronized void                clear()    synchronized Object              clone()    // 测试此映射表中是否存在与指定值关联的键。                  boolean             contains(Object value)    // 测试指定对象是否为此哈希表中的键。     synchronized boolean             containsKey(Object key)    // 如果此 Hashtable 将一个或多个键映射到此值，则返回 true。     synchronized boolean             containsValue(Object value)    synchronized Enumeration<v>      elements()    synchronized Set<entry<k, v="">>    entrySet()    synchronized boolean             equals(Object object)    synchronized V                   get(Object key)    synchronized int                 hashCode()    synchronized boolean             isEmpty()    synchronized Set<k>              keySet()    synchronized Enumeration<k>      keys()    synchronized V                   put(K key, V value)    synchronized void                putAll(Map<? extends K, ? extends V> map)    synchronized V                   remove(Object key)    synchronized int                 size()    synchronized String              toString()    synchronized Collection<v>       values()    // 增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素。     protected  void rehash() </v></k></k></entry<k,></v></pre><h1 id="二、HashTable遍历方式"><a href="#二、HashTable遍历方式" class="headerlink" title="二、HashTable遍历方式"></a>二、HashTable遍历方式</h1><h2 id="2-1-遍历HashTable的键值对"><a href="#2-1-遍历HashTable的键值对" class="headerlink" title="2.1 遍历HashTable的键值对"></a>2.1 遍历HashTable的键值对</h2><p><b>第一步：根据entrySet()获取HashTable的“键值对”的Set集合。</b><br><b>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</b></p><pre>    // 假设table是Hashtable对象    // table中的key是String类型，value是Integer类型    Integer integ = null;    Iterator iter = table.entrySet().iterator();    while(iter.hasNext()) {        Map.Entry entry = (Map.Entry)iter.next();        // 获取key        key = (String)entry.getKey();        // 获取value        integ = (Integer)entry.getValue();    }</pre><h2 id="2-2-通过Iterator遍历HashTable的键"><a href="#2-2-通过Iterator遍历HashTable的键" class="headerlink" title="2.2 通过Iterator遍历HashTable的键"></a>2.2 通过Iterator遍历HashTable的键</h2><p><b>第一步：根据keySet()获取HashTable的“键”的Set集合。</b><br><b>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</b></p><pre>    // 假设table是Hashtable对象    // table中的key是String类型，value是Integer类型    String key = null;    Integer integ = null;    Iterator iter = table.keySet().iterator();    while (iter.hasNext()) {            // 获取key        key = (String)iter.next();            // 根据key，获取value        integ = (Integer)table.get(key);    }</pre><h2 id="2-3-通过Iterator遍历HashTable的值"><a href="#2-3-通过Iterator遍历HashTable的值" class="headerlink" title="2.3 通过Iterator遍历HashTable的值"></a>2.3 通过Iterator遍历HashTable的值</h2><p><b>第一步：根据value()获取HashTable的“值”的集合。</b><br><b>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</b></p><pre>    // 假设table是HashTable对象    // table中的key是String类型，value是Integer类型    Integer value = null;    Collection c = table.values();    Iterator iter= c.iterator();    while (iter.hasNext()) {        value = (Integer)iter.next();    }</pre><h2 id="2-4-通过Enumeration遍历HashTable的键"><a href="#2-4-通过Enumeration遍历HashTable的键" class="headerlink" title="2.4 通过Enumeration遍历HashTable的键"></a>2.4 通过Enumeration遍历HashTable的键</h2><p><b>第一步：根据keys()获取HashTable的集合。</b><br><b>第二步：通过Enumeration遍历“第一步”得到的集合。</b></p><pre>    Enumeration enu = table.keys();    while(enu.hasMoreElements()) {        System.out.println(enu.nextElement());    } </pre>  <h2 id="2-5-通过Enumeration遍历HashTable的值"><a href="#2-5-通过Enumeration遍历HashTable的值" class="headerlink" title="2.5 通过Enumeration遍历HashTable的值"></a>2.5 通过Enumeration遍历HashTable的值</h2><p><b>第一步：根据elements()获取HashTable的集合。</b><br><b>第二步：通过Enumeration遍历“第一步”得到的集合。</b></p><pre>    Enumeration enu = table.elements();    while(enu.hasMoreElements()) {        System.out.println(enu.nextElement());    }</pre><p><b>PS:本文章相关代码均已上传至 GitHub <a href="https://github.com/weechang/java-zero" target="_blank">查看详情</a></b></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;和HashMap一样，HashTable 也是一个散列表，它存储的内容是键值对(key-value)映射。&lt;br&gt;HashTable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。&lt;br&gt;HashTable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，HashTable中的映射不是有序的。&lt;br&gt;
    
    </summary>
    
      <category term="Java学习之从头开始" scheme="https://blog.weechang.xyz/categories/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
    
      <category term="Java基础" scheme="https://blog.weechang.xyz/categories/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java学习之从头开始" scheme="https://blog.weechang.xyz/tags/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
    
      <category term="Java基础" scheme="https://blog.weechang.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="HashTable" scheme="https://blog.weechang.xyz/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>【Java学习之从头开始】Java基础-2——HashMap类</title>
    <link href="https://blog.weechang.xyz/2018/07/30/java%E5%9F%BA%E7%A1%80-2%E2%80%94%E2%80%94HashMap%E7%B1%BB/"/>
    <id>https://blog.weechang.xyz/2018/07/30/java基础-2——HashMap类/</id>
    <published>2018-07-30T09:05:03.000Z</published>
    <updated>2018-07-31T09:31:42.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、原理实现"><a href="#一、原理实现" class="headerlink" title="一、原理实现"></a>一、原理实现</h1><p>hashMap的本质是一个数组，数组中每一个元素称为一个Node，Node中存放的是hash值与链表（或红黑树）的键值对。<br>hashMap的存储过程如下:<br>根据 key 计算出它的哈希值 h。<br>假设Node的个数为 n，那么这个键值对应该放在第 (h % n) 个Node中。<br><a id="more"></a><br>如果该Node中已经有了键值对，就使用<a href="http://www.cnblogs.com/lizhanwu/p/4303410.html" target="_blank">拉链法</a>解决冲突。<br>hashMap还有一个重要的属性: 负载因子(load factor)，它用来衡量hashMap的 空/满 程度，一定程度上也可以体现查询的效率，计算公式为:</p><p>负载因子 = 总键值对数 / Node个数</p><p>负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，hashMap将自动扩容。<br>hashMap在自动扩容时，一般会创建两倍于原来个数的Node，因此即使 key 的hashMap不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。<br>hashMap的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个Node中的链表长度并不发生改变，因此也就不能提高hashMap的查询性能。</p><p>基于以上总结，细心的读者可能会发现hashMap的两个问题:</p><p>如果hashMap中本来Node就比较多，扩容时需要重新哈希并移动数据，性能影响较大。<br>如果哈希函数设计不合理，hashMap在极端情况下会变成线性表，性能极低。<br>于是针对这种问题，java8中采用了红黑树与链表相互转换的方式来解决。当Node中的键值对大于8的时候，链表结构将变为树形结构。该方式能够在一定程度上解决链表的查询效率问题，但是最好的解决方案还是在hash函数的设计上，尽量减少hash冲突。</p><p>根据概率论分析，理想状态下，hashMap中的Node满足泊松分布<br>当负载因子为 0.75 时，上述公式中 λ 约等于 0.5，因此箱子中元素个数和概率的关系如下:</p><table><thead><tr><th>数量</th><th>概率</th></tr></thead><tbody><tr><td>0</td><td>0.60653066</td></tr><tr><td>1</td><td>0.30326533</td></tr><tr><td>2</td><td>0.07581633</td></tr><tr><td>3</td><td>0.01263606</td></tr><tr><td>4</td><td>0.00157952</td></tr><tr><td>5</td><td>0.00015795</td></tr><tr><td>6</td><td>0.00001316</td></tr><tr><td>7</td><td>0.00000094</td></tr><tr><td>8</td><td>0.00000006</td></tr></tbody></table><h1 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h1><h2 id="2-1-成员变量"><a href="#2-1-成员变量" class="headerlink" title="2.1 成员变量"></a>2.1 成员变量</h2><pre>    /**     * 默认初始容量 - 必须是2的幂。     * 个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。     */    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16    /**     *     * 最大容量。     */    static final int MAXIMUM_CAPACITY = 1 << 30;    /**     * 默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。     */    static final float DEFAULT_LOAD_FACTOR = 0.75f;    /**     * 使用树而不是链表的计数阈值。     *如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。     * 这个值表示当某个链表长度大于 8 时，有可能会转化成树。     * 备注：从JDK1.8开始，HashMap容量在大于一定值后，底层将会由链表结构转为树形结构     */    static final int TREEIFY_THRESHOLD = 8;    /**     * 当容量小于该值时，将由树状结构转为链表结构     */    static final int UNTREEIFY_THRESHOLD = 6;    /**     * 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。     * 这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。     */    static final int MIN_TREEIFY_CAPACITY = 64;    // 数组，该数组用于存储不同的hash值与链表的对应关系    transient Node<k,v>[] table;    // 单向链表，该链表用于处理哈希冲突    Set<map.entry<k,v>> entrySet;    // hashMap长度    int size;    // 用来实现fail-fast机制的。     int modCount;     // HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值="容量*加载因子"，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。     int threshold;     // 加载因子     final float loadFactor;</map.entry<k,v></k,v></pre><h1 id="三、常用方法"><a href="#三、常用方法" class="headerlink" title="三、常用方法"></a>三、常用方法</h1><h2 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h2><pre>    /**    * @param initialCapacity 初始大小    * @param loadFactor 扩容因子    */    public HashMap(int initialCapacity, float loadFactor)    /**    *@param initialCapacity 初始大小    */    public HashMap(int initialCapacity)    public HashMap()    /**    *@param m Map子类    */    public HashMap(Map<? extends K, ? extends V> m)</pre><h2 id="3-2-对外方法"><a href="#3-2-对外方法" class="headerlink" title="3.2 对外方法"></a>3.2 对外方法</h2><pre>    /**    * 清空hashMap    * 通过将所有Node置空实现    */    public void clear()    /**    * 是否存在键为key的键值对    */    public boolean containsKey(Object key)    /**    * 是否存在值为value的键值对    */    public boolean containsValue(Object value)    /**    * 获取所有的键值对    */    public Set<map.entry<k,v>> entrySet()    /**    * 获取所有键值对 值的集合    */    public Collection<v> values()    /**    * 获取所有键值对 键的集合    */    public Set<k> keySet()    /**    * 根据键值对的键获取值    */    public V get(Object key)    /**    * put 一个键值对    */    public V put(K key, V value)    /**    *将"m"的全部元素都添加到HashMap中    */    public void putAll(Map<? extends K, ? extends V> m)    /**    *移除键为key的元素    */    public V remove(Object key)</k></v></map.entry<k,v></pre><h1 id="四、HashMap的遍历"><a href="#四、HashMap的遍历" class="headerlink" title="四、HashMap的遍历"></a>四、HashMap的遍历</h1><h2 id="4-1-遍历HashMap的键值对"><a href="#4-1-遍历HashMap的键值对" class="headerlink" title="4.1 遍历HashMap的键值对"></a>4.1 遍历HashMap的键值对</h2><p>第一步：根据entrySet()获取HashMap的“键值对”的Set集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p><pre>    // 假设map是HashMap对象    // map中的key是String类型，value是Integer类型    Integer integ = null;    Iterator iter = map.entrySet().iterator();    while(iter.hasNext()) {        Map.Entry entry = (Map.Entry)iter.next();        // 获取key        key = (String)entry.getKey();        // 获取value        integ = (Integer)entry.getValue();    }</pre><h2 id="4-2-遍历HashMap的键"><a href="#4-2-遍历HashMap的键" class="headerlink" title="4.2 遍历HashMap的键"></a>4.2 遍历HashMap的键</h2><p>第一步：根据keySet()获取HashMap的“键”的Set集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p><pre>    // 假设map是HashMap对象    // map中的key是String类型，value是Integer类型    String key = null;    Integer integ = null;    Iterator iter = map.keySet().iterator();    while (iter.hasNext()) {            // 获取key        key = (String)iter.next();            // 根据key，获取value        integ = (Integer)map.get(key);    }</pre><h2 id="4-3-遍历HashMap的值"><a href="#4-3-遍历HashMap的值" class="headerlink" title="4.3 遍历HashMap的值"></a>4.3 遍历HashMap的值</h2><p>第一步：根据value()获取HashMap的“值”的集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p><pre>    // 假设map是HashMap对象    // map中的key是String类型，value是Integer类型    Integer value = null;    Collection c = map.values();    Iterator iter= c.iterator();    while (iter.hasNext()) {        value = (Integer)iter.next();    }</pre><p><b>PS:本文章相关代码均已上传至 GitHub <a href="https://github.com/weechang/java-zero" target="_blank">查看详情</a></b></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、原理实现&quot;&gt;&lt;a href=&quot;#一、原理实现&quot; class=&quot;headerlink&quot; title=&quot;一、原理实现&quot;&gt;&lt;/a&gt;一、原理实现&lt;/h1&gt;&lt;p&gt;hashMap的本质是一个数组，数组中每一个元素称为一个Node，Node中存放的是hash值与链表（或红黑树）的键值对。&lt;br&gt;hashMap的存储过程如下:&lt;br&gt;根据 key 计算出它的哈希值 h。&lt;br&gt;假设Node的个数为 n，那么这个键值对应该放在第 (h % n) 个Node中。&lt;br&gt;
    
    </summary>
    
      <category term="Java学习之从头开始" scheme="https://blog.weechang.xyz/categories/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
    
      <category term="Java基础" scheme="https://blog.weechang.xyz/categories/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java学习之从头开始" scheme="https://blog.weechang.xyz/tags/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
    
      <category term="Java基础" scheme="https://blog.weechang.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="HashMap" scheme="https://blog.weechang.xyz/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>手把手教学，教你把你的个人项目推送到maven中央仓库</title>
    <link href="https://blog.weechang.xyz/2018/07/20/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6%EF%BC%8C%E6%95%99%E4%BD%A0%E6%8A%8A%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/"/>
    <id>https://blog.weechang.xyz/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/</id>
    <published>2018-07-20T08:43:08.000Z</published>
    <updated>2018-07-31T06:05:56.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近闲下来了，想要自己造点小轮子用，方便自己在不同项目使用，同时想偷懒，不想每次都在项目里面copy代码。于是想到了重要仓库这个东西，把自己的代码托管到github（虽然现在的github已经不再单纯），然后发布jar包到maven中央仓库，以后每个项目都只用引入maven依赖就可以了。同时还能方便好基友们使用，万一哪一天好基友高兴就献身了呢，想想就有点小激动呢。好了废话不多说，下面正式开始手把手教学活动。<br><a id="more"></a><br><b><a href="https://github.com/weechang/JUtil" target="_blank" rel="noopener">附上小轮子传送门</a>给感兴趣的小伙伴</b><br>将项目发布到maven仓库需要以下几步:<br>1.在sonatype中创建issue<br>2.使用gpg生成秘钥<br>3.配置Maven进行deploy和release</p><h1 id="1-在sonatype中创建issue"><a href="#1-在sonatype中创建issue" class="headerlink" title="1 在sonatype中创建issue"></a>1 在sonatype中创建issue</h1><p>首先我们需要在<a href="https://issues.sonatype.org/secure/Dashboard.jspa" targe="_blank" target="_blank" rel="noopener">https://issues.sonatype.org/secure/Dashboard.jspa</a>中新建一个issues。如果没有sonatype账号的话，分分钟注册一个<br><img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/创建项目.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"><br>创建完成后就是如下图示<br><img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/创建完成.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"><br>这个时候只需要耐心等待工作人员审核就行了，因为我的domain问题，经历了二次审核，但是都很快，一般提交后两个小时内就会有结果。当issues状态变为Resolved就可以继续下一步操作了。</p><h1 id="2-使用gpg生成秘钥"><a href="#2-使用gpg生成秘钥" class="headerlink" title="2 使用gpg生成秘钥"></a>2 使用gpg生成秘钥</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>选择对应的OS版本进行下载安装即可，下载地址传送门：<a href="https://www.gnupg.org/download/index.html" targe="_blank" target="_blank" rel="noopener">https://www.gnupg.org/download/index.html</a></p><h2 id="2-2-生成key"><a href="#2-2-生成key" class="headerlink" title="2.2 生成key"></a>2.2 生成key</h2><p>首先查看安装成功没有 <pre>gpg –version</pre> （MAC 和 Linux系统需要 gpg2 –version）<br>通过 <pre>gpg –gen-key</pre> 生成key，也可以通过UI界面生成和管理key<br><img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/生成key.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"><br>运行后gpg要求你选择加密算法，过期时间等等，这些直接选择默认值即可。通过对比发现，gpg 2.0以上的版本运行gpg –gen-key命令 会跳过这些步骤。<br>之后gpg要求你输入姓名，邮箱以及关键的Passphrase，依次输入即可。然后gpg为你生成了一对秘钥。<br>通过<pre>gpg –list-keys</pre>查看生成的key列表<br><img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/秘钥列表.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"><br>这里可以看到我的公钥是：34754DFE562C10E1A09907B7F4797C9A95E36DB6，记住这个key，下面我们需要用到。</p><h2 id="2-3-上传公钥"><a href="#2-3-上传公钥" class="headerlink" title="2.3 上传公钥"></a>2.3 上传公钥</h2><p>生成秘钥后，我们需要把公钥上传到服务器上。运行以下命令：<pre>gpg2 –keyserver hkp://pool.sks-keyservers.net –send-keys 34754DFE562C10E1A09907B7F4797C9A95E36DB6（刚才生成的公钥）</pre></p><h1 id="3-配置Maven"><a href="#3-配置Maven" class="headerlink" title="3 配置Maven"></a>3 配置Maven</h1><h2 id="3-1-配置maven-setting-xml"><a href="#3-1-配置maven-setting-xml" class="headerlink" title="3.1 配置maven setting.xml"></a>3.1 配置maven setting.xml</h2><p>需要在本地的maven配置server 和 profile 两个地方，啰嗦的话就不多少了，直接上配置：</p><pre>    &lt;server>        &lt;id>ossrh&lt;/id>        &lt;username>第一步注册的用户名&lt;/username>        &lt;password>第一步注册的密码&lt;/password>    &lt;/server></pre><pre>     &lt;profile>         &lt;id>ossrh&lt;/id>         &lt;activation>             &lt;activeByDefault>true&lt;/activeByDefault>         &lt;/activation>         &lt;properties>             &lt;gpg.executable>gpg(MAC 和 Linux用户使用gpg2)&lt;/gpg.executable>             &lt;gpg.passphrash>生成密钥时输入的密码&lt;/gpg.passphrash>         &lt;/properties>    </pre><h2 id="3-2-配置项目的pom-xml"><a href="#3-2-配置项目的pom-xml" class="headerlink" title="3.2 配置项目的pom.xml"></a>3.2 配置项目的pom.xml</h2><p>具体的配置可以查看小轮子里面的pom设置 <a href="https://github.com/weechang/JUtil/blob/master/pom.xml" target="_blank">https://github.com/weechang/JUtil/blob/master/pom.xml</a><br>首先需要添加指向sonatype仓库的&lt;distributionManagement&gt;</p><p><pre><br>    &lt;distributionManagement&gt;<br>        &lt;snapshotRepository&gt;<br>            &lt;id&gt;ossrh&lt;/id&gt;<br>            &lt;url&gt;<a href="https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;" target="_blank" rel="noopener">https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;</a><br>        &lt;/snapshotRepository&gt;<br>        &lt;repository&gt;<br>            &lt;id&gt;ossrh&lt;/id&gt;<br>            &lt;name&gt;Maven Central Staging Repository&lt;/name&gt;<br>            &lt;url&gt;<a href="https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;" target="_blank" rel="noopener">https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;</a><br>        &lt;/repository&gt;<br>    &lt;/distributionManagement&gt;<br></pre><br>继续配置pfofiles,添加各种推送、DOC、加密的插件</p><p><pre><br>    &lt;profiles&gt;<br>        &lt;profile&gt;<br>            &lt;id&gt;release<br>            &lt;build&gt;<br>                &lt;plugins&gt;<br>                    &lt;plugin&gt;<br>                        &lt;groupId&gt;org.sonatype.plugins&lt;/groupId&gt;<br>                        &lt;artifactId&gt;nexus-staging-maven-plugin&lt;/artifactId&gt;<br>                        &lt;version&gt;1.6.8&lt;/version&gt;<br>                        &lt;extensions&gt;true&lt;/extensions&gt;<br>                        &lt;configuration&gt;<br>                            &lt;serverId&gt;ossrh&lt;/serverId&gt;<br>                            &lt;nexusUrl&gt;<a href="https://oss.sonatype.org/&lt;/nexusUrl&gt;" target="_blank" rel="noopener">https://oss.sonatype.org/&lt;/nexusUrl&gt;</a><br>                            &lt;autoReleaseAfterClose&gt;true&lt;/autoReleaseAfterClose&gt;<br>                        &lt;/configuration&gt;<br>                    &lt;/plugin&gt;<br>                    &lt;plugin&gt;<br>                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                        &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;<br>                        &lt;version&gt;3.0.1&lt;/version&gt;<br>                        &lt;executions&gt;<br>                            &lt;execution&gt;<br>                                &lt;id&gt;attach-javadocs&lt;/id&gt;<br>                                &lt;goals&gt;<br>                                    &lt;goal&gt;jar&lt;/goal&gt;<br>                                &lt;/goals&gt;<br>                            &lt;/execution&gt;<br>                        &lt;/executions&gt;<br>                    &lt;/plugin&gt;<br>                    &lt;plugin&gt;<br>                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                        &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;<br>                        &lt;executions&gt;<br>                            &lt;execution&gt;<br>                                &lt;id&gt;attach-sources&lt;/id&gt;<br>                                &lt;goals&gt;<br>                                    &lt;goal&gt;jar-no-fork<br>                                &lt;/goals&gt;<br>                            &lt;/execution&gt;<br>                        &lt;/executions&gt;<br>                    &lt;/plugin&gt;<br>                    &lt;plugin&gt;<br>                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                        &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;<br>                        &lt;version&gt;1.6&lt;/version&gt;<br>                        &lt;executions&gt;<br>                            &lt;execution&gt;<br>                                &lt;id&gt;sign-artifacts&lt;/id&gt;<br>                                &lt;phase&gt;verify&lt;/phase&gt;<br>                                &lt;goals&gt;<br>                                    &lt;goal&gt;sign&lt;/goal&gt;<br>                                &lt;/goals&gt;<br>                            &lt;/execution&gt;<br>                        &lt;/executions&gt;<br>                    &lt;/plugin&gt;<br>                &lt;/plugins&gt;<br>            &lt;/build&gt;<br>        &lt;/profile&gt;<br>    &lt;/profiles&gt;<br></pre><br>然后还可以添加一些开发者信息和license信息，具体的就不多说了。具体可以参考小轮子的配置</p><h2 id="3-3-部署到中央仓库"><a href="#3-3-部署到中央仓库" class="headerlink" title="3.3 部署到中央仓库"></a>3.3 部署到中央仓库</h2><p>运行以下代码进行deploy</p><p><pre>mvn clean deploy -P release</pre><br>如下图表示成功部署到中央仓库<br><img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/部署成功.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"><br>因为我们在pom中添加了自动发布插件，所以可以不用管理，直接到中央仓库去查看就能看到你发布的项目了<br><b>PS:在部署过成功可能会遇到401的问题，具体请参考传送门 <a href="https://stackoverflow.com/questions/24830610/why-am-i-getting-a-401-unauthorized-error-in-maven" target="_blank">https://stackoverflow.com/questions/24830610/why-am-i-getting-a-401-unauthorized-error-in-maven</a></b></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近闲下来了，想要自己造点小轮子用，方便自己在不同项目使用，同时想偷懒，不想每次都在项目里面copy代码。于是想到了重要仓库这个东西，把自己的代码托管到github（虽然现在的github已经不再单纯），然后发布jar包到maven中央仓库，以后每个项目都只用引入maven依赖就可以了。同时还能方便好基友们使用，万一哪一天好基友高兴就献身了呢，想想就有点小激动呢。好了废话不多说，下面正式开始手把手教学活动。&lt;br&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="手把手教学" scheme="https://blog.weechang.xyz/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6/"/>
    
      <category term="maven中央仓库" scheme="https://blog.weechang.xyz/tags/maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【Java学习之从头开始】Java基础-1——String类</title>
    <link href="https://blog.weechang.xyz/2018/06/08/java%E5%9F%BA%E7%A1%80-1%E2%80%94%E2%80%94String%E7%B1%BB/"/>
    <id>https://blog.weechang.xyz/2018/06/08/java基础-1——String类/</id>
    <published>2018-06-08T05:59:02.000Z</published>
    <updated>2018-07-31T09:31:42.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-1-成员变量"><a href="#1-1-成员变量" class="headerlink" title="1.1 成员变量"></a>1.1 成员变量</h2><pre>    public final class String implements java.io.Serializable, Comparable<string>, CharSequence {        private final char value[];        private int hash; // Default to 0        private static final long serialVersionUID = -6849794470754667710L;        private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];    }</string></pre><p>从源码可以看出，<b>String底层是通过一个不可变的字符串常量来进行维护的。所以只要一个字符改变就会生成一个新的String类型对象。</b><br><a id="more"></a></p><h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><pre>    String()    String(String original)    String(char value[])    String(char value[], int offset, int count)    String(int[] codePoints, int offset, int count)    String(byte bytes[], int offset, int length, String charsetName)    String(byte bytes[], int offset, int length, Charset charset)    String(byte bytes[], String charsetName)    String(byte bytes[], Charset charset)    String(byte bytes[], int offset, int length)    String(byte bytes[])    String(StringBuffer buffer)    String(StringBuilder builder)    String(char[] value, boolean share)</pre><h1 id="二、创建方式的区别"><a href="#二、创建方式的区别" class="headerlink" title="二、创建方式的区别"></a>二、创建方式的区别</h1><h2 id="2-1-直接赋值方式"><a href="#2-1-直接赋值方式" class="headerlink" title="2.1 直接赋值方式"></a>2.1 直接赋值方式</h2><p>String str = “str”; //<b>直接赋值方式创建对象是在方法区的常量池</b></p><h2 id="2-2-构造方法创建"><a href="#2-2-构造方法创建" class="headerlink" title="2.2 构造方法创建"></a>2.2 构造方法创建</h2><p>String str = “str”;//<b>通过构造方法创建字符串对象是在堆内存</b></p><pre>    public class JavaString {        /**         * 创建方式的比较         */        public void createMethod() {            String str1 = "str";            String str2 = new String("str");            String str3 = str1;            String str4 = str2;            System.out.println(str1 == str2); // false            System.out.println(str1 == str3); // true            System.out.println(str2 == str4); // true            System.out.println(str1 == str4); // false        }        public static void main(String[] args) {            JavaString javaString = new JavaString();            javaString.createMethod();        }    }</pre><h2 id="2-3-内存分析"><a href="#2-3-内存分析" class="headerlink" title="2.3 内存分析"></a>2.3 内存分析</h2><img src="/2018/06/08/java基础-1——String类/memory.png" title="内存示意"><p><b>在字符串中，如果采用直接赋值的方式（String str=”str”）进行对象的实例化，则会将匿名对象“str”放入字符串常量池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象。</b><br>这样，所有直接赋值的String对象，如果利用相同的“str”，则String对象==返回true；<br>PS：字符串还可以采用手工入池的方式</p><pre>    /**     * 字符串手工入池     */    public void intern(){        String str1 = new String("str").intern();        String str2 = "str";        System.out.println(str1 == str2); // true    }</pre><h2 id="2-4-区别"><a href="#2-4-区别" class="headerlink" title="2.4 区别"></a>2.4 区别</h2><p>1）直接赋值（String str = “str”）：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。<br>2）构造方法（String str=  new String(“str”);）:会开辟两块堆内存空间（具体原因阐述见此处），其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public  String intern();方法进行手工入池。<br><b>PS:String类对象一旦声明则不可以改变；而改变的只是地址，原来的字符串还是存在的，并且产生垃圾。</b></p><h1 id="三、字符串常量池"><a href="#三、字符串常量池" class="headerlink" title="三、字符串常量池"></a>三、字符串常量池</h1><h2 id="3-1-字符串常量池概述"><a href="#3-1-字符串常量池概述" class="headerlink" title="3.1 字符串常量池概述"></a>3.1 字符串常量池概述</h2><p>1）常量池表（Constant_Pool table）</p><p>Class文件中存储所有常量（包括字符串）的table。<br>这是Class文件中的内容，还不是运行时的内容，不要理解它是个池子，其实就是Class文件中的字节码指令。</p><p>2）运行时常量池（Runtime Constant Pool）　</p><p>JVM内存中方法区的一部分，这是运行时的内容<br>这部分内容（绝大部分）是随着JVM运行时候，从常量池转化而来，每个Class对应一个运行时常量池<br>上一句中说绝大部分是因为：除了 Class中常量池内容，还可能包括动态生成并加入这里的内容</p><p>3）字符串常量池（String Pool）</p><p>这部分也在方法区中，但与Runtime Constant Pool不是一个概念，String Pool是JVM实例全局共享的，全局只有一个<br>JVM规范要求进入这里的String实例叫“被驻留的interned string”，各个JVM可以有不同的实现，HotSpot是设置了一个哈希表StringTable来引用堆中的字符串实例，被引用就是被驻留。</p><h2 id="3-2-亨元模式"><a href="#3-2-亨元模式" class="headerlink" title="3.2 亨元模式"></a>3.2 亨元模式</h2><p>其实字符串常量池这个问题涉及到一个设计模式，叫“享元模式”，顾名思义 - - - &gt; 共享元素模式<br>也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素<br>Java中String部分就是根据享元模式设计的，而那个存储元素的地方就叫做“字符串常量池 - String Pool”</p><h2 id="3-3-详细分析"><a href="#3-3-详细分析" class="headerlink" title="3.3 详细分析"></a>3.3 详细分析</h2><p>举例：</p><pre>    int x  = 10;    String y = "hello";</pre><p>1)首先，10和”hello”会在经过javac（或者其他编译器）编译过后变为Class文件中constant_pool table的内容<br>2)当我们的程序运行时，也就是说JVM运行时，每个Classconstant_pool table中的内容会被加载到JVM内存中的方法区中各自Class的Runtime Constant Pool。<br>3)一个没有被String Pool包含的Runtime Constant Pool中的字符串（这里是”hello”）会被加入到String Pool中（HosSpot使用hashtable引用方式），步骤如下：　　　<br>    一是：在Java Heap中根据”hello”字面量create一个字符串对象<br>    二是：将字面量”hello”与字符串对象的引用在hashtable中关联起来，键 - 值 形式是：”hello” = 对象的引用地址。<br>另外来说，当一个新的字符串出现在Runtime Constant Pool中时怎么判断需不需要在Java Heap中创建新对象呢？<br>策略是这样：会先去根据equals来比较Runtime Constant Pool中的这个字符串是否和String Pool中某一个是相等的（也就是找是否已经存在），如果有那么就不创建，直接使用其引用；反之，如上3。如此，就实现了享元模式，提高的内存利用效率。<br>举例：<br>使用String s = new String(“hello”); 会创建2个对象。<br>首先，出现了字面量”hello”，那么去String Pool中查找是否有相同字符串存在，因为程序就这一行代码所以肯定没有，那么就在Java Heap中用字面量”hello”首先创建1个String对象。<br>接着，new String(“hello”)，关键字new又在Java Heap中创建了1个对象，然后调用接收String参数的构造器进行了初始化。最终s的引用是这个String对象。</p><h1 id="四、常用方法"><a href="#四、常用方法" class="headerlink" title="四、常用方法"></a>四、常用方法</h1><h2 id="4-1-基本操作"><a href="#4-1-基本操作" class="headerlink" title="4.1 基本操作"></a>4.1 基本操作</h2><pre>    // 获取字符串的长度    int length()    // 返回指定字符在该字符串中第一次出现的位置，若无则返回-1    int indexOf(int ch)    // 返回指定字符在该字符串中最后一次出现的位置，若无则返回-1    int lastIndexOf(int ch)    // 返回指定位置的字符，其中index取值范围为（0~字符长度-1）    char charAt(int index)</pre><h2 id="4-2-转换操作"><a href="#4-2-转换操作" class="headerlink" title="4.2 转换操作"></a>4.2 转换操作</h2><pre>    // 转换为字符数组    char[] toCharArray()    // 将传入值转换为String （常见入参为Integer、Long、Double等）    String valueOf(xxx)    // 转换为小写    String toLowerCase()    // 转换为大写    String toUpperCase()</pre><h2 id="4-3-替换操作"><a href="#4-3-替换操作" class="headerlink" title="4.3 替换操作"></a>4.3 替换操作</h2><pre>    // 使用 replacement替换原字符串中所有的target    String replace(CharSequence target, CharSequence replacement)    // 替换字符串中的所有空格    String trim()</pre><h2 id="4-4-截取操作"><a href="#4-4-截取操作" class="headerlink" title="4.4 截取操作"></a>4.4 截取操作</h2><pre>    // 根据 regex 将原字符串拆分为 数组    String[] split(String regex)    // 截取 beginIndex 到 endIndex之间的字符串    String substring(int beginIndex, int endIndex)</pre><h2 id="4-5判断操作"><a href="#4-5判断操作" class="headerlink" title="4.5判断操作"></a>4.5判断操作</h2><pre>    // 判断值是否相等    boolean equals(Object anObject)    // 忽略大小写的判断    boolean equalsIgnoreCase(String anotherString)    // 是否以prefix 开头    startsWith(String prefix)    // 是否以prefix 结尾    endsWith(String prefix)    // 是否包含 s    boolean contains(CharSequence s)    // 是否是空字符串    boolean isEmpty()</pre><p>#五、String、StringBuffer、StringBuilder</p><h2 id="5-1-异同点"><a href="#5-1-异同点" class="headerlink" title="5.1 异同点"></a>5.1 异同点</h2><p>同：三者底层都是通过字符数组来进行维护的。</p><p>异：</p><table><thead><tr><th></th><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>是否可变</td><td>×</td><td>√</td><td>√</td></tr><tr><td>线程安全</td><td>√</td><td>√</td><td>×</td></tr></tbody></table><h2 id="5-2-效率比较"><a href="#5-2-效率比较" class="headerlink" title="5.2 效率比较"></a>5.2 效率比较</h2><p><b>通常情况下：StringBuilder &gt; StringBuffer &gt; String</b></p><p><b>PS:本文章相关代码均已上传至 GitHub <a href="https://github.com/weechang/java-zero" target="_blank">查看详情</a></b></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-成员变量&quot;&gt;&lt;a href=&quot;#1-1-成员变量&quot; class=&quot;headerlink&quot; title=&quot;1.1 成员变量&quot;&gt;&lt;/a&gt;1.1 成员变量&lt;/h2&gt;&lt;pre&gt;
    public final class String implements java.io.Serializable, Comparable&lt;string&gt;, CharSequence {

        private final char value[];

        private int hash; // Default to 0

        private static final long serialVersionUID = -6849794470754667710L;

        private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];
    }
&lt;/string&gt;&lt;/pre&gt;


&lt;p&gt;从源码可以看出，&lt;b&gt;String底层是通过一个不可变的字符串常量来进行维护的。所以只要一个字符改变就会生成一个新的String类型对象。&lt;/b&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java学习之从头开始" scheme="https://blog.weechang.xyz/categories/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
    
      <category term="Java基础" scheme="https://blog.weechang.xyz/categories/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java学习之从头开始" scheme="https://blog.weechang.xyz/tags/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
    
      <category term="Java基础" scheme="https://blog.weechang.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="String" scheme="https://blog.weechang.xyz/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>【Java学习之从头开始】Java基础-0——Object类</title>
    <link href="https://blog.weechang.xyz/2018/06/07/java%E5%9F%BA%E7%A1%80-0%E2%80%94%E2%80%94Object%E7%B1%BB/"/>
    <id>https://blog.weechang.xyz/2018/06/07/java基础-0——Object类/</id>
    <published>2018-06-07T10:39:22.000Z</published>
    <updated>2018-07-31T09:31:42.573Z</updated>
    
    <content type="html"><![CDATA[<p>从这篇文章起就正式开始Java学习之旅了。java中，万物皆对象，所以第一篇先学习Java的Object类，循序渐进。<br><a id="more"></a></p><h1 id="一、getClass"><a href="#一、getClass" class="headerlink" title="一、getClass()"></a>一、getClass()</h1><pre>public final native Class<?> getClass();</pre><p>返回此Object的运行时类类型。如： class io.github.weechang.java.base.JavaObject。<br>不可重写，要调用的话，一般和getName()联合使用，如getClass().getName(); // io.github.weechang.java.base.JavaObject</p><h1 id="二、hashCode"><a href="#二、hashCode" class="headerlink" title="二、hashCode()"></a>二、hashCode()</h1><pre>public native int hashCode();</pre><p>返回该对象的哈希值。如：123961122<br>该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。如HashSet、HashMap。<br>如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。</p><h1 id="三、equals"><a href="#三、equals" class="headerlink" title="三、equals()"></a>三、equals()</h1><pre>public boolean equals(Object obj) {    return (this == obj);}</pre><p>Object中的equals方法是直接判断this和obj是否是同一对象，所谓同一对象就是指内存中同一块存储单元，如果this和obj指向的是同一块内存对象，则返回true,如果this和obj指向的不是同一块内存，则返回false。</p><pre>注意：即便是内容完全相等的两块不同的内存对象，也返回false。     如果是同一块内存，则object中的equals方法返回true,如果是不同的内存，则返回false     如果希望不同内存但相同内容的两个对象equals时返回true,则我们需要重写父类的equal方法     Java中一部分类已经重写了object中的equals方法（这样就是比较内容是否相等了），如基本的包装类型 Integer、Long、Boolean等，还有String。</pre><h1 id="四、clone"><a href="#四、clone" class="headerlink" title="四、clone()"></a>四、clone()</h1><pre>protected native Object clone() throws CloneNotSupportedException;</pre><p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。<br>Java里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法（实现深复制）。</p><h2 id="4-1-clone与copy的区别"><a href="#4-1-clone与copy的区别" class="headerlink" title="4.1 clone与copy的区别"></a>4.1 clone与copy的区别</h2><p>在通常操作中，我们常采用的赋值方式为 User u1 = new User(); User u2 = u1;此时，User u2 = u1这种赋值方式就称为copy。此时的赋值只是简单地将u1所指向的内存地址赋值给了u2,所以此时u1、u2引用的是同一块内存空间。所以对u1或者u2任意对象的操作如u1.setId(2);都会带来另一对象的值的改变，此时可以发现u2.getId() 返回值也为2。若我们不希望带来这样的改变，就需要用到clone.User u2 = u1.clone();等价于User u2 = new User(); u2.setId(u1.getId());</p><p><b>copy：只是简单地将内存地址进行引用，实则两者是同一对象,任一对象值的改变，会带来另一对象值的改变。</b><br><b>clone: 两者是不同内存地址的对象，两者值只有在初始clone时一致，一个对象值的改变，不会带来另一对象值的改变。</b></p><h2 id="4-2-Shallow-Clone与Deep-Clone"><a href="#4-2-Shallow-Clone与Deep-Clone" class="headerlink" title="4.2 Shallow Clone与Deep Clone"></a>4.2 Shallow Clone与Deep Clone</h2><p>Object在对某个对象实施仅仅是简单地执行域对域的copy，这就是Shallow Clone。若User中存在一属性为 Date birthDay，此时u1与U2的引诱关系图如下：<br><img src="/2018/06/07/java基础-0——Object类/clone.png" title="Shallow Clone"><br>此时，除了基本数据类型是值的clone外，非基本数据类型都只是引用的clone。所以此时clone对象与原对象存在一部分相同的引用。此时任一对象的非基本类型的值改变，会导致另一对象的值的改变。若要解决此问题就需要Deep Clone。<br>针对User 对象可以对clone方法进行改造，如下：</p><pre>@Overrideprotected Object clone() throws CloneNotSupportedException {    User cloned = (User) super.clone();    cloned.birthDay = (Date) birthDay.clone();    return cloned;}</pre><h1 id="五、toString"><a href="#五、toString" class="headerlink" title="五、toString()"></a>五、toString()</h1><pre>public String toString() {    return getClass().getName() + "@" + Integer.toHexString(hashCode());}</pre><p>返回值为 字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。如 ：io.github.weechang.java.base.obj.User@762efe5d</p><h1 id="六、notify"><a href="#六、notify" class="headerlink" title="六、notify()"></a>六、notify()</h1><pre>public final native void notify();</pre><p>该方法唤醒在该对象上等待的某个线程</p><h1 id="七、notifyAll"><a href="#七、notifyAll" class="headerlink" title="七、notifyAll()"></a>七、notifyAll()</h1><pre>public final native void notifyAll();</pre><p>该方法唤醒在该对象上等待的所有线程。</p><h1 id="八、wait"><a href="#八、wait" class="headerlink" title="八、wait()"></a>八、wait()</h1><pre>public final void wait() throws InterruptedException {    wait(0);}</pre><pre>public final native void wait(long timeout) throws InterruptedException;</pre><pre>/***@param timeout  等待该线程终止的时间最长为timeout毫秒。 *@param nanos 等待时间为 timeout毫秒+nanos纳秒*/public final void wait(long timeout, int nanos) throws InterruptedException {      if (timeout < 0) {          throw new IllegalArgumentException("timeout value is negative");      }      if (nanos < 0 || nanos > 999999) {          throw new IllegalArgumentException("nanosecond timeout value out of range");      }     if (nanos > 0) {         timeout++;     }     wait(timeout); }</pre><p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，</p><p>如果在规定时间内没有获得锁就返回。</p><h1 id="九、finalize"><a href="#九、finalize" class="headerlink" title="九、finalize()"></a>九、finalize()</h1><pre> protected void finalize() throws Throwable { }</pre>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。Java允许在类中定义一个名为finalize()的方法。它的工作原理是：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法。并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。<pre>关于垃圾回收，有三点需要记住：　　1、对象可能不被垃圾回收。只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。　　2、垃圾回收并不等于“析构”。　　3、垃圾回收只与内存有关。使用垃圾回收的唯一原因是为了回收程序不再使用的内存。</pre><pre>finalize()的用途：　　无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。　　不过这种情况一般发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式。</pre><p><b>PS:本文章相关代码均已上传至 GitHub <a href="https://github.com/weechang/java-zero" target="_blank">查看详情</a></b></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从这篇文章起就正式开始Java学习之旅了。java中，万物皆对象，所以第一篇先学习Java的Object类，循序渐进。&lt;br&gt;
    
    </summary>
    
      <category term="Java学习之从头开始" scheme="https://blog.weechang.xyz/categories/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
    
      <category term="Java基础" scheme="https://blog.weechang.xyz/categories/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java学习之从头开始" scheme="https://blog.weechang.xyz/tags/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
    
      <category term="Java基础" scheme="https://blog.weechang.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Object" scheme="https://blog.weechang.xyz/tags/Object/"/>
    
  </entry>
  
</feed>
