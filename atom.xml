<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>耒耒耒耒耒</title>
  
  <subtitle>张未的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.weechang.xyz/"/>
  <updated>2018-08-31T02:55:36.387Z</updated>
  <id>http://blog.weechang.xyz/</id>
  
  <author>
    <name>张未</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AxonFramework-EventStore实现</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-EventStore%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-EventStore实现/</id>
    <published>2018-08-31T02:52:45.000Z</published>
    <updated>2018-08-31T02:55:36.387Z</updated>
    
    <content type="html"><![CDATA[<p>事件溯源存储库需要一个事件存储（event store）从聚合中存储和加载事件。事件存储提供了一个事件总线的功能，增加了持久化已发布的事件，并能够基于聚合标识符检索事件。</p><a id="more"></a><p>Axon提供了一个开箱即用的事件存储，EmbeddedEventStore。它委托事件实际的存储和检索到EventStorageEngine。<br>有多个EventStorageEngine的实现：</p><h2 id="JpaEventStorageEngine"><a href="#JpaEventStorageEngine" class="headerlink" title="JpaEventStorageEngine"></a>JpaEventStorageEngine</h2><p>JpaEventStorageEngine存储事件在JPA-compatible数据源中。JPA事件存储存储事件在所谓的条目中。这些条目包含事件的序列化形式，以及存储一些领域元数据以快速查找这些条目。使用JpaEventStorageEngine，你必须在你的类路径中有JPA注解(javax.persistence)。</p><p>默认情况下，事件存储需要你配置你的持久化上下文(如在META-INF/persistence.xml中定义)包含DomainEventEntry和SnapshotEventEntry（两者都在org.axonframework.eventsourcing.eventstore.jpa包中)。<br>下面是一个持久化上下文配置的示例配置：</p><pre><persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">    <persistence-unit name="eventStore" transaction-type="RESOURCE_LOCAL"> (1)        <class>org...eventstore.jpa.DomainEventEntry</class> (2)        <class>org...eventstore.jpa.SnapshotEventEntry</class>    </persistence-unit></persistence></pre><p>在这个示例中，事件存储有一个特定的持久化单元。然而，你可能会选择将第三行添加到任何其他持久化单元的配置中。<br>本行注册DomainEventEntry(由JpaEventStore使用的类)到持久化上下文。</p><blockquote><p><b>注意</b><br>Axon使用锁来防止两个线程访问相同的聚合。然而，如果在同一数据库上你有多个jvm，这不会帮助你。在这种情况下，你不得不依靠数据库来检测冲突。并发访问事件存储将导致违反主键约束（Key Constraint Violation），因为表允许聚合只能有一个任何序列号的事件，所以，用已有的序列号为现有聚合插入第二个事件将导致错误。<br>JpaEventStorageEngine可以检测这个错误并把它转换成ConcurrencyException。然而，每个数据库系统以不同的方式报告此违规行为。如果你用JpaEventStore注册你的数据源，它将尝试检测数据库的类型，并找出错误代码是一个违反主键约束（Key Constraint Violation）。或者，你可能会提供一个PersistenceExceptionTranslator实例，如果一个给定的异常代表一个违反主键约束（Key Constraint Violation）它能分辨。<br>如果没有提供数据源或PersistenceExceptionTranslator，从数据库驱动程序按原样抛出异常。</p></blockquote><p>默认情况下，JPA事件存储引擎需要一个EntityManagerProvider实现，返回EventStorageEngine使用的EntityManager实例。这还允许应用程序管理所用的持久化上下文。EntityManagerProvider的责任是提供一个正确的EntityManager实例。</p><p>有几个EntityManagerProvider的实现可用，各有不同的需求。SimpleEntityManagerProvider仅在构建时返回EntityManager实例给它。这使得实现成为容器管理上下文一个简单的选择。ContainerManagedEntityManagerProvider作为一种选择，返回默认的持久化上下文，并且它的使用默认通过JPA事件存储。<br>如果你有一个持久化单元称为“myPersistenceUnit”，你希望在JpaEventStore中使用，这就是EntityManagerProvider实现，可能看起来像:</p><pre>public class MyEntityManagerProvider implements EntityManagerProvider {    private EntityManager entityManager;    @Override    public EntityManager getEntityManager() {        return entityManager;    }    @PersistenceContext(unitName = "myPersistenceUnit")    public void setEntityManager(EntityManager entityManager) {        this.entityManager = entityManager;    }}</pre>   <p>默认情况下，JPA事件存储把条目存储在DomainEventEntry和SnapshotEventEntry实体中。虽然在许多情况下这就足够了，你可能会遇到这些实体提供的元数据不够的情况。或者你可能想将不同的聚合类型的事件存储在不同的表。<br>如果是这样,你可以扩展JpaEventStorageEngine。它包含了一些protected方法，你可以重写来调整其行为。</p><blockquote><p><b>警告</b><br>注意持久化提供者，如Hibernate，在它们的EntityManager实现上使用一级缓存。通常，这意味着在查询中使用或返回的所有隶属于EntityManager的实体。它们只有在周围事务被提交或在事务中执行显式“清除”时才被清除。当查询在事务上下文中执行时尤其如此。<br>要解决这个问题，请确保仅仅查询非实体对象。你可以使用JPA的“SELECT new SomeClass(parameters) FROM …”风格的查询来解决这个问题。或者，获取一批事件后调用EntityManager.flush()和EntityManager.clear()。未能这样做当加截大事件流时可能导致OutOfMemoryExceptions。</p></blockquote><h2 id="JDBC-Event-Storage-Engine"><a href="#JDBC-Event-Storage-Engine" class="headerlink" title="JDBC Event Storage Engine"></a>JDBC Event Storage Engine</h2><p>JDBC事件存储引擎使用JDBC连接将事件存储在JDBC兼容的数据存储。通常，这些都是关系数据库。从理论上讲，任何一个JDBC驱动程序都可以用来支持JDBC事件存储引擎。</p><p>类似于JPA，JDBC事件存储引擎将事件存储在条目中。默认情况下，每个事件存储在一个单独的条目中，对应表中的一行。一个表用于事件，另一个用于快照。</p><p>JdbcEventStorageEngine使用ConnectionProvider来获取连接。通常，这些连接可以直接从数据源中获得。然而，Axon会将这些连接绑定到一个工作单元，以便在一个工作单元使用一个连接。这将确保一个单独的事务用于存储所有事件，即使在同一线程中嵌套多个工作单元。</p><blockquote><p><b>注意</b><br>Spring用户建议使用SpringDataSourceConnectionProvider从数据源附加连接到现有的事务。</p></blockquote><h2 id="MongoDB-Event-Storage-Engine"><a href="#MongoDB-Event-Storage-Engine" class="headerlink" title="MongoDB Event Storage Engine"></a>MongoDB Event Storage Engine</h2><p>MongoDB是一个基于文档的NoSQL存储。其可伸缩特性使它适合用于事件存储。Axon提供了MongoEventStorageEngine,使用MongoDB作为数据库支持。它包含在Axon Mongo模块(Maven artifactId axon-mongo)。</p><p>事件存储在两个独立的集合中：一个用于实际的事件流，一个用于快照。</p><p>默认情况下，MongoEventStorageEngine将存储各自的事件在各自的文档。然而，它是可能改变StorageStrategy使用。</p><p>Axon提供的选择是DocumentPerCommitStorageStrategy，为在一个单独的提交中存储所有事件，创建一个单独的文档(即在同一DomainEventStream)。</p><p>在一个单独的文档中存储整个提交的好处在于提交是原子存储的。此外，它只需要对任意数量的事件进行一次往返。缺点是,它变得更加难以直接在数据库中查询事件。例如，当重构领域模型时，如果他们被包含在“commit document”中，很难从一个聚合“transfer”事件到另一个聚合。</p><p>MongoDB不需要很多配置。它所需要的只是对一个存储事件集合的引用，然后你就可以开始了。在生产环境中，你可能想要对集合中的索引进行双重检查。</p><h2 id="Event-Store-Utilities"><a href="#Event-Store-Utilities" class="headerlink" title="Event Store Utilities"></a>Event Store Utilities</h2><p>Axon提供了一些事件存储引擎，可能在某些情况下是有用的。</p><p>SequenceEventStorageEngine是围绕其它两个事件存储引擎的包装器。当读取时,它从这两个事件存储引擎中返回事件。附加事件只是附加到第二个事件存储引擎。出于性能原因使用事件存储两种不同的实现的情况下，这是有用的，例如。第一个是一个更大的，但较慢事件存储，而第二个是优化的快速读取和写入。</p><p>还有一个常驻内存的存储事件EventStorageEngine实现：InMemoryEventStorageEngine。虽然它可能优于任何其他的事件存储，这并不意味着长期生产使用。然而，它在需要事件存储的short-lived工具或测试中非常有用,。</p><h2 id="Influencing-the-serialization-process（影响序列化过程）"><a href="#Influencing-the-serialization-process（影响序列化过程）" class="headerlink" title="Influencing the serialization process（影响序列化过程）"></a>Influencing the serialization process（影响序列化过程）</h2><p>事件存储需要为存储准备一种序列化事件的方法。默认情况下，Axon使用XStreamSerializer，其使用XStream序列化成XML事件。XStream是相当快的，比Java序列化更灵活。此外，XStream序列化的结果是人类可读的。对日志和调试而言非常有用。</p><p>XStreamSerializer可以配置。你可以定义它应该用于某些包、类甚至字段的别名。除了可以缩短潜在的长名称之外，还可以在事件的类定义更改时使用别名。有关别名的更多信息，访问XStream网站。</p><p>另外，Axon还提供了JacksonSerializer，使用Jackson将事件序列化为JSON。当它生成一个更紧凑的序列化形式，它要求类遵守Jackson所要求的约定(或配置)。</p><blockquote><p><b>注意</b><br>使用Java代码(或其他JVM语言)配置序列化器是很容易的。然而，由于它调用方法的局限性，在Spring XML程序上下文看配置它并不那么简单。其中一个选项是创建一个FactoryBean，创建一个XStreamSerializer实例，并配置它的代码。检查 Spring 参考更多的信息。</p></blockquote><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/7ffff660d9a1" target="_blank" rel="noopener">https://www.jianshu.com/p/7ffff660d9a1</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件溯源存储库需要一个事件存储（event store）从聚合中存储和加载事件。事件存储提供了一个事件总线的功能，增加了持久化已发布的事件，并能够基于聚合标识符检索事件。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-存储库</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%AD%98%E5%82%A8%E5%BA%93/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-存储库/</id>
    <published>2018-08-31T02:50:48.000Z</published>
    <updated>2018-08-31T02:52:08.827Z</updated>
    
    <content type="html"><![CDATA[<p>存储库是提供对聚合访问的机制。存储库充当了用于保存数据的实际存储机制的网关。在CQRS中，存储库只需要能够根据他们的惟一标识符找到聚合。任何其他类型的查询，应该在查询数据库中执行。</p><a id="more"></a><p>在Axon Framework中,所有存储库必须实现Repository接口。这个接口规定了三种方法:load(identifier, version)， load(identifier)和newInstance(factoryMethod)。load方法允许你从存储库加载聚合。version可选参数是用来检测并发修改(见Advanced conflict detection and resolution)。newInstance用于注册新创建的聚合到存储库中。</p><p>基于你潜在的持久性存储和审计需求，有一些基础实现提供大了部分存储库所需的基本功能。Axon Framework对保存聚合当前状态的存储库(见Standard Repositories)和那些存储聚合事件的存储库(见 Event Sourcing Repositories)进行了区分。</p><p>注意，存储库接口没有声明delete(identifier)方法。删除聚合是通过在一个聚合内部调用AggregateLifecycle.markDeleted()方法完成的。删除聚合是一个与其他迁移一样的状态迁移，唯一的区别是它在许多情况下是不可逆的。你应该在聚合上创建自己的有意义的方法，来将聚合的状态设置为“已删除”。这也允许你注册你想要发布的任何事件。</p><h2 id="Standard-repositories（标准存储库）"><a href="#Standard-repositories（标准存储库）" class="headerlink" title="Standard repositories（标准存储库）"></a>Standard repositories（标准存储库）</h2><p>标准存储库存储聚合的实际状态。在每次修改后，新的状态将覆盖旧的。这使得命令组件也可以使用应用程序的查询组件使用的相同信息。标准存储库存储聚合的实际状态。这可能取决于你正在创建的应用程序的类型，这是最简单的解决方案。如果是这样的话，Axon提供了一些帮助你实现这样一个存储库的构件。</p><p>Axon为标准存储库提供了一个开箱即用的实现：GenericJpaRepository。它认为聚合是一个有效的JPA实体。它使用EntityManagerProvider配置，EntityManagerProvider提供EntityManager来管理实际的持久化，并且一个类指定聚合的实际类型存储在存储库中。当聚合调用静态AggregateLifecycle.apply()方法时，你也可以通过EventBus去发布事件。</p><p>你也可以轻松实现自己的存储库。在这种情况下，最好从抽象类LockingRepository扩展。作为聚合的包装器类型，建议使用AnnotatedAggregate。看GenericJpaRepository的源码示例。</p><h2 id="Event-Sourcing-repositories（事件溯源存储库）"><a href="#Event-Sourcing-repositories（事件溯源存储库）" class="headerlink" title="Event Sourcing repositories（事件溯源存储库）"></a>Event Sourcing repositories（事件溯源存储库）</h2><p>聚合根能够根据事件重建它们的状态，也可以配置为通过事件溯源存储库加载。这些存储库不存储聚合本身，但存储聚合生成的一系列事件。基于这些事件，可以随时恢复聚合的状态。</p><p>在AxonFramework中，EventSourcingRepository实现提供了任何事件溯源存储库所需的基本功能。这依赖于EventStore(见Implementing your own Event Store)，它抽象了实际的存储机制。</p><p>根据情况，你可以提供一个聚合工厂。AggregateFactory指定了如何创建一个聚合实例。一旦创建了一个聚合，EventSourcingRepository可以使用从事件存储中加载的事件来初始化。Axon Framework自带了一些你可以使用的AggregateFactory实现。如果他们还不够，可以很容易创建你自己的实现。</p><h2 id="GenericAggregateFactory"><a href="#GenericAggregateFactory" class="headerlink" title="GenericAggregateFactory"></a>GenericAggregateFactory</h2><p>GenericAggregateFactory是一种特别的AggregateFactory实现，可用于任何类型的事件溯源聚合根。GenericAggregateFactory创建存储库管理的聚合类型的一个实例。聚合类必须是非抽象的，声明一个默认的不进行初始化的无参构造函数化。<br>GenericAggregateFactory适用于大多数场景，聚合不需要专门注入non-serializable资源。</p><h2 id="SpringPrototypeAggregateFactory"><a href="#SpringPrototypeAggregateFactory" class="headerlink" title="SpringPrototypeAggregateFactory"></a>SpringPrototypeAggregateFactory</h2><p>根据你的架构选择，使用Spring将依赖项注入到聚合中可能是有用的。例如，你可以将查询库注入到你的聚合，以确保某些值的存在(或不存在)。</p><p>注入依赖项到你的聚合，在定义了SpringPrototypeAggregateFactory的Spring上下文中，你需要配置一个聚合根的属性bean。不是使用构造函数创建的常规的实例，而是使用Spring应用程序上下文实例化你聚合。这也将在你的聚合中注入的任何依赖项。</p><h2 id="实现自己的AggregateFactory"><a href="#实现自己的AggregateFactory" class="headerlink" title="实现自己的AggregateFactory"></a>实现自己的AggregateFactory</h2><p>在某些情况下，GenericAggregateFactory不能提供你所需要的东西。例如，你可以有一个抽象的聚合类型与不同的场景的多个实现(例如，PublicUserAccount和BackOfficeAccount都扩展一个帐户)。而不是为每个聚合创建不同的存储库，你可以使用一个单独的存储库，并配置一个AggregateFactory意识到不同的实现。</p><p>聚合工厂大部分的工作是创建未初始化的聚合实例。它必须使用一个给定的聚合标识符和流中的第一个事件。通常，这个事件是一个创建事件，其中包含关于预期聚合类型的提示。你可以使用这些信息来选择一个实现并调用其构造函数。确保没有事件被应用于构造函数；聚合必须未初始化。</p><p>相对于简单的存储库直接加载聚合的实现，基于事件初始化聚合可能是一项耗时的工作,。CachingEventSourcingRepository提供一个可以从中加载聚合的缓存</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/585e95e31704" target="_blank" rel="noopener">https://www.jianshu.com/p/585e95e31704</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存储库是提供对聚合访问的机制。存储库充当了用于保存数据的实际存储机制的网关。在CQRS中，存储库只需要能够根据他们的惟一标识符找到聚合。任何其他类型的查询，应该在查询数据库中执行。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-分发事件</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%88%86%E5%8F%91%E4%BA%8B%E4%BB%B6/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-分发事件/</id>
    <published>2018-08-31T02:47:38.000Z</published>
    <updated>2018-08-31T02:49:58.936Z</updated>
    
    <content type="html"><![CDATA[<p>在某些情况下，有必要发布事件到外部系统,比如消息broker。</p><a id="more"></a><h2 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h2><p>Axon提供了开箱即用的支持从一个AMQP message broker中转递事件和传递事件到broker中，比如Rabbit MQ。</p><h2 id="将事件转发到AMQP-Echange"><a href="#将事件转发到AMQP-Echange" class="headerlink" title="将事件转发到AMQP Echange"></a>将事件转发到AMQP Echange</h2><p>SpringAMQPPublisher将事件转发给一个AMQP Exchange。它使用SubscribableMessageSource初始化，一般是EventBus或EventStore。从理论上讲，这可能是发布者可以订阅的任何事件源。</p><p>要配置SpringAMQPPublisher，只需一个实例定义为Spring Bean。有一些setter方法允许你指定你预期的行为，如事务支持，publisher 确认(如果由broker支持)，和交换名称。</p><p>默认的exchange名称为’Axon.EventBus’</p><blockquote><p><b>注意</b><br>注意，exchanges不会被自动创建。你还必须声明队列、Exchanges 和你希望使用的Bindings 。检查Spring文档了解更多信息。</p></blockquote><h2 id="从AMQP-队列中读取事件"><a href="#从AMQP-队列中读取事件" class="headerlink" title="从AMQP 队列中读取事件"></a>从AMQP 队列中读取事件</h2><p>Spring已经广泛的支持从一个AMQP队列读取消息。然而,这需要与Axon“架桥”，以便这些消息可以从Axon处理，就像它们是常规事件消息一样。</p><p>SpringAMQPMessageSource允许事件处理器从队列中读取消息，而不是事件存储或事件总线。它作为一个Spring AMQP和SubscribableMessageSource之间的适配器需要这些处理器。</p><p>配置SpringAMQPMessageSource最简单的方法，是通过定义一个bean，重写默认的onMessage方法并使用@RabbitListener注解，如下:</p><pre>@Beanpublic SpringAMQPMessageSource myMessageSource(Serializer serializer) {    return new SpringAMQPMessageSource(serializer) {        @RabbitListener(queues = "myQueue")        @Override        public void onMessage(Message message, Channel channel) throws Exception {            super.onMessage(message, channel);        }    };}</pre><p>Spring的@RabbitListener注解告诉Spring，这个方法需要被给定队列上的每个消息调用(myQueue的例子)。此方法简单地调用super.onMessage()方法，执行实际事件的发布到已经订阅它的所有处理器。</p><p>订阅这个MessageSource的处理器，将正确的SpringAMQPMessageSource实例传递给订阅处理器的构造函数:</p><pre>// in an @Configuration file:@Autowiredpublic void configure(EventHandlingConfiguration ehConfig, SpringAmqpMessageSource myMessageSource) {    ehConfig.registerSubscribingEventProcessor("myProcessor", c -> myMessageSource);}</pre><p>请注意跟踪处理器与SpringAMQPMessageSource不兼容。</p><h2 id="异步事件处理"><a href="#异步事件处理" class="headerlink" title="异步事件处理"></a>异步事件处理</h2><p>异步处理事件推荐的方法是使用跟踪事件处理器。这个实现可以保证所有事件的处理，甚至在发生系统故障的情况下(假定事件已经被持久化)。</p><p>然而,也有可能在SubscribingProcessor中异步处理事件。要做到这一点，SubscribingProcessor必须用EventProcessingStrategy配置。这种策略可以用来改变事件监听器的调用应如何管理。</p><p>默认策略(DirectEventProcessingStrategy)在传递事件的线程中调用这些事件处理程序。这允许处理器使用现有的事务。</p><p>其他Axon-provided strategy是AsynchronousEventProcessingStrategy。它使用一个Executor异步调用事件侦听器。</p><p>尽管AsynchronousEventProcessingStrategy异步执行，某些事件按顺序处理仍然是可取的。SequencingPolicy定义事件是否必须按顺序处理，并行或两者的结合。策略返回给定事件的序列标识符。如果两个事件的策略返回一个相等的标识符,这意味着他们必须由事件处理程序按顺序处理。一个空序列标识符意味着事件可能与任何其他事件并行处理。</p><p>Axon提供了一些可以使用的通用策略：</p><ul><li>FullConcurrencyPolicy会告诉Axon，事件处理程序可以处理所有并发事件。这意味着需要按特定顺序处理的事件之间没有关系。</li><li>SequentialPolicy告诉Axon，所有活动必须按照顺序进行处理。处理事件的操作将在处理前一个事件完成时开始。</li><li>SequentialPerAggregatePolicy将迫使领域事件从同一聚合顺序处理。然而，事件来自不同聚合可能并发处理。这通常是一个合适的政策，用于事件侦听器更新数据库中聚合的细节。</li></ul><p>除了这些提供的策略之外，你可以定义自己的策略。所有策略都必须实现SequencingPolicy接口。这个接口定义了一个方法getSequenceIdentifierFor，返回值为一个给定的事件序列标识符。返回相等序列标识符的事件必须按顺序处理。产生不同序列标识符的事件可以同时处理。出于性能原因，如果事件可以并行处理任何其他事件，则策略实现应该返回null。这样更快，因为Axon不必检查对事件处理的任何限制条件。</p><p>当使用AsynchronousEventProcessingStrategy时建议明确定义一个ErrorHandler。默认的ErrorHandler传播异常，但在异步执行中没有什么可以传播的，除了Executor。这可能导致事件没有被处理。相反，建议使用一个ErrorHandler报告错误，并允许继续处理。ErrorHandler被配置在SubscribingEventProcessor的构造函数上，还提供了EventProcessingStrategy。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/c333f2c05239" target="_blank" rel="noopener">https://www.jianshu.com/p/c333f2c05239</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在某些情况下，有必要发布事件到外部系统,比如消息broker。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-事件发布和处理</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-事件发布和处理/</id>
    <published>2018-08-31T02:44:40.000Z</published>
    <updated>2018-08-31T02:46:47.068Z</updated>
    
    <content type="html"><![CDATA[<p>由应用程序生成的事件需要被分发到更新查询数据库的组件，搜索引擎或其他需要它们的资源：事件处理程序（Event Handlers）。事件总线（Event Bus）的职责是分发事件消息到所有感兴趣的组件。接收端，事件处理器（Event Processors）负责处理这些事件，其中包括相应的事件处理程序（Event Handlers）的调用。</p><a id="more"></a><h2 id="发布事件（Publishing-Events）"><a href="#发布事件（Publishing-Events）" class="headerlink" title="发布事件（Publishing Events）"></a>发布事件（Publishing Events）</h2><p>在绝大多数情况下，聚合将通过申请（applying）它们发布事件。然而，有时候也有必要发布一个事件(可能来自另一个组件)，直接到事件总线。发布一个事件，在EventMessage中简单封装描述事件的有效负载（payload）。</p><p>GenericEventMessage.asEventMessage(Object)方法允许你将任何对象包装成EventMessage。如果传递的对象已经是EventMessage，它只是返回。</p><h2 id="事件总线（Event-Bus）"><a href="#事件总线（Event-Bus）" class="headerlink" title="事件总线（Event Bus）"></a>事件总线（Event Bus）</h2><p>EventBus是分发事件到已订阅的事件处理器的机制。Axon 提供了两个事件总线的实现：SimpleEventBus和EmbeddedEventStore。两个实现都支持订阅和跟踪处理器(processor)，EmbeddedEventStore持久化事件，它允许你在以后的阶段重放它们。SimpleEventBus有一个易失性存储器，然后一旦事件已经发布到订阅组件上，就会“忘记”它们。</p><p>当使用配置API时，默认情况下使用SimpleEventBus。配置EmbeddedEventStore则相反，需要提供一个StorageEngine的实现，它对事件进行实际存储。</p><pre>Configurer configurer = DefaultConfigurer.defaultConfiguration();configurer.configureEmbeddedEventStore(c -> new InMemoryEventStorageEngine());</pre><h2 id="Event-Processors"><a href="#Event-Processors" class="headerlink" title="Event Processors"></a>Event Processors</h2><p>事件处理程序（Event Handlers）定义了接收事件时执行的业务逻辑。事件处理器（Event Processors）负责解决该过程的技术方面的组件。它们启动一个工作单元，也可能一个事务，并且确保相关的数据在事件处理期间，可以正确附加到所有创建的消息上。</p><p>事件处理器大致有两种形式：订阅和跟踪。订阅事件处理器订阅它们自己给事件源，并由发布机制管理的线程调用。另一方面，跟踪事件处理器使用自己管理的线程从源中取出它们的消息。</p><h2 id="将处理程序分配给处理器"><a href="#将处理程序分配给处理器" class="headerlink" title="将处理程序分配给处理器"></a>将处理程序分配给处理器</h2><p>所有处理器都有一个名称，它跨JVM实例标识一个处理器实例。两个名称相同的处理器，可以被认为是同一处理器的两个实例。<br>所有事件处理程序都被附加到一个处理器，它的名字是事件处理程序类的包名。<br>例如, 下面的类：</p><ul><li>org.axonframework.example.eventhandling.MyHandler,</li><li>org.axonframework.example.eventhandling.MyOtherHandler</li><li>org.axonframework.example.eventhandling.module.MyHandler</li></ul><p>将触发两个处理器的创建：</p><ul><li>org.axonframework.example.eventhandling with 2 handlers, and</li><li>org.axonframework.example.eventhandling.module with a single handler</li></ul><p>配置API允许你为分配的类配置其他策略给处理器，甚至将特定实例分配给特定的处理器。</p><h2 id="配置处理器"><a href="#配置处理器" class="headerlink" title="配置处理器"></a>配置处理器</h2><p>默认情况下，Axon将使用订阅事件处理器。这是有可能改变处理程序是如何分配和如何使用配置API的EventHandlingConfiguration类配置处理器的。</p><p>EventHandlingConfiguration类定义了一些的方法，可用于定义处理器需要如何配置。</p><ul><li>registerEventProcessorFactory允许你定义一个默认的工厂方法，创建没有明确定义工厂的事件处理器。</li><li>registerEventProcessor(String name, EventProcessorBuilder builder)定义了用于创建一个带有给定名称的处理器的工厂方法。注意，此种处理器只有当名称被选择作为任何可用的事件处理程序bean的处理器时才会创建。</li><li>registerTrackingProcessor(String name)定义了一个带有给定名称的处理器，使用默认设置，应该被配置成一个跟踪事件处理器。它使用TransactionManager和TokenStore配置。</li><li>usingTrackingProcessors()设置默认跟踪处理器，而不是订阅处理器。</li></ul><p>跟踪处理器不像订阅处理器，需要一个令牌存储来存储它们的进程。跟踪处理器通过其事件流接收的每个消息都伴随着一个令牌。这个令牌允许处理器在任何以后的点重新打开流，并在最后一个事件中提取它。</p><p>配置API负责令牌存储，以及大多数其他组件处理器需要从全局配置实例。如果没有明确定义TokenStore ，在生产中不推荐使用InMemoryTokenStore。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/217ac0d8822d" target="_blank" rel="noopener">https://www.jianshu.com/p/217ac0d8822d</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由应用程序生成的事件需要被分发到更新查询数据库的组件，搜索引擎或其他需要它们的资源：事件处理程序（Event Handlers）。事件总线（Event Bus）的职责是分发事件消息到所有感兴趣的组件。接收端，事件处理器（Event Processors）负责处理这些事件，其中包括相应的事件处理程序（Event Handlers）的调用。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-分布式命令总线连接器</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%88%86%E5%B8%83%E5%BC%8F%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF%E8%BF%9E%E6%8E%A5%E5%99%A8/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-分布式命令总线连接器/</id>
    <published>2018-08-31T02:40:27.000Z</published>
    <updated>2018-08-31T02:43:19.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JGroupsConnector"><a href="#JGroupsConnector" class="headerlink" title="JGroupsConnector"></a>JGroupsConnector</h2><p>JGroupsConnector使用(正如它的名字已经说明)JGroups作为底层发现和调度机制。描述JGroups的特性有太多的参考指南,请参阅JGroups用户指南以了解更多的细节。</p><a id="more"></a><p>因为JGroups既处理节点的发现又处理它们之间的通信，所以JGroupsConnector既充当CommandBusConnector也充当CommandRouter。</p><blockquote><p><b>注意</b><br>你可以在axon-distributed-commandbus-jgroups模块中，为DistributedCommandBus找到JGroups特定组件。</p></blockquote><p>JGroupsConnector有四个强制性配置元素：</p><ul><li>第一种是JChannel，它定义了JGroups协议栈。一般来说，用JGroups配置文件的引用构造JChannel。JGroups附带的默认配置,可以用作自己配置的依据。请记住，IP多路广播一般不工作在云服务中，像亚马逊。中这种类型的环境中， TCP Gossip通常是一个好的开端。</li><li>集群名称定义了每个segment应登记到的集群的名称。具有相同的集群名称的Segment最终会探测到彼此，并在彼此间分发命令。</li><li>“本地segment”是命令总线实现，分发命令去往本地的JVM。这些命令可能已通过其他JVM或从本地的一个实例分发。</li><li>最后，序列化器是用来序列化之前通过线路发送的命令消息。</li></ul><blockquote><p><b>注意</b><br>当使用缓存时，当ConsistentHash更改以避免潜在的数据损坏时，它应该被清空（例如，当命令没有指定一个@TargetAggregateVersion和新成员快速加入和离开JGroup，修改聚合然而它还要缓存到其他地方）。</p></blockquote><p>最终，JGroupsConnector需要实际连接，按顺序分发消息到其他segment。这样做，调用connect()方法。</p><pre>JChannel channel = new JChannel("path/to/channel/config.xml");CommandBus localSegment = new SimpleCommandBus();Serializer serializer = new XStreamSerializer();JGroupsConnector connector = new JGroupsConnector(channel, "myCommandBus", localSegment, serializer);DistributedCommandBus commandBus = new DistributedCommandBus(connector, connector);// on one node:commandBus.subscribe(CommandType.class.getName(), handler);connector.connect();// on another node, with more CPU:commandBus.subscribe(CommandType.class.getName(), handler);commandBus.subscribe(AnotherCommandType.class.getName(), handler2);commandBus.updateLoadFactor(150); // defaults to 100connector.connect();// from now on, just deal with commandBus as if it is local...</pre><blockquote><p><b>注意</b><br>注意，并非所有的segment都必需具有相同类型的命令的命令处理器。你完全可以为不同的命令类型使用不同的segment。分布式命令总线总是选择一个节点分发命令到那个支持特定类型的命令。</p></blockquote><p>如果你使用Spring，你可能需要考虑使用JGroupsConnectorFactoryBean。它自动连接连接器当ApplicationContext启动后，并且在ApplicationContext关闭时完全的断开。此外,它为测试环境使用合理的默认值(但不应被视为生产准备)和自动装配配置。</p><h2 id="Spring-Cloud-Connector"><a href="#Spring-Cloud-Connector" class="headerlink" title="Spring Cloud Connector"></a>Spring Cloud Connector</h2><p>Spring Cloud连接器装置，用Spring Cloud来描述使用服务注册和发现机制来分配命令总线。因此，你可以自由选择使用哪一个Spring Cloud实现用来分发你的命令。实现的一个例子是 Eureka Discovery/Eureka 服务器组合。</p><blockquote><p><b>注意</b><br>当前版本(Axon 3.0.4)SpringCloudCommandRouter使用ServiceInstance。Metadata 字段来通知所有系统中的节点，通过CommandNameFilter它可以处理命令。这是很重要的,Spring Cloud实现选择支持ServiceInstance.Metadata字段的使用。例如Spring Cloud Consul目前不支持该字段，因此SpringCloudCommandRouter并不是一个可行的解决方案。我们正在研究一个额外的解决方案，从中检索CommandNameFilter 。</p></blockquote><p>提供每个SpringCloud实现的描述将推动本参考指南。因此，我们参考他们各自的文件以获得进一步的信息。</p><p>Spring Cloud连接器装置是一个SpringCloudCommandRouter和SpringHttpCommandBusConnector的组合，分别填充CommandRouter的地点和 DistributedCommandBus的CommandBusConnector。</p><blockquote><p><b>注意</b><br>Spring Cloud连接器特定的组件DistributedCommandBus可以在axon-distributed-commandbus-springcloud模块中找到 。</p></blockquote><p>SpringCloudCommandRouter必须由以下提供的来创建：</p><ul><li>一个DiscoveryClient类型“discovery client”。这可以通过用@EnableDiscoveryClient注解你的Spring Boot应用程序来提供,将在你的类路径中寻找Spring Cloud 的实现。</li><li>一个RoutingStrategy类型的”routing strategy”。目前axon-core模块提供了一些实现，但是一函数调用也可以满足要求。例如，如果你想路由命令基于“聚合标识符”，你可以使用AnnotationRoutingStrategy和注解有效载荷的字段，用@TargetAggregateIdentifier识别聚合。</li></ul><p>SpringHttpCommandBusConnector需要创建三个参数:</p><ul><li>一个CommandBus类型的“local command bus”。这是命令总线实现，它将分发命令到本地的JVM。这些命令可能是由其他JVM上的或本地的实例分发。</li><li>RestOperations对象来执行一个命令消息的发布到另一个实例。</li><li>最后一个Serializer类型的“序列serializer”。序列化器用于在命令发送到网络之前序列化命令消息。</li></ul><p>SpringCloudCommandRouter和SpringHttpCommandBusConnector应该都被用于创建DistributedCommandsBus。在Spring Java 配置中，看起来如下:</p><pre>// Simple Spring Boot App providing the `DiscoveryClient` bean@EnableDiscoveryClient@SpringBootApplicationpublic class MyApplication {    public static void main(String[] args) {        SpringApplication.run(MyApplication.class, args);    }    // Example function providing a Spring Cloud Connector    @Bean    public CommandRouter springCloudCommandRouter(DiscoveryClient discoveryClient) {        return new SpringCloudCommandRouter(discoveryClient, new AnnotationRoutingStrategy());    }    @Bean    public CommandBusConnector springHttpCommandBusConnector(@Qualifier("localSegment") CommandBus localSegment,                                                             RestOperations restOperations,                                                             Serializer serializer) {        return new SpringHttpCommandBusConnector(localSegment, restOperations, serializer);    }    @Primary // to make sure this CommandBus implementation is used for autowiring    @Bean    public DistributedCommandBus springCloudDistributedCommandBus(CommandRouter commandRouter,                                                                   CommandBusConnector commandBusConnector) {        return new DistributedCommandBus(commandRouter, commandBusConnector);    }}// if you don't use Spring Boot Autoconfiguration, you will need to explicitly define the local segment:@Bean@Qualifier("localSegment")public CommandBus localSegment() {    return new SimpleCommandBus();}</pre><blockquote><p><b>注意</b><br>注意，并非所有的segment都必需具有相同类型的命令的命令处理器。你完全可以为不同的命令类型使用不同的segment。分布式命令总线总是选择一个节点分发命令到那个支持特定类型的命令。</p></blockquote><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/ccef9924f8d7" target="_blank" rel="noopener">https://www.jianshu.com/p/ccef9924f8d7</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JGroupsConnector&quot;&gt;&lt;a href=&quot;#JGroupsConnector&quot; class=&quot;headerlink&quot; title=&quot;JGroupsConnector&quot;&gt;&lt;/a&gt;JGroupsConnector&lt;/h2&gt;&lt;p&gt;JGroupsConnector使用(正如它的名字已经说明)JGroups作为底层发现和调度机制。描述JGroups的特性有太多的参考指南,请参阅JGroups用户指南以了解更多的细节。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework命令拦截器</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework%E5%91%BD%E4%BB%A4%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework命令拦截器/</id>
    <published>2018-08-31T02:29:32.000Z</published>
    <updated>2018-08-31T02:33:31.112Z</updated>
    
    <content type="html"><![CDATA[<p>使用命令总线的优点之一，是能够基于所有传入的命令采取相应的行动。例子是，不论哪种命令类型，你都希望去做日志记录或身份验证。这是使用拦截器来完成的。</p><a id="more"></a><p>有不同类型的拦截器：Dispatch拦截器和Handler拦截器。前者在命令被分发到命令处理程序之前被调用。在那时，它甚至不能确定该命令有任何处理器的存在。后者在命令处理程序被调用之前调用。</p><h2 id="Message-Dispatch-Interceptors（消息分发拦截器）"><a href="#Message-Dispatch-Interceptors（消息分发拦截器）" class="headerlink" title="Message Dispatch Interceptors（消息分发拦截器）"></a>Message Dispatch Interceptors（消息分发拦截器）</h2><p>当命令在命令总线上被分发时调用消息分发拦截器。例如，它们可以通过添加元数据来更改命令消息，或通过抛出异常来阻塞命令。这些拦截器总是在分发命令的线程上被调用。</p><p>##Structural validation（结构性验证）</p><p>如果它没有包含正确格式的所有必需的信息，那么处理命令是没有意义的,。事实上，一个命令缺乏信息应该尽可能早地被阻塞，甚至最好是任何事务开始之前。因此，拦截器应该检查所有传入命令的信息的可用性。这就是所谓的结构性验证。</p><p>Axon Framework支持基于JSR 303 Bean Validation的验证。这允许你用像@NotEmpty和@Pattern这样的注解，去注解命令上的字段。你需要在你的类路径中include一个JSR 303实现(比如Hibernate-Validator)。然后，在命令总线上配置一个BeanValidationInterceptor，它会自动找到并配置你的验证器实现。虽然它使用合理的默认值，但你可以根据具体需要调整它。</p><blockquote><p><b>提示</b><br>你想在一个无效的命令上使用尽可能少的资源。因此，该拦截器通常是位于拦截器链的最前端。在某些情况下，一个日志或审计拦截器可能需要放在前面，紧跟着它的是验证拦截器。</p></blockquote><p>BeanValidationInterceptor还实现了MessageHandlerInterceptor，也允许你把它配置为一个处理程序（Handler）拦截器。</p><h2 id="Message-Handler-Interceptors（消息处理程序拦截器）"><a href="#Message-Handler-Interceptors（消息处理程序拦截器）" class="headerlink" title="Message Handler Interceptors（消息处理程序拦截器）"></a>Message Handler Interceptors（消息处理程序拦截器）</h2><p>消息处理程序拦截器可以在命令处理之前和之后执行操作。拦截器甚至可以完全阻止命令处理，例如出于安全原因。</p><p>拦截器必须实现MessageHandlerInterceptor接口。该接口声明了一个方法handle，它需要三个参数：命令消息，当前的UnitOfWork和InterceptorChain。InterceptorChain用于继续分发处理。</p><p>与分发拦截器不同，处理程序拦截器在命令处理程序上下文中被调用。这意味着它们可以根据正在处理消息的工作单元附上相关数据。然后这个相关数据将被附加到在工作单元的上下文中被创建的消息。</p><p>处理程序拦截器也通常用于管理围绕命令处理的事务。这么做，注册一个TransactionManagingInterceptor，使用TransactionManager依次配置启动和提交(或回滚)实际事务。</p><h2 id="Distributing-the-Command-Bus-分布式命令总线"><a href="#Distributing-the-Command-Bus-分布式命令总线" class="headerlink" title="Distributing the Command Bus(分布式命令总线)"></a>Distributing the Command Bus(分布式命令总线)</h2><p>CommandBus的实现在早期声称只允许命令消息在单个JVM上分发。有时候，你想把不同JVM中的命令总线的多个实例作为一个。当返回任何结果时，在一个JVM命令总线上发出的命令应该无缝地传到到另一个JVM中的命令处理程序。</p><p>这就是DistributedCommandBus（分布式命令总线）的由来。不像其他CommandBus的实现，DistributedCommandBus不调用任何处理器。它的作用是在不同的JVM的命令总线实现之间形成一座“桥”。每个JVM上的DistributedCommandBus实例称为“Segment”。</p><img src="/2018/08/31/AxonFramework命令拦截器/distributed.png" title="distributed"><blockquote><p><b>注意</b><br>虽然分布式命令总线本身是Axon Framework核心模块的一部分，但它需要的组件，你可以在其中一个以axon-distributed-commandbus -开头的模块中找到。如果你使用Maven，确保你有适当的依赖集。groupId和version与核心模块相同。</p></blockquote><p>DistributedCommandBus依赖于两个组件：一个是CommandBusConnector，实现JVM的之间的通信协议；一个是CommandRouter，为每个传入的命令选择目的地。这个路由器定义分布式总线命令的segment应该given一个命令，根据路由键计算得到路由策略。两个具有相同路由键的命令将始终路由到相同的segment，只要segment数量和配置没有改变。一般来说，用目标聚合的标识符作为路由键。</p><p>提供两个RoutingStrategy的实现：MetaDataRoutingStrategy，它使用元数据属性在命令消息中查找路由键，而AnnotationRoutingStrategy，它使用注解在命令消息有效负载上的@TargetAggregateIdentifier来提取路由键。显然，你也可以提供自己的实现。</p><p>默认情况下，当命令消息没有键能被解析时，RoutingStrategy实现将抛出一个异常时。这种行为可以改变，通过在MetaDataRoutingStrategy或AnnotationRoutingStrategy的构造函数中提供一个UnresolvedRoutingKeyPolicy。有三个可能的策略:</p><ul><li>ERROR:这是默认值，当路由键不可用时，会抛出一个异常。</li><li>RANDOM_KEY：将返回一个随机值，当一个路由键不能从命令消息解析。这实际上意味着这些命令将被路由到命令总线的随机segment。</li><li>STATIC_KEY:将返回一个静态键(现有的“未被解析的”)为未被解析的路由键。这实际上意味着所有这些命令将被路由到相同的segment，只要segment的配置不改变。</li></ul><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/d603a00bc5cc" target="_blank" rel="noopener">https://www.jianshu.com/p/d603a00bc5cc</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用命令总线的优点之一，是能够基于所有传入的命令采取相应的行动。例子是，不论哪种命令类型，你都希望去做日志记录或身份验证。这是使用拦截器来完成的。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework命令总线</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework命令总线/</id>
    <published>2018-08-31T02:25:51.000Z</published>
    <updated>2018-08-31T02:28:19.047Z</updated>
    
    <content type="html"><![CDATA[<p>命令总线是将命令分发给各自的命令Handler的机制。每个命令总是被精确发送到一个命令Handler。如果没有可用的命令Handler为已分发的命令，将会抛出NoHandlerForCommandException异常。对同一命令类型订阅多个命令Handler将导致订阅互相取代。在这种情况下，最后一个订阅获胜。</p><a id="more"></a><h2 id="分发命令"><a href="#分发命令" class="headerlink" title="分发命令"></a>分发命令</h2><p>CommandBus提供了两个方法去分发命令到它们各自的Handler：dispatch(commandMessage,callback)和dispatch(commandMessage)。第一个参数是一个包含要发送的实际命令的消息。第二个可选的参数接收一个回调，允许在命令处理完成时通知分发组件。这个回调有两个方法:onSuccess()和onFailure()，分别会在命令处理返回后被调用，或者当它抛出一个异常时调用。</p><p>调用组件可能不采取在分发命令的同一线程中调用回调。如果调用线程在继续之前依赖于结果，你可以使用FutureCallback。这是一个Future(在java.concurrent包中定义)和Axon的CommandCallback的组合。或者，考虑使用命令网关。</p><p>如果一个应用程序不直接对命令的结果感兴趣，可以使用dispatch(commandMessage) 方法。</p><h2 id="SimpleCommandBus"><a href="#SimpleCommandBus" class="headerlink" title="SimpleCommandBus"></a>SimpleCommandBus</h2><p>SimpleCommandBus，顾名思义，最简单的实现。它在分发它们的线程中简单的处理命令。命令处理后，修改后的聚合在同一线程被保存和发布生成的事件。在大多数情况下，如web应用程序，该实现将符合你的需求。配置API中SimpleCommandBus是默认使用的实现。</p><p>像大多数CommandBus实现一样，SimpleCommandBus允许拦截器进行配置。在命令总线上分发一个命令后调用CommandDispatchInterceptors。在实际的命令handler 方法之前调用CommandHandlerInterceptors，允许你修改或阻塞命令。有关更多信息，请参考命令处理器拦截器。</p><p>因为所有命令处理都在同一线程中完成，这个实现仅限于JVM的边界。这个实现的性能是很好的，但不超凡。跨JVM边界，或使你的CPU cycles发挥最大的功效，看看其他CommandBus实现。</p><h2 id="AsynchronousCommandBus"><a href="#AsynchronousCommandBus" class="headerlink" title="AsynchronousCommandBus"></a>AsynchronousCommandBus</h2><p>顾名思义，AsynchronousCommandBus实现从分发它们的线程异步执行命令。它使用一个Executor在不同的线程来执行实际的处理逻辑。</p><p>默认情况下，AsynchronousCommandBus使用一个unbounded缓存的线程池。这意味着分发一个命令时会创建线程。完成处理命令的线程将被重新用于新命令。如果60秒线程没有处理命令，则会停止线程。</p><p>或者，Executor实例可以提供不同的线程策略配置。</p><p>注意，应用程序停止时应该关闭AsynchronousCommandBus，以确保任何等待线程正确关闭。关闭，调用shutdown()方法。这也将关闭任何Executor实例，如果它实现ExecutorService接口的话。</p><h2 id="DisruptorCommandBus"><a href="#DisruptorCommandBus" class="headerlink" title="DisruptorCommandBus"></a>DisruptorCommandBus</h2><p>SimpleCommandBus具有合理的性能特性，特别是当你经历了性能调优技巧。事实上，SimpleCommandBus需要锁来防止多个线程并发访问同一聚合，导致处理开销和锁争用。</p><p>DisruptorCommandBus采用不同的方法进行多线程处理。不是多个线程每个都执行同样的处理，而是有多个线程，每个负责一件处理。DisruptorCommandBus使用Disruptor，一个小的并发编程框架，通过不同的方法对多线程进行处理来实现更好的性能。任务不是在调用线程中进行处理，而是将任务移交给两组线程进行处理，每组线程负责一部分处理。第一组的线程将执行命令handler，更改一个聚合的状态。第二组将存储并将事件发布到事件存储。</p><p>虽然DisruptorCommandBus轻易优于SimpleCommandBus 4倍(!)，但有一些限制:</p><ul><li>DisruptorCommandBus仅支持事件溯源聚合。这个命令总线充当由Disruptor处理聚合的存储库。获取一个存储库的引用，使用createRepository(AggregateFactory)。</li><li>一个命令只能导致一个聚合实例状态变化。</li><li>当使用缓存时，它只允许给定的标识符为单个聚合。这意味着它是不可能有两个具有相同的标识符的不同类型的聚合。</li><li>命令一般不会引发需要回滚工作单元的故障。当发生回滚时，DisruptorCommandBus不能保证命令按照它们被分发的顺序进行处理。此外，它需要重试其他命令，从而造成不必要的计算。</li><li><p>在创建一个新的聚合实例时，命令更新所创建实例可能并不完全按照所提供的顺序进行。一旦创建了聚合，所有命令将按照它们被分发顺序执行。为了确保顺序，在创建命令上使用回调去等待正在创建的聚合。它不应该耗时超过几毫秒。<br>构建一个DisruptorCommandBus实例，你需要一个EventStore。该组件在Repositories and Event Stores中有解释。<br>或者，你可以提供一个DisruptorConfiguration实例，它允许你调整配置优化你的特定环境下的性能：</p></li><li><p>Buffer size:在ringBuffer上注册传入命令的槽数。更高的值可能会增加吞吐量,但也导致更高的延迟。必须是2的次方数，默认为4096。</p></li><li>ProducerType: 表示条目是由单线程或多线程生成的。默认为多线程。</li><li>WaitStrategy：当处理器线程（三个线程负责的实际处理）需要等待对方时使用的策略。最好的WaitStrategy取决于机器上可用的处理器数量，和正在运行的其他进程的数量。如果低延迟是至关重要的，DisruptorCommandBus可以自己认领内核，你可以使用BusySpinWaitStrategy。为了使命令总线索取更少的CPU并且允许其他线程处理，使用YieldingWaitStrategy。最后，你可以使用SleepingWaitStrategy和BlockingWaitStrategy允许其他进程共享CPU。如果命令总线不需要进行专职处理，则后者是合适的。默认为BlockingWaitStrategy。</li><li>Executor：设置Executor为DisruptorCommandBus提供线程。这个Executor必须能够提供至少4个线程。其中的3个线程，由DisruptorCommandBus的处理组件认领。额外的线程用于调用回调函数，并计划重试以防检测到错误的聚合状态。默认是CachedThreadPool提供线程从一个称为“DisruptorCommandBus”的线程组中。</li><li>TransactionManager：定义了事务管理器，应该确保存储和事件发布以事务的方式执行。</li><li>InvokerInterceptors:定义了在调用处理中使用的CommandHandlerInterceptors。这个处理调用实际的命令处理器方法。</li><li>PublisherInterceptors:定义了在发布处理中使用的CommandHandlerInterceptors。这个发布处理存储和发布生成的事件。</li><li>RollbackConfiguration:定义工作单元应该回滚的异常。默认配置为回滚未经检查的异常。</li><li>RescheduleCommandsOnCorruptState:指示已经执行过命令但损坏的聚合(如:因为一个工作单元是回滚)是否应该重新计划。如果为假，回调的onFailure()方法将被调用。如果为的(默认),命令将被重新计划。</li><li>CoolingDownPeriod:设置等待的秒数，以确保所有命令被处理。在冷却期间，不接受新命令，但是现有的命令仍然处理，并在必要时重新计划。冷却期间确保线程可供重新安排命令和调用回调之用。默认为1000(1秒)。</li><li>缓存:设置缓存存储从Event Store中恢复的聚合实例。缓存用disruptor存储不活跃的聚合实例。</li><li>InvokerThreadCount:给命令处理器的调用分配线程的数量。一个好的起始点是机器内核数量的一半。</li><li>PublisherThreadCount:用于发布事件的线程数量。一个好的起始点是一半的内核数量，如果IO上花费大量的时间，可以增加。</li><li>SerializerThreadCount:使用pre-serialize事件的线程数量。默认为1，但如果没有配置序列化器将被忽略。</li><li>Serializer:用于执行pre-serialization的序列化器。当配置序列化器时，DisruptorCommandBus将包装所有生成的事件在一个SerializationAware消息上。附加有效负载和元数据的序列化形式，在发布到事件存储之前。</li></ul><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/6aee33abd7f0" target="_blank" rel="noopener">https://www.jianshu.com/p/6aee33abd7f0</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;命令总线是将命令分发给各自的命令Handler的机制。每个命令总是被精确发送到一个命令Handler。如果没有可用的命令Handler为已分发的命令，将会抛出NoHandlerForCommandException异常。对同一命令类型订阅多个命令Handler将导致订阅互相取代。在这种情况下，最后一个订阅获胜。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-测试带注解的Saga</title>
    <link href="http://blog.weechang.xyz/2018/08/29/AxonFramework-%E6%B5%8B%E8%AF%95%E5%B8%A6%E6%B3%A8%E8%A7%A3%E7%9A%84Saga/"/>
    <id>http://blog.weechang.xyz/2018/08/29/AxonFramework-测试带注解的Saga/</id>
    <published>2018-08-29T03:30:56.000Z</published>
    <updated>2018-08-30T06:03:51.892Z</updated>
    
    <content type="html"><![CDATA[<p>与命令处理组件类似，saga有一个明确定义的接口：它们只对事件作出响应。另一方面，saga通常具有时间概念，并且可以作为事件处理过程的一部分与其他组件交互。Axon Framework的测试支持模块包含帮助你编写saga测试的固件。</p><a id="more"></a><p>每个测试固件包含三个阶段，类似于前面部分描述的命令处理组件固件。</p><ul><li>given 某些事件(从某些聚合),</li><li>when事件到达或时间流逝，</li><li>expect某些行为或状态。</li></ul><p>“given ”和“when”阶段都接受事件作为它们交互的一部分。在“given”阶段，可能会忽略所有副作用，如生成的命令。在“when”阶段，另一方面，从被记录和被验证的saga生成事件和命令。</p><pre>FixtureConfiguration fixture = new SagaTestFixture(InvoicingSaga.class);fixture.givenAggregate(invoiceId).published(new InvoiceCreatedEvent())        .whenTimeElapses(Duration.ofDays(31))        .expectDispatchedCommandsMatching(Matchers.listWithAllOf(aMarkAsOverdueCommand()));        // or, to match against the payload of a Command Message only        .expectDispatchedCommandsMatching(Matchers.payloadsMatching(Matchers.listWithAllOf(aMarkAsOverdueCommand())));</pre><p>saga可以分发命令使用一个回调函数通知命令处理的结果。由于在测试中没有实际的命令处理完成，该行为使用CallbackBehavior对象定义。这个对象使用setCallbackBehavior()在固件上注册，并定义当一个命令被分发后，是否和如何必须调用回调函数。</p><p>不是直接使用CommandBus，而是你还可以使用命令网关。见下文如何规定他们的行为。</p><p>通常，saga将与资源交互。这些资源不是saga状态的一部分，但在saga加载和创建后被注入。测试固件允许你注册需要被注入到saga中的资源。要注册一个资源，只需用资源作为参数调用fixture.registerResource(Object)方法。固件将在saga上检测合适的setter方法或字段(带有@Inject注解)并用一个可用的资源调用它。</p><blockquote><p><b>提示</b><br>注入模拟对象(例如Mockito或Easymock)到你的saga，可能是非常有益的。它允许你验证saga与外部资源的正确交互。</p></blockquote><p>命令网关为saga提供了一个更简单的方式来调度命令。使用自定义命令网关还可以更容易地创建模拟或桩来定义其在测试中的行为。然而，当提供一个模拟或桩时，实际的命令可能不不会被分发，因此无法验证测试固件中发送的命令。</p><p>因此，固件提供了两个方法，让你注册命令网关和一个可选的模拟定义其行为:registerCommandGateway(Class)和registerCommandGateway(Class, Object)。这两种方法都返回一个given类的实例，表示要使用的网关。这个实例也注册为资源，使它具有资源注入的资格。</p><p>当registerCommandGateway(Class)用来注册一个网关时，它分发命令到由固件管理的CommandBus。网关的行为主要是通过CallbackBehavior定义于固件。如果没有提供明确的CallbackBehavior，回调不调用，从而无法为网关提供任何返回值。</p><p>当registerCommandGateway(Class, Object)是用来注册一个网关，第二个参数是用于定义网关的行为。</p><p>测试固件试图尽可能消除系统时间迁延。这意味着它将会在测试执行时显得没有时间迁延。除非你显式地声明使用whenTimeElapses()。所有事件都将拥有测试固件创建那一刻的时间戳。</p><p>在测试期间暂停时间，可以更容易地预测在什么时间计划发布事件。如果你的测试用例验证一个事件在30秒后计划发布，它将保持30秒，而不管实际调度和测试执行之间的时间。</p><blockquote><p><b>注意</b><br>固件使用StubScheduler作为基于时间的活动，如调度事件和推进时间。固件将发送到saga实例的任何事件的时间戳设置为这个scheduler的时间。这意味着一旦固件开始，时间就“stopped”，并可能提前确定使用whenTimeAdvanceTo和whenTimeElapses方法。</p></blockquote><p>你还可以使用与测试固件无关的StubEventScheduler，如果你需要测试事件的调度。这个EventScheduler实现允许你验证哪个事件被安排在哪个时间，并且给你选择操纵时间的进展。你可以将时间提前到一个特定的时间，将时钟移动到一个特定的日期和时间，或者将时间提前到下一个计划的事件。所有这些操作将返回进度间隔内计划的事件。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/49429788e7da" target="_blank" rel="noopener">https://www.jianshu.com/p/49429788e7da</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与命令处理组件类似，saga有一个明确定义的接口：它们只对事件作出响应。另一方面，saga通常具有时间概念，并且可以作为事件处理过程的一部分与其他组件交互。Axon Framework的测试支持模块包含帮助你编写saga测试的固件。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework测试</title>
    <link href="http://blog.weechang.xyz/2018/08/29/AxonFramework%E6%B5%8B%E8%AF%95/"/>
    <id>http://blog.weechang.xyz/2018/08/29/AxonFramework测试/</id>
    <published>2018-08-29T02:30:35.000Z</published>
    <updated>2018-08-31T02:06:51.619Z</updated>
    
    <content type="html"><![CDATA[<p>CQRS最大的好处之一，尤其是事件溯源就事件和命令而言，单纯地表达测试是可能的。这两个功能组件，事件和命令对领域专家或业务所有者都有明确的含义。这不仅意味着测试表达就事件和命令而言有明确的功能含义，这也意味着他们不依靠任何实现选择。</p><a id="more"></a><p>本章描述的特性需要axon-test模块,可通过配置maven依赖(使用<artifactid>axon-test</artifactid> 和<scope>test&lt;/scope)或通过完整包下载。</scope></p><p>本章中描述的固件可用于任何测试框架，如JUnit和TestNG。</p><h2 id="命令组件测试"><a href="#命令组件测试" class="headerlink" title="命令组件测试"></a>命令组件测试</h2><p>在任何CQRS基础架构中命令处理组件通常是最复杂的。比其他组件更复杂，这也意味着该组件有额外的与测试相关的需求。</p><p>虽然更复杂，但是命令的API处理组件相当容易。它有一个命令进来，然后事件出去。在某些情况下，可能有一个查询作为命令执行的一部分。除此之外，命令和事件是API的唯一部分。这意味着可以在事件和命令的基础上完整地定义测试场景。典型地，以：</p><ul><li>given过去的某些事件，</li><li>when 执行这个命令，</li><li>expect 这些事件将被发布和/或存储</li></ul><p>Axon Framework提供了一个测试固件，使你能够做到这一点。AggregateTestFixture允许你配置某些基础设施，包括必要的命令处理器和存储库，并以given-when-then形式的事件和命令来表达你的场景。</p><p>下面的示例展示了用JUnit 4对given-when-then测试固件的使用：</p><pre>public class MyCommandComponentTest { private FixtureConfiguration fixture; @Before public void setUp() {     fixture = new AggregateTestFixture(MyAggregate.class); } @Test public void testFirstFixture() {     fixture.given(new MyEvent(1))            .when(new TestCommand())            .expectSuccessfulHandlerExecution()            .expectEvents(new MyEvent(2));     /*     These four lines define the actual scenario and its expected     result. The first line defines the events that happened in the     past. These events define the state of the aggregate under test.     In practical terms, these are the events that the event store     returns when an aggregate is loaded. The second line defines the     command that we wish to execute against our system. Finally, we     have two more methods that define expected behavior. In the     example, we use the recommended void return type. The last method     defines that we expect a single event as result of the command     execution.     /* }}</pre><p>given-when-then测试固件定义了三个阶段：配置、执行和验证。每个阶段由不同的接口表示：分别是，FixtureConfiguration, TestExecutor 和 ResultValidator。固件类的静态newGivenWhenThenFixture()方法提供了对第一个的引用，进而可能提供验证，等等。</p><blockquote><p><b>注意</b><br>为了最好地利用这些阶段之间的迁移，最好使用这些方法提供的流式接口，如上面的示例所示。</p></blockquote><p>在配置阶段（即在提供第一个“given”之前），你提供了执行测试所需的构件。作为固件的一部分提供事件总线、命令总线和事件存储的专用版本。有accessor方法来获得对它们的引用。任何命令处理器不直接在聚合上注册，需要显式地使用registerAnnotatedCommandHandler 方法配置。除了带注解的命令处理器外，你还可以配置各种组件和设置，定义应该如何设置测试周围的基础设施。</p><p>一旦固件配置好，你就可以定义“given”事件。测试固件将用DomainEventMessage包装这些事件。如果“given”事件实现消息，消息的有效负载和元数据将被纳入DomainEventMessage，否则given事件作为有效负载。DomainEventMessage 的序列号顺序，从0开始。</p><p>或者，你也可以为“given”场景提供命令。在这种情况下，在执行实际的测试命令时，这些命令生成的事件将被用于事件源聚合。使用“givenCommands(…)”方法提供命令对象。</p><p>执行阶段允许你提供一个针对命令处理组件执行的命令。对调用处理程序的行为(无论是在聚合或外部处理程序)进行监控，并与在验证阶段注册的预期进行比较。</p><blockquote><p><b>注意</b><br>在执行测试过程中，Axon试图检测测试中的所有在聚合上的非法状态的更改。它通过将聚合的状态与命令执行后的聚合状态进行比较，如果它从所有“given”和存储的事件溯源。如果状态不相同，这意味着状态变化发生在聚合事件处理器方法之外。比较时将忽略静态和瞬态字段，因为它们通常包含对资源的引用。<br>可以使用setReportIllegalStateChange方法在固件的配置中切换检测。</p></blockquote><p>最后一个阶段是验证阶段，允许你检查命令处理组件的活动。这完全是根据返回值和事件来完成的。</p><p>测试固件允许你验证命令处理程序的返回值。你可以显式地定义预期的返回值，或者简单地要求成功返回该方法。你也可以表达任何你期望的CommandHandler抛出的异常。</p><p>另一个组件是对已发布事件的验证。有两种匹配预期事件的方法。</p><p>第一是通过事件实例，它需要与实际的事件是行逐字的比较。将预期事件的所有属性与实际事件中的对应对象进行比较（使用equals()）。如果其中一个属性不相等，则测试失败，并生成一个广泛的错误报告。</p><p>表达期望的另一种方式是使用的匹配器(Hamcrest库提供的)。匹配器接口规定了两个方法matches(Object)和describeTo(Description)。第一个返回一个布尔值，指示是否匹配或不匹配。第二个让你表达你的期望。例如，一个“GreaterThanTwoMatcher”可以添加“任何值大于2的事件“的描述。描述允许创建关于测试用例失败的错误消息。</p><p>创建事件列表的匹配器可能是繁琐和容易出错的工作。为了简化问题，Axon提供了一组匹配器允许你提供一组特定于事件的匹配器，并告诉Axon应该如何匹配列表。</p><p>下面是可用的事件列表匹配器和他们的目的的概述：</p><ul><li><p>List with all of: Matchers.listWithAllOf(event matchers…)<br>如果所有的事件匹配器与真实事件列表中至少一个事件匹配，该匹配器将成功。不管是否有多个匹配器匹配相同的事件，或如果列表中一个事件不匹配任何匹配器。</p></li><li><p>List with any of: Matchers.listWithAnyOf(event matchers…)<br>如果一个或多个事件匹配器与实际的事件列表中一个或多个事件匹配，该匹配器将成功。一些匹配器甚至一个也不匹配，而另一个匹配多个。</p></li><li><p>Sequence of Events: Matchers.sequenceOf(event matchers…)<br>使用此匹配器来验证实际事件匹配器和提供的事件匹配器有相同的顺序。如果匹配器与后一个事件相匹配，与前一个匹配器匹配的事件相匹配，该匹配器将成功。这意味着可能出现不匹配事件的“gaps”。<br>如果评估事件之后，更多的匹配器是可用的，他们都是匹配“null”。它是由事件的匹配器来决定是否接受。</p></li><li><p>Exact sequence of Events: Matchers.exactSequenceOf(event matchers…)<br>“事件的序列”匹配器的变化不允许不匹配事件的空隙。这意味着每个匹配器必须与事件后面的事件相匹配，与前一个匹配器匹配的事件相匹配。每个匹配器都应该与它前一个匹配器相对应的事件的后续一个事件相匹配</p></li></ul><p>为了方便起见,提供了一些普遍需要的事件匹配器。他们与单个事件实例相匹配:</p><ul><li><p>Equal Event: Matchers.equalTo(instance…)<br>验证given对象在语义上等于given事件，这个匹配器将比较实际和预期的对象的所有字段的值使用一个null-safe相等方法。这意味着可以比较事件，即使它们不实现equals方法。存储在given参数字段上的对象用equals进行比较，要求他们正确实现。</p></li><li><p>No More Events: Matchers.andNoMore() or Matchers.nothing()<br>仅与空值匹配，这个匹配器可以作为最后一个匹配器添加到事件的准确顺序匹配器,以确保没有不匹配的事件依然存在。</p></li></ul><p>由于匹配器传递一个事件消息列表，有时你只是想验证消息的有效负载。有匹配器来帮助你:</p><ul><li><p>Payload Matching: Matchers.messageWithPayload(payload matcher)<br>验证消息的有效负载匹配给定的有效载荷匹配器。</p></li><li><p>Payloads Matching: Matchers.payloadsMatching(list matcher)<br>验证消息的有效负载匹配给定的有效载荷匹配器。给定的匹配器必须匹配列表包含的每个消息的有效负载。有效负载匹配匹配器通常用作外匹配器,以防止重复有效负载匹配器。</p></li></ul><p>下面是一个简单的代码示例，以显示这些匹配器的使用。在这个例子中,我们预期共有两个事件发布。第一个事件必须是一个“ThirdEvent”，第二个是“aFourthEventWithSomeSpecialThings”。可能没有第三个事件，因为那样”andNoMore”匹配器会失败。</p><pre>fixture.given(new FirstEvent(), new SecondEvent())       .when(new DoSomethingCommand("aggregateId"))       .expectEventsMatching(exactSequenceOf(           // we can match against the payload only:           messageWithPayload(equalTo(new ThirdEvent())),           // this will match against a Message           aFourthEventWithSomeSpecialThings(),           // this will ensure that there are no more events           andNoMore()       ));// or if we prefer to match on payloads only:       .expectEventsMatching(payloadsMatching(               exactSequenceOf(                   // we only have payloads, so we can equalTo directly                   equalTo(new ThirdEvent()),                   // now, this matcher matches against the payload too                   aFourthEventWithSomeSpecialThings(),                   // this still requires that there is no more events                   andNoMore()               )       ));</pre><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/2e893c9d48bf" target="_blank" rel="noopener">https://www.jianshu.com/p/2e893c9d48bf</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CQRS最大的好处之一，尤其是事件溯源就事件和命令而言，单纯地表达测试是可能的。这两个功能组件，事件和命令对领域专家或业务所有者都有明确的含义。这不仅意味着测试表达就事件和命令而言有明确的功能含义，这也意味着他们不依靠任何实现选择。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-Saga的基础设施</title>
    <link href="http://blog.weechang.xyz/2018/08/29/AxonFramework-Saga%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    <id>http://blog.weechang.xyz/2018/08/29/AxonFramework-Saga的基础设施/</id>
    <published>2018-08-29T02:17:20.000Z</published>
    <updated>2018-08-30T06:03:51.760Z</updated>
    
    <content type="html"><![CDATA[<p>事件需要被重定向到适当的saga实例。为此,一些基础设施类是必需的。最重要的组件是SagaManager和SagaRepository。</p><a id="more"></a><h2 id="Saga-Manager"><a href="#Saga-Manager" class="headerlink" title="Saga Manager"></a>Saga Manager</h2><p>与处理事件的任何组件一样，processing也是由事件处理器完成的。然而，因为saga不是单例实例处理事件，但是有独特的生命周期，它们需要管理。</p><p>Axon通过AnnotatedSagaManager来支持生命周期管理，这是提供给一个事件Processor来执行处理器的实际的调用。它的初始化使用saga的类型来管理，也使用可以存储和恢复的SagaRepository这种saga类型。一个AnnotatedSagaManager只能管理一个saga类型。</p><p>当使用配置API时，Axon将对大多数组件使用合理的默认设置。不管怎样，强烈建议定义一个SagaStore的实现使用。SagaStore是在某处物理存储saga实例的机制，AnnotatedSagaRepository(默认)要求它们使用SagaStore去存储和检索saga实例。</p><pre>Configurer configurer = DefaultConfigurer.defaultConfiguration();configurer.registerModule(        SagaConfiguration.subscribingSagaManager(MySagaType.class)                         // Axon defaults to an in-memory SagaStore, defining another is recommended                         .configureSagaStore(c -> new JpaSagaStore(...)));// alternatively, it is possible to register a single SagaStore for all Saga types:configurer.registerComponent(SagaStore.class, c -> new JpaSagaStore(...));</pre><h2 id="saga存储库和saga存储"><a href="#saga存储库和saga存储" class="headerlink" title="saga存储库和saga存储"></a>saga存储库和saga存储</h2><p>SagaRepository负责存储和检索saga，使用SagaManager。它能够通过标识符和关联值检索特定的saga实例。然而，有一些特殊的要求。因为在saga中的并发处理是一个非常微妙的过程，存储库必须确保每个概念的saga实例（具有相同的标识符）只有一个实例存在于JVM。</p><p>Axon提供了 AnnotatedSagaRepository 实现，允许saga实例的查找，同时保证在同一时间只有一个saga实例被访问。它使用一个SagaStore执行saga实例实际的持久化。</p><p>实现的选择主要取决于应用程序使用的存储引擎。Axon提供了JdbcSagaStore、InMemorySagaStore JpaSagaStore 和MongoSagaStore。</p><p>在某些情况下,应用程序受益于缓存Saga实例。在这种情况下，有一个CachingSagaStore包装另一个实现添加缓存行为。<br>请注意，CachingSagaStore 是一 个write-through 缓存，这意味着保存操作总是立即转发到后备存储器，以确保数据安全。</p><h2 id="JpaSagaStore"><a href="#JpaSagaStore" class="headerlink" title="JpaSagaStore"></a>JpaSagaStore</h2><p>JpaSagaStore使用JPA来存储状态和关联saga的值。saga本身并不需要任何JPA注解；Axon将使用序列化器序列化saga(类似于事件序列化，你可以使用JavaSerializer或XStreamSerializer)。</p><p>JpaSagaStore通过EntityManagerProvider来配置,它提供对EntityManager实例的访问。这种抽象允许使用应用程序管理和容器管理EntityManagers。根据情况,你可以定义序列化器去序列化saga实例。Axon默认为XStreamSerializer。</p><h2 id="JdbcSagaStore"><a href="#JdbcSagaStore" class="headerlink" title="JdbcSagaStore"></a>JdbcSagaStore</h2><p>JdbcSagaStore使用原来的JDBC存储saga实例及其关联值。类似于JpaSagaStore，saga实例不需要知道他们是如何存储的。序列化使用序列化器。</p><p>用DataSource 或ConnectionProvider初始化JdbcSagaStore 。虽然不是必需的，用ConnectionProvider初始化时，建议在UnitOfWorkAwareConnectionProviderWrapper包装实现。它将检查已经打开的数据库连接的当前工作单元，以确保工作单元中的所有活动都是在单个连接上完成的。</p><p>不像JPA，JdbcSagaRepository使用普通的SQL语句，存储和检索信息。这可能意味着某些操作依赖于数据库特有的SQL方言。情况也可能是这样，某些数据库供应商提供了你希望使用的非标准特性。允许这个，你可以提供自己的SagaSqlSchema。SagaSqlSchema接口定义的存储库的所有操作要在底层数据库上执行。它允许你定制为它们执行的SQL语句。默认是GenericSagaSqlSchema。其他可用的实现是PostgresSagaSqlSchema,Oracle11SagaSqlSchema 和HsqlSagaSchema。</p><h2 id="MongoSagaStore"><a href="#MongoSagaStore" class="headerlink" title="MongoSagaStore"></a>MongoSagaStore</h2><p>MongoSagaStore存储saga实例和它们的关联到MongoDB数据库中。MongoSagaStore存储在单个集合中的所有saga到MongoDB数据库中。每个saga实例创建一个文档。</p><p>MongoSagaStore还确保在任何时候，在单个JVM中任何唯一的saga只有一个saga实例存在。这样可以确保不因并发问题而丢失任何状态更改。</p><p>使用MongoTemplate和一个可选的序列化器初始化MongoSagaStore。MongoTemplate提供了一个对集合的引用存储Sagas。Axon 提供了DefaultMongoTemplate，DefaultMongoTemplate获取MongoClient实例，还获取数据库名称和集合的名称存储Sagas。数据库名称和集合的名称可以省略。在这种情况下，他们分别默认为“axonframework”和“sagas”。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>如果使用一个支持的saga存储的数据库，保存和加载Saga 实例可能是相对昂贵的操作。特别是在很短的时间段内多次调用同一个saga实例的情况下，缓存对应用程序的性能是有利的。</p><p>Axon 提供了CachingSagaStore实现。这个SagaStore包装实际的存储。加载saga或关联值时，CachingSagaStore将首先查阅其缓存，优于委托给包装的存储库。当存储信息时，所有调用总是被委托，以确保后备存储器总是有一个与saga的状态一致的视图。</p><p>配置缓存,简单包装任何SagaStore到CachingSagaStore中。CachingSagaStore的构造函数接受三个参数:分别是，包装的存储库、用于关联值的缓存和saga的实例。后两个参数可以引用相同或不同的缓存。这取决于你的具体的程序的逐出需求。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/57bd121412fa" target="_blank" rel="noopener">https://www.jianshu.com/p/57bd121412fa</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件需要被重定向到适当的saga实例。为此,一些基础设施类是必需的。最重要的组件是SagaManager和SagaRepository。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework跟踪最后期限</title>
    <link href="http://blog.weechang.xyz/2018/08/29/AxonFramework%E8%B7%9F%E8%B8%AA%E6%9C%80%E5%90%8E%E6%9C%9F%E9%99%90/"/>
    <id>http://blog.weechang.xyz/2018/08/29/AxonFramework跟踪最后期限/</id>
    <published>2018-08-29T02:11:46.000Z</published>
    <updated>2018-08-30T06:03:51.733Z</updated>
    
    <content type="html"><![CDATA[<p>当有事发生时，很容易使一个saga采取行动。毕竟，有一个事件要通知saga。但是如果你想让你的saga，在什么事情都没发生的情况下做些什么呢？这就是最后期限。在发票中，通常是几周，而信用卡支付的确认可能在几秒钟内。</p><a id="more"></a><p>在Axon中，你可以使用一个EventScheduler计划发布一个事件。在发票的例子中，你希望发票在30内付清。saga将在发送CreateInvoiceCommand后，安排一个InvoicePaymentDeadlineExpiredEvent在30天后发布。计划一个事件后EventScheduler返回ScheduleToken。这个令牌可以用来取消计划，例如已收到发票的付款。</p><p>Axon提供了两种EventScheduler实现:一个纯Java和一个使用Quartz 2作为调度机制支持。</p><p>这个纯java实现的EventScheduler使用ScheduledExecutorService去计划事件发布。虽然这个计划器的定时非常可靠，但它是一个纯内存实现。一旦JVM关闭，所有的计划都将丢失。这使得这种实现不适合长期限的计划。</p><p>SimpleEventScheduler 需要配置一个EventBus和一个SchedulingExecutorService（看java.util.concurrent.Executors类的静态方法的helper方法）。</p><p>QuartzEventScheduler是一个更可靠，企业信得过的实现。使用Quartz 作为底层调度机制，它提供了更强大的功能，如持久性、集群和失败的管理。这意味着事件发布将被保证。可能会晚一点，但会发布。</p><p>需要配置一个Quartz调度器和EventBus。另外，你可以设置以组的名称进行计划，默认为”AxonFramework-Events”</p><p>一个或多个组件将监听计划的事件。这些组件可能依赖于绑定到调用它们的线程的事务。计划的事件由EventScheduler管理的线程发布。管理事务在这些线程上，你可以配置一个TransactionManager或UnitOfWorkFactory创建一个事务绑定工作单元。</p><blockquote><p><b>注意</b><br>Spring用户可以使用quartzeventschedulerfactorybean或simpleeventschedulerfactorybean进行更简单的配置。它允许你直接设置PlatformTransactionManager。</p></blockquote><h2 id="注入资源"><a href="#注入资源" class="headerlink" title="注入资源"></a>注入资源</h2><p>saga一般做的不仅仅是维护基于事件的状态。它们与外部的组件进行交互。要做到这一点，他们需要访问处理组件所需的资源。通常，这些资源实际上并不是saga状态的一部分，也不应该持久化。但是，一旦重新构建一个saga，在事件被路由到该实例之前，必须注入这些资源。</p><p>为了这个目的有了ResourceInjector。它使用SagaRepository将资源注入到一个saga。Axon提供了SpringResourceInjector用应用程序上下文中的资源注入带注解的字段和方法，和一个SimpleResourceInjector，注册已经注册的资源到用@Inject注解的方法和字段。</p><blockquote><p><b>提示</b><br>由于资源与saga不应该被持久化，所以务必向这些字段添加临时关键字。这将防止序列化机制尝试将这些字段的内容写入存储库。存储库将在saga被反序列化之后自动重新注入所需的资源。</p></blockquote><p>Simpleresourceinjector允许一个预先指定的资源集合被注射。它扫描saga的(setter)方法和字段，以找到被@Inject注解的那个。</p><p>当使用配置API，Axon将默认为the ConfigurationResourceInjector。它将注入配置中可用的任何资源。组件像EventBus、EventStore CommandBus和CommandGateway默认情况下是可用的,但你也可以使用configurer.registerComponent()注册自己的组件。</p><p>Springresourceinjector使用Spring的依赖注入机制注入资源聚合。这意味着，如果需要，可以使用setter注入或直接字段注入。要注入的方法或字段需要注解，以便Spring识别它为依赖项。例如@Autowired。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/02e3636fc735" target="_blank" rel="noopener">https://www.jianshu.com/p/02e3636fc735</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当有事发生时，很容易使一个saga采取行动。毕竟，有一个事件要通知saga。但是如果你想让你的saga，在什么事情都没发生的情况下做些什么呢？这就是最后期限。在发票中，通常是几周，而信用卡支付的确认可能在几秒钟内。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework事件处理</title>
    <link href="http://blog.weechang.xyz/2018/08/27/AxonFramework%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://blog.weechang.xyz/2018/08/27/AxonFramework事件处理/</id>
    <published>2018-08-27T06:47:54.000Z</published>
    <updated>2018-08-30T06:03:51.802Z</updated>
    
    <content type="html"><![CDATA[<p>saga中的事件处理非常接近一个普通的事件监听器。上述的对于方法和参数解析的规则在这里是有效的。不过,有一个主要区别。虽然存在事件监听器只有单个实例处理所有传入事件，但也存在一个saga有多个实例，每个实例都对不同的事件感兴趣。例如,关于Order的id为1的管理业务Saga对Order“2”的事件不感兴趣，反之亦然。</p><a id="more"></a><p>Axon不会将所有事件都发布给所有saga实例（这将是对资源的完全浪费），而是只发布与saga相关联的属性的事件。这个通过使用AssociationValues完成。一个AssociationValue由key和value组成。key代表标识符使用的类型，例如“orderId”或“order”。value表示前面例子中相应“1”或“2”值。</p><p>带@SagaEventHandler注解的方法被评估的顺序与带@EventHandler的相同。如果处理器方法的参数与传入的事件匹配，那么方法就匹配，如果saga有一个定义在处理器方法上的association属性。</p><p>@SagaEventHandler注解有两个attribute,其中associationProperty是最重要的。这是传入事件上property的名称，应该用来寻找相关的saga。association值的key是property的名称。这个值是由property的getter方法返回的值。</p><p>例如,考虑一个带”String getOrderId()”方法传入事件,返回“123”。如果一个带@SagaEventHandler(associationProperty = orderId)注解的方法接受这个事件,这个事件被路由到所有已经与带一个键为orderId和值为“123”的AssociationValues关联的saga。这可能是一个,多个,甚至没有。</p><p>有时,想要关联的属性的名称不是想要使用的关联的名称。例如,你有一个销售订单相匹配购买订单的saga。你可以有一个包含“buyOrderId”和“sellOrderId”的事务对象。如果你想要的saga将“orderId”作为关联的值，你可以定义一个不同的keyName 在@SagaEventHandler注解中。它将变成@SagaEventHandler(associationProperty=”sellOrderId”, keyName=”orderId”)。</p><h2 id="管理关联"><a href="#管理关联" class="headerlink" title="管理关联"></a>管理关联</h2><p>当一个saga事务管理跨多个域的概念，如订单、发货,、发票，等等，saga需要与这些概念的实例关联。一个关联需要两个参数：key，识别关联的类型(订单、发货等)和一个value，该值表示该概念的标识符。<br>在以下几个方面完成用概念关联到saga。第一，当新创建一个saga时将调用一个用@StartSaga注解的事件处理器时，它将自动与@SagaEventHandler方法中标识的关联。所有其他的关联用SagaLifecycle.associateWith(String key, String/Number value)方法创建。用SagaLifecycle.removeAssociationWith(String key, String/Number value)方法去移除一个特定的关联。</p><p>想象一下为一个围绕着订单的事务而已经被创建的一个saga。saga自动关联订单，方法被@StartSaga注解。saga是负责创建该订单的发票，并告诉航运创建一个载货量。一旦货物到达和发票支付,交易完成后,saga被关闭。<br>这是一个saga的代码：</p><p><pre><br>public class OrderManagementSaga {<br>    private boolean paid = false;<br>    private boolean delivered = false;<br>    @Inject<br>    private transient CommandGateway commandGateway;<br>    @StartSaga<br>    @SagaEventHandler(associationProperty = “orderId”)<br>    public void handle(OrderCreatedEvent event) {<br>        // client generated identifiers<br>        ShippingId shipmentId = createShipmentId();<br>        InvoiceId invoiceId = createInvoiceId();<br>        // associate the Saga with these values, before sending the commands<br>        associateWith(“shipmentId”, shipmentId);<br>        associateWith(“invoiceId”, invoiceId);<br>        // send the commands<br>        commandGateway.send(new PrepareShippingCommand(…));<br>        commandGateway.send(new CreateInvoiceCommand(…));<br>    }<br>    @SagaEventHandler(associationProperty = “shipmentId”)<br>    public void handle(ShippingArrivedEvent event) {<br>        delivered = true;<br>        if (paid) { end(); }<br>    }<br>    @SagaEventHandler(associationProperty = “invoiceId”)<br>    public void handle(InvoicePaidEvent event) {<br>        paid = true;<br>        if (delivered) { end(); }<br>    }<br>    // …<br>}<br></pre><br>通过允许客户端生成标识符，可以很容易地与一个概念相关联，而不需要请求响应类型命令。在发布命令之前，我们将事件与这些概念关联起来。通过这种方式，我们也保证捕捉到作为该命令的一部分生成的事件。一旦发票付清，货物到达，saga也将结束。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/297622466ca9" target="_blank" rel="noopener">https://www.jianshu.com/p/297622466ca9</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;saga中的事件处理非常接近一个普通的事件监听器。上述的对于方法和参数解析的规则在这里是有效的。不过,有一个主要区别。虽然存在事件监听器只有单个实例处理所有传入事件，但也存在一个saga有多个实例，每个实例都对不同的事件感兴趣。例如,关于Order的id为1的管理业务Saga对Order“2”的事件不感兴趣，反之亦然。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework管理复杂的业务事务</title>
    <link href="http://blog.weechang.xyz/2018/08/27/AxonFramework%E7%AE%A1%E7%90%86%E5%A4%8D%E6%9D%82%E7%9A%84%E4%B8%9A%E5%8A%A1%E4%BA%8B%E5%8A%A1/"/>
    <id>http://blog.weechang.xyz/2018/08/27/AxonFramework管理复杂的业务事务/</id>
    <published>2018-08-27T06:43:56.000Z</published>
    <updated>2018-08-30T06:03:51.685Z</updated>
    
    <content type="html"><![CDATA[<p>并不是每个命令都能够在一个ACID事务中完全执行。现金转账事务是一个很常见频繁出现的例子，用来作为论据。通常认为，把钱从一个账户转移到另一个账户，绝对需要原子性和一致性。其实并非如此，相反，这是完全不可能的。如果钱从A银行的帐户转移到B银行的帐户怎么办？A银行要获得B银行数据库的锁吗？如果转账正在进行的时候，A银行已经扣除了金额,但B银行并没收到它，这不是很奇怪吗?事实上不是，这是“正在进行”。另一方面,如果在向B银行的帐户中存资金时出现错误，A银行的客户就想要他的钱回退。所以我们需要某种形式的最终一致性。</p><a id="more"></a><p>虽然ACID事务在某些情况下不是必需的甚至是不可能的，但仍然需要某种形式的事务管理。通常，这些事务称为BASE事务：基本的可用性，软性状态，最终一致性。 与ACID相反，BASE事务无法轻松回滚。 要回滚，需要采取补偿措施来恢复作为事务一部分发生的任何事情。 在汇款的例子中，如果没有把钱存入B银行，将把钱退还给A银行。<br>在CQRS中，Sagas可用于管理这些BASE事务。 他们对事件做出响应，并可能调度命令，调用外部应用程序等。在领域驱动设计的上下文中，将Sagas用作多个限界上下文之间的协调机制并不罕见。</p><h2 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h2><p>一个saga是一种特殊类型的事件监听器：用来管理业务事务。一些事务可能运行数天甚至数周，而另一些则在几毫秒内完成。在Axon中，saga的每个实例负责管理一个业务事务。这意味着saga维护状态必须管理事务，持续或采取补偿动作回滚已经被采取任何动作。通常情况下，与常规的事件监听器相反，saga有一个起点和终点，都由事件触发。虽然saga的起点通常是非常明确的，但可能有多种方式结束一个saga。</p><p>在Axon中,Sagas是定义了一个或多个@SagaEventHandler方法的类。与常规事件处理器不同，在任何时间可能存在多个saga的实例。Saga由一个Processor管理(跟踪或订阅)，Processor通过事件致力于处理特定saga类型。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>一个单独的saga实例负责管理一个单独的事务。这意味着你需要能够标示一个saga生命周期的开始和结束。</p><p>在一个saga中，事件处理器用@SagaEventHandler注解。如果一个特定的事件标志着开始一个事务，在同一个方法上添加另一个注解:@StartSaga。这个注解将创建一个新的saga，并且当匹配事件后布后调用它的事件处理器方法。</p><p>默认情况下,只有在找不到匹配的saga时才能开启一个新的saga。你也可以强行创建一个新的saga实例，通过把@StartSaga注解上的forceNew属性设置为true。</p><p>结束一个saga可以以两种方式完成。如果一个特定的事件总是标示saga生命周期的结束，在saga上用@EndSaga注解事件的处理器。在调用处理器后，saga的生命周期将结束。作为一种选择,你可以调用end()从saga内部去结束生命周期。这允许你有条件地结束saga。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/9c8d7fb623a0" target="_blank" rel="noopener">https://www.jianshu.com/p/9c8d7fb623a0</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并不是每个命令都能够在一个ACID事务中完全执行。现金转账事务是一个很常见频繁出现的例子，用来作为论据。通常认为，把钱从一个账户转移到另一个账户，绝对需要原子性和一致性。其实并非如此，相反，这是完全不可能的。如果钱从A银行的帐户转移到B银行的帐户怎么办？A银行要获得B银行数据库的锁吗？如果转账正在进行的时候，A银行已经扣除了金额,但B银行并没收到它，这不是很奇怪吗?事实上不是，这是“正在进行”。另一方面,如果在向B银行的帐户中存资金时出现错误，A银行的客户就想要他的钱回退。所以我们需要某种形式的最终一致性。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework在聚合中处理命令</title>
    <link href="http://blog.weechang.xyz/2018/08/27/AxonFramework%E5%9C%A8%E8%81%9A%E5%90%88%E4%B8%AD%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.weechang.xyz/2018/08/27/AxonFramework在聚合中处理命令/</id>
    <published>2018-08-27T06:04:52.000Z</published>
    <updated>2018-08-30T06:03:51.707Z</updated>
    
    <content type="html"><![CDATA[<p>建议在包含处理状态命令的聚合中直接定义命令处理器，因为命令处理器有可能需要该集合的状态来执行其任务。</p><a id="more"></a><p>要在一个聚合上定义一个命令处理器,只需用@CommandHandler注解命令处理方法即可。带@CommandHandler注解方法的规则和其他处理方法都是一样的。然而,命令不仅通过他们的有效载荷(payload)进行路由。命令消息携带一个名字,该名称默认为命令对象的完全限定类名。</p><p>默认情况下,带@CommandHandler注解的方法允许以下参数类型:</p><ul><li><p>第一个参数是命令消息的有效载荷。它的类型也可能是Message或CommandMessage，如果@CommandHandler 注解明确定义命令处理器的名称。默认情况下，命令名是命令的有效载荷的完全限定类名。</p></li><li><p>用@MetaDataValue注解的参数，将用注解上的键对元数据值进行解析。如果需要为false（默认值），则在元数据值不存在时传递NULL。如果需要为True，在元数据值不存在时，该解析器将不匹配并阻止该方法被调用。</p></li><li><p>参数的类型元数据将注入整个CommandMessage的元数据。</p></li><li><p>UnitOfWork类型的参数获取当前工作单元注入。这允许命令处理器注册的行为在工作单元的特定阶段执行，或获得与它注册的资源的访问。</p></li><li><p>Message或CommandMessage类型的参数，将得到完整的消息，包括有效载荷和元数据。如果方法需要多个元数据字段或包装消息的其他属性，则此方法非常有用。</p></li></ul><p>为了使Axon知道哪一个聚合类型的实例应该处理命令消息，命令对象的属性传送聚合标识符，必须用@TargetAggregateIdentifier注解。注解可以放置在任何字段或访问器方法上（例如getter）。</p><p>创建聚合实例的命令不需要标识目标聚合标识符，虽然建议标注聚合标识符。</p><p>如果你喜欢使用另一个机制路由命令，这种行为可以通过提供一个自定义CommandTargetResolver来重写。这个类应该返回聚合标识符和预期的版本(如果有的话)基于给定的命令。</p><blockquote><p><b>注意</b><br>当@CommandHandler注解放在一个聚合的构造函数上时，相应的命令将创建一个新的聚合实例，并将它添加到存储库。这些命令不需要针对特的定聚合实例。因此，这些命令不需要任何@TargetAggregateIdentifier或@TargetAggregateVersion注解，也不会调用自定义CommandTargetResolver。<br>当一个命令创建一个聚合实例时，该命令的回调函数在命令执行成功执行后，将得到聚合标识符。</p></blockquote><pre>public class MyAggregate {    @AggregateIdentifier    private String id;    @CommandHandler    public MyAggregate(CreateMyAggregateCommand command) {        apply(new MyAggregateCreatedEvent(IdentifierFactory.getInstance().generateIdentifier()));    }    // no-arg constructor for Axon    MyAggregate() {    }    @CommandHandler    public void doSomething(DoSomethingCommand command) {    // do something...    }    // code omitted for brevity. The event handler for MyAggregateCreatedEvent must set the id field}public class DoSomethingCommand {    @TargetAggregateIdentifier    private String aggregateId;    // code omitted for brevity}</pre><p>Axon的配置API可用于配置聚合。例如:</p><pre>Configurer configurer = ...// to use defaults:configurer.configureAggreate(MyAggregate.class);// allowing customizations:configurer.configureAggregate(AggregateConfigurer.defaultConfiguration(MyAggregate.class).configureCommandTargetResolver(c -> new CustomCommandTargetResolver()));</pre><p>@CommandHandler注释并不局限于聚合根。把所有命令处理器放在根里，有时会导致聚合根中存在大量的方法,而它们中的许多只简单地调用转发给底层实体之一。如果是这样,你可以把@CommandHandler注解在一个底层的实体的方法上。Axon找到这些带注释的方法,聚合根中声明的实体字段必须用@AggregateMember标明。注意,命令处理器只检查带注解的字段的声明类型。如果一个字段值为空时传入命令到实体,就会抛出一个异常。</p><pre>public class MyAggregate {    @AggregateIdentifier    private String id;    @AggregateMember    private MyEntity entity;    @CommandHandler    public MyAggregate(CreateMyAggregateCommand command) {        apply(new MyAggregateCreatedEvent(...);    }    // no-arg constructor for Axon    MyAggregate() {    }    @CommandHandler    public void doSomething(DoSomethingCommand command) {        // do something...    }    // code omitted for brevity. The event handler for MyAggregateCreatedEvent must set the id field    // and somewhere in the lifecycle, a value for "entity" must be assigned to be able to accept    // DoSomethingInEntityCommand commands.}public class MyEntity {    @CommandHandler    public void handleSomeCommand(DoSomethingInEntityCommand command) {        // do something    }}</pre><p>请注意，在聚合中每个命令必须只对应一个处理器。这意味着你不能用@CommandHandler标注多个实体(either root nor not，包含是根和不是根的所有实体)来处理相同的命令类型。如果你需要有条件地路由命令到一个实体,这些实体的父类应该处理命令,并根据apply的条件转发该命令。</p><p>字段的运行时类型不需要精确地声明类型。然而，@CommandHandle方法只检查被@AggregateMember标记的字段的声明类型。</p><p>也可以用@AggregateMember去注释包含实体的集合和Map。在后一种情况下，map的值有望包含实体，而键包含一个用作它们引用的值。</p><p>作为一个命令需要被路由到正确的实例，这些实例必须被正确地标识。它们的“ID”字段必须用@ EntityId标记。命令的属性将用于查找该消息应被路由到的实体，默认为被标识的字段的名称。例如，当标记一个名为“myentityid”字段，命令必须具有相同名称的属性。这意味着必须提供个getmyentityid或myentityid()方法。如果字段的名称和路由属性不同，你可以提供一个值显式使用 @EntityId(routingKey = “customRoutingProperty”)。</p><p>如果在带注解的集合和Map中没有实体能被找到，Axon会抛出一个IllegalStateException异常。显然,聚合不能够在那个时间点上处理命令。</p><blockquote><p><b>注意</b><br>字段声明的集合或Map应该包含适当的泛型,允许Axon识别实体的类型包含在集合或Map中。如果不可能添加泛型在声明中(例如因为你已经使用了一个自定义泛型类型的实现),你必须指定实体的类型，用于entityType属性@AggregateMember注解。</p></blockquote><h2 id="外部命令处理器"><a href="#外部命令处理器" class="headerlink" title="外部命令处理器"></a>外部命令处理器</h2><p>在某些情况下,想要直接向一个聚合实例路由命令是不可能。在这种情况下,可以注册一个命令处理器对象。命令处理器对象是一个简单的(常规的)对象，是带@CommandHandle注解的方法。与集合的情况不同，命令处理器对象只有单个实例，该对象处理其方法中声明的所有命令类型。</p><pre>public class MyAnnotatedHandler {    @CommandHandler    public void handleSomeCommand(SomeCommand command, @MetaDataValue("userId") String userId) {        // whatever logic here    }    @CommandHandler(commandName = "myCustomCommand")    public void handleCustomCommand(SomeCommand command) {        // handling logic here    }}// To register the annotated handlers to the command bus:Configurer configurer = ...configurer.registerCommandHandler(c -> new MyAnnotatedHandler());</pre><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/64ddd5a8f517" target="_blank" rel="noopener">https://www.jianshu.com/p/64ddd5a8f517</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建议在包含处理状态命令的聚合中直接定义命令处理器，因为命令处理器有可能需要该集合的状态来执行其任务。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework聚合事件溯源</title>
    <link href="http://blog.weechang.xyz/2018/08/27/AxonFramework%E8%81%9A%E5%90%88%E4%BA%8B%E4%BB%B6%E6%BA%AF%E6%BA%90/"/>
    <id>http://blog.weechang.xyz/2018/08/27/AxonFramework聚合事件溯源/</id>
    <published>2018-08-27T05:56:57.000Z</published>
    <updated>2018-08-30T06:03:51.538Z</updated>
    
    <content type="html"><![CDATA[<p>除了存储一个聚合的当前状态，还可以根据过去发布的事件恢复一个聚合的状态。为此，所有状态的更改必须由一个事件来表示。</p><a id="more"></a><p>主要部分，事件溯源聚合类似于“有规律”聚合：他们必须声明一个标识符并可以使用apply函数发布事件。然而，事件溯源聚合中状态的变化(也就字段的任何变化)必须在@EventSourcingHandler注解的方法中被排他地执行。这包括设置聚合标识符。</p><p>注意,聚合标识必须被设置在聚合发布的第一个事件的@EventSourcingHandler上，这通常是创建事件。</p><p>事件溯源聚合的聚合根还必须包含一个无参的构造函数，Axon Framework使用这个构造函数创建一个空的聚合实例，在使用过去的事件之前初始化它。没有提供这种构造函数加载聚合时将导致异常。</p><pre>public class MyAggregateRoot {    @AggregateIdentifier    private String aggregateIdentifier;    // fields containing state...    @CommandHandler    public MyAggregateRoot(CreateMyAggregate cmd) {        apply(new MyAggregateCreatedEvent(cmd.getId()));    }    // constructor needed for reconstruction    protected MyAggregateRoot() {    }    @EventSourcingHandler    private void handleMyAggregateCreatedEvent(MyAggregateCreatedEvent event) {        // make sure identifier is always initialized properly        this.aggregateIdentifier = event.getMyAggregateIdentifier();        // ... update state    }}</pre><p>带@EventSourcingHandler注解的方法使用特定的规则来解析。这些规则对于带@EventHandler注解的方法也同样适合，并在Defining Event Handlers这一章节中彻底解释。</p><blockquote><p><b>注意</b><br>事件处理器(Event handler)的方法可以是私有的，只要JVM的安全设置允许Axon Framework改变方法的可访问性。这使你能够清楚地分离聚合的公共API，该方法从处理事件的内部逻辑中公开生成事件的方法。大多数的IDE有一个选项来忽略“未使用的私有方法”的警告为特定注解的方法。或者,你可以添加一个@SuppressWarnings(UnusedDeclaration)注解到方法,以确保你不意外地删除事件处理器方法。</p></blockquote><p>有时候，特别是当聚合结构的增长远远超过两个实体时，对同一聚合的其他实体中事件发布的影响更明显。然而，由于重构聚合状态时事件处理器方法也会被调用，所以必须采取特殊的预防措施。</p><p>在事件溯源处理器方法内可以apply()新事件。这使得实体B可以apply一个事件来响应实体A做的一些事情成为可能。Axond重演历史事件时将忽略apply()调用。注意,在这种情况下，内部apply()调用事件只发布给实体，在所有实体收到第一个事件后。如果有更多的事件需要公布，在apply一个内部事件后的实体状态的基础上，可以用apply(…).andThenApply(…)</p><p>你还可以使用静态AggregateLifecycle.isLive()方法来检查聚合是否“存活”。基本上,一个聚合如果已经完成重演历史事件会被认为是存活的。当重演这些事件时，isLive()将返回false。在处理新生成的事件时，使用islive()方法是唯一可以执行的活动。</p><p>复杂的聚合结构</p><p>复杂的业务逻辑通常需要多个带聚合根的聚合来提供支持。在这种情况下，重要的是把复杂性分布在聚合内的多个实体中。当使用事件溯源时，不仅聚合根需要使用事件来触发状态转换，而且聚合内的实体也如此。</p><blockquote><p><b>注意</b><br>一个常见的误解，聚合的实体不应该包含任何属性访问方法来暴露状态。这并非如此。事实上，在同一聚合内的实体向其他的实体暴露状态，可能会使一个聚合受益很多。然而，建议不要向外部暴露聚合的状态。</p></blockquote><p>Axon在复杂的聚合结构中提供了对事件溯源的支持。实体，就像聚合根，简单的对象。子实体的字段声明必须使用@AggregateMember来注解。这个注释告诉Axon被注解的字段，包含一个应该对命令和事件处理程序进行检查的类。</p><p>当一个实体(包括聚合根)应用一个事件时，它首先是由聚合根处理，然后向下通过所有带@AggregateMember注解的字段到其子实体。</p><p>可能包含子实体的字段必须用@AggregateMember注解，此注释可用于多种字段类型：</p><p>字段直接引用的实体类型;<br>内部包含一个迭代器字段(包括所有集合,例如,列表,等等);<br>内部包含java.util.Map字段的值。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/7b88c5077006" target="_blank" rel="noopener">https://www.jianshu.com/p/7b88c5077006</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了存储一个聚合的当前状态，还可以根据过去发布的事件恢复一个聚合的状态。为此，所有状态的更改必须由一个事件来表示。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>MySql中的find_in_set、in、like的区别</title>
    <link href="http://blog.weechang.xyz/2018/08/23/MySql%E4%B8%AD%E7%9A%84find-in-set%E3%80%81in%E3%80%81like%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.weechang.xyz/2018/08/23/MySql中的find-in-set、in、like的区别/</id>
    <published>2018-08-23T02:33:26.000Z</published>
    <updated>2018-08-24T05:35:00.298Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近需要做项目，遇到一个需要查询表中的某一列，其数据结构为多个id间用“,”隔开的字符串。需要判断是否包含某一个id，最开始想的是用like查询，但是转念一想，like查询会存在查询id为1的时候，11、12这样的数据也会被查询出来，后来开始寻找其他方法，找到了find_in_set(str, Strs)函数。然后就对MySql中字符串查询的函数一起做一个总结。</p></blockquote><a id="more"></a><h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p> <b>in相当于多个or条件查询</b></p><p> 例如：</p><p> select * from user where id in(1,2,3)</p><h2 id="NOT-IN"><a href="#NOT-IN" class="headerlink" title="NOT IN"></a>NOT IN</h2><h2 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h2><h2 id="SUBSTR"><a href="#SUBSTR" class="headerlink" title="SUBSTR()"></a>SUBSTR()</h2><h2 id="FIND-IN-SET"><a href="#FIND-IN-SET" class="headerlink" title="FIND_IN_SET()"></a>FIND_IN_SET()</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近需要做项目，遇到一个需要查询表中的某一列，其数据结构为多个id间用“,”隔开的字符串。需要判断是否包含某一个id，最开始想的是用like查询，但是转念一想，like查询会存在查询id为1的时候，11、12这样的数据也会被查询出来，后来开始寻找其他方法，找到了find_in_set(str, Strs)函数。然后就对MySql中字符串查询的函数一起做一个总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常记录" scheme="http://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="http://blog.weechang.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="MySql" scheme="http://blog.weechang.xyz/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework命令模型</title>
    <link href="http://blog.weechang.xyz/2018/08/21/AxonFramework%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%9E%8B/"/>
    <id>http://blog.weechang.xyz/2018/08/21/AxonFramework命令模型/</id>
    <published>2018-08-21T06:00:06.000Z</published>
    <updated>2018-08-30T06:03:51.610Z</updated>
    
    <content type="html"><![CDATA[<p>在一个基于CQRS的应用程序中，领域模型(由Eric Evans和Martin Fowler定义)可以是一个非常强大的机制，来驾驭在验证和执行状态的变化时所涉及的复杂性，虽然典型的领域模型提供了大量的构建块，但当在CQRS中应用命令处理时有一个构件起着主导性的作用：聚合。</p><a id="more"></a><p>应用程序中的一个状态的改变，始于一个命令。命令不但是表达意图(描述你想要做什么)的组合，而且是基于这一意图采取行动所需的信息。命令模型用于处理传入的命令，以验证并定义它的结果。在这个模型中，一个命令处理器负责处理某种类型的命令，并根据它包含的信息采取行动。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合是一个总是保持一致性状态的实体或一组实体。聚合根是聚合树顶部负责维护这个一致性状态的对象。这使得聚合主要构件在任何基于CQRS应用中实现命令模型。</p><blockquote><p><b>注意</b><br>“聚合”指的是埃文斯在领域驱动设计中所定义的聚合:<br>”作为数据变更的一个单元来处理的一组相关联的对象。在外部只能引用聚合的聚合根对象。在聚合边界内使用一组一致性规则。”</p></blockquote><p>例如，“联系人”聚合可以包含两个实体：联系人和地址。若要保持整个聚合处于一致性状态，向联系人添加地址时应通过联系人实体完成。在这种情况下，联系人实体是约定的聚合根。</p><p>在Axon中，聚合由聚合标识符标识。这可能是任何对象，但也有一些标识符良好实现的指导原则。<br>标识符必须:</p><p>实现equals和hashCode来保证与其他实例进行相等比较，<br>实现一个提供一致结果的toString()方法(相等的标识符，toString()方法的结果也应该相等),<br>并且最好是可序列化的。<br>当聚合使用不兼容标识符时，测试固件（见测试）将验证这些条件并使测试失败。 字符串类型的标识符，UUID和数值类型都适用。 不要使用原始类型作为标识符，因为它们不允许进行延迟初始化。在某些情况下，Axon可能会错误地假设原始类型的默认值是标识符的值。</p><p>注意<br>一个经过深思熟虑的好实践是使用随机生成的标识符，而不是使用序列。使用序列会大大降低应用程序的可伸缩性，因为机器需要保持彼此最后一次使用的最新的序列号。UUID冲突的机率非常地小(假如你生成8.2乘以10的11次方个UUID，冲突的机率也只有10的负15次方)。</p><p>此外，聚合应小心地使用函数式标识符。因为它们有变化的倾向，使得它很难适应相应的应用程序。</p><h2 id="聚合的实现"><a href="#聚合的实现" class="headerlink" title="聚合的实现"></a>聚合的实现</h2><p>聚合总是通过一个称为聚合根的实体访问。通常，这个实体的名称和聚合完全一样。例如,Order聚合可能由Order实体引用几个Orderline实体组合而成。Order 和Orderline一起形成聚合。</p><p>一个聚合是一个合乎规范的对象,其中包含状态和和改变这个状态的方法。虽然根据CQRS原则并不完全正确，也可能通过访问器方法暴露出聚合的状态。</p><p>聚合根必须声明一个包含聚合标识符的字段。这个标识符字段必须最迟在第一个事件发布时初始化。这个标识符字段必须由@AggregateIdentifier来注解。如果你在聚合上使用JPA注解，Axon也可以使用由JPA提供的@Id注解。</p><p>聚合可以使用AggregateLifecycle.apply()方法来注册发布的事件。与EventBus不同，这些信息需要被包装在一个EventMessage中，apply()允许你直接传递负载对象。</p><pre>@Entity // Mark this aggregate as a JPA Entitypublic class MyAggregate {    @Id // When annotating with JPA @Id, the @AggregateIdentifier annotation is not necessary    private String id;    // fields containing state...    @CommandHandler    public MyAggregate(CreateMyAggregateCommand command) {        // ... update state        apply(new MyAggregateCreatedEvent(...));    }    // constructor needed by JPA    protected MyAggregate() {    }}</pre><p>通过定义一个带@EventHandler注解的方法，聚合内的实体能监听聚合发布的事件。当一个EventMessage发布时这些方法将被调用（在任何外部处理器被发布之前）。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/6cfc9ab399b2" target="_blank" rel="noopener">https://www.jianshu.com/p/6cfc9ab399b2</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个基于CQRS的应用程序中，领域模型(由Eric Evans和Martin Fowler定义)可以是一个非常强大的机制，来驾驭在验证和执行状态的变化时所涉及的复杂性，虽然典型的领域模型提供了大量的构建块，但当在CQRS中应用命令处理时有一个构件起着主导性的作用：聚合。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework配置</title>
    <link href="http://blog.weechang.xyz/2018/08/20/AxonFramework%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.weechang.xyz/2018/08/20/AxonFramework配置/</id>
    <published>2018-08-20T10:34:05.000Z</published>
    <updated>2018-08-30T06:03:51.450Z</updated>
    
    <content type="html"><![CDATA[<p>获得一个默认的配置是非常容易的：<br>Configuration config = DefaultConfigurer.defaultConfiguration().buildConfiguration();</p><a id="more"></a><p>这个配置为分发消息提供了在线程上处理消息、分发它们的实现。显然，这种配置不会很有用。你必须将你的命令模型对象和事件处理器注册到该配置中。</p><p>为此,通过.defaultConfiguration()方法返回配置实例。<br>Configurer configurer = DefaultConfigurer.defaultConfiguration();</p><p>配置提供了多种允许你注册这些组件的方法。在每个组件的相应章节有如何配置这些组件的详细描述。</p><p>组件一般形式的注册,如下:<br>Configurer configurer = DefaultConfigurer.defaultConfiguration();<br>configurer.registerCommandHandler(c -&gt; doCreateComponent());<br>注意registerCommandBus中lambda表达式的调用。这个表达式的参数c是描述完整配置的配置对象。如果组件需要其他组件正常运行，则可以使用此配置来检索它们。</p><p>例如,注册一个需要序列化器的命令处理程序<br>configurer.registerCommandHandler(c -&gt; new MyCommandHandler(c.serializer());</p><p>不是所有的组件都有其明确的accesor方法。检索一个配置中的组件,使用：<br>configurer.registerCommandHandler(c -&gt; new MyCommandHandler(c.getComponent(MyOtherComp<br>onent.class));</p><p>该组件必须和配置一起注册,使用<br>configurer.registerComponent(componentType, builderFunction) .builder函数将接受配置对象作为输入参数。</p><p>使用Spring设置配置<br>使用Spring时,不需要显式地使用配置。相反,你可以简单地把@EnableAxon设置到一个Spring @configuration类上。</p><p>Axon将使用Spring应用程序上下文来定位构件的特定实现，并为那些不存在的提供默认值。因此,取代在配置中注册构件,你只需要在Spring应用程序上下文中让@Bean可用即可。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/7fcbc0dcc39c" target="_blank" rel="noopener">https://www.jianshu.com/p/7fcbc0dcc39c</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;获得一个默认的配置是非常容易的：&lt;br&gt;Configuration config = DefaultConfigurer.defaultConfiguration().buildConfiguration();&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework工作单元</title>
    <link href="http://blog.weechang.xyz/2018/08/20/AxonFramework%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/"/>
    <id>http://blog.weechang.xyz/2018/08/20/AxonFramework工作单元/</id>
    <published>2018-08-20T05:17:12.000Z</published>
    <updated>2018-08-30T06:03:51.577Z</updated>
    
    <content type="html"><![CDATA[<p>工作单元是Axon Framework的一个重要的概念,虽然在大多数情况下你可能不太直接与它交互。消息的处理被视为一个独立单元。工作单元的目的是在处理一条消息(命令或事件)期间去协调行为的执行。组件可以在工作单元每一个阶段执行注册行为,如onPrepareCommit或onCleanup。</p><a id="more"></a><p>你可能不太需要直接访问工作单元，主要使用Axon提供的构件来访问。不管出于什么原因，如果你需要访问它，有几种方式可以获得它。处理器可以在处理函数中通过一个参数来接收工作单元。如果你使用注解，你可以添加一个UnitOfWork类型参数到你被注解的函数。在其他地方,你可以通过调用CurrentUnitOfWork.get()把工作单元绑定到当前线程。注意，如果没有把工作单元绑定到当前线程，这个方法将抛出一个异常。使用CurrentUnitOfWork.isStarted()可检测它是否可用。</p><p>需要访问当前工作单元的一个原因是，在消息处理过程中附加需要多次重复使用的资源，或者，如果创建资源时需要在工作单元结束时进行清理工作。在这种情况下,unitOfWork.getOrComputeResource()和生命周期回调方法,如onRollback(),afterCommit()和onCleanup()，允许你在工作单元处理期间，注册资源和声明行为。</p><blockquote><p><b>注意</b><br>注意工作单元只是变化的缓存，不是事务的替代品。尽管当工作单位被提交时，所有的阶段更改都被提交，但它的提交不是原子性的。这意味着，当提交失败时一些变化可能会被持久化，而另一些则没有。最佳实践要求命令不应该包含多个行为。如果你坚持这种做法，一个工作单元只包含一个单一的行为，从而将使其被安全使用。如果你的工作单元中有更多的行为，那么你可以考虑将一个事务附加到工作单元的提交。当工作单元提交时，使用unitOfWork.onCommit(. .)注册一个行为。*</p></blockquote><p>你的处理器可以抛出一个异常作为处理消息的结果。默认情况下,未经检测的异常将导致UnitOfWork回滚所有的更改。结果是 ，预定的副作用被撤消。</p><p>Axon 提供了一些开箱即用的回滚策略:</p><ul><li>RollbackConfigurationType.NEVER ,总是提交工作单元。</li><li>RollbackConfigurationType.ANY_THROWABLE ,当异常发生时总是回滚。</li><li>RollbackConfigurationType.UNCHECKED_EXCEPTIONS，错误和运行时异常回滚。</li><li>RollbackConfigurationType.RUNTIME_EXCEPTION ,运行时异常回滚（但不是错误）</li></ul><p>当使用Axon 组件处理消息时，将自动为你管理工作单元的生命周期。如果你选择不使用这些组件，但实现自己的处理，则需要以编程方式启动和提交(或回滚)工作单元。</p><p>在大多数情况下，DefaultUnitOfWork将为你提供你所需要的功能。它在单线程中处理进程。在一个工作单元上下文中执行一个任务，可以new一个DefaultUnitOfWork并简单地调用UnitOfWork.execute(Runnable)或UnitOfWork.executeWithResult(Callable)函数。典型的用法如下:</p><pre>// then, either use the autocommit approach: uow.executeWithResult(() -> ... logic here);// or manually commit or rollback: try {    // business logic comes here    uow.commit();} catch (Exception e) {    uow.rollback(e);    // maybe rethrow...}```</pre> <p>一个工作单元了解各个阶段。每当它进展到不同的阶段时，就会通知UnitOfWork监听器。</p><p><strong>活动阶段:</strong>这是开始工作单元的地方。工作单元通常在当前线程中的这个阶段被注册(通过CurrentUnitOfWork.set(UnitOfWork))。随后，消息通常在此阶段由消息处理器处理。</p><p><strong>提交阶段:</strong>在处理完消息之后，但是在提交工作单元之前，将调用onPrepareCommit监听器。如果一个工作单元被绑定到一个事务中，那么将调用onCommit监听器来提交任何的支持事务。当提交成功时，将调用afterCommit监听器。如果在提交或任何步骤之前失败，将调用onRollback监听器。如果可用，则消息处理器的结果包含在工作单元的ExecutionResult中。</p><p><strong>清理阶段:</strong>在此阶段，该工作单元(如锁)所持有的任何资源都将被释放。如果多个工作单元被嵌套，那么清理阶段将被推迟到外部的单元工作都准备好清理为止。</p><p>消息处理过程可以被认为是一个原子过程;它要么完全被处理，要么完全不被处理。Axon Framework使用工作单元来跟踪消息处理器执行的操作。在处理器完成后，Axon 将尝试提交在工作单元中注册的操作。</p><p>将事务绑定到工作单元是可能的。许多组件，例如CommandBus的实现和所有异步处理事件处理器，都允许你配置事务管理器（Transaction Manager）。然后，该事务管理器将被用于创建事务，以绑定到用于管理消息处理的工作单元。</p><p>当应用程序组件在消息处理的不同阶段需要资源时，比如，数据库连接或实体管理器(EntityManager)，这些资源能</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/3814c293f4fc" target="_blank" rel="noopener">https://www.jianshu.com/p/3814c293f4fc</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作单元是Axon Framework的一个重要的概念,虽然在大多数情况下你可能不太直接与它交互。消息的处理被视为一个独立单元。工作单元的目的是在处理一条消息(命令或事件)期间去协调行为的执行。组件可以在工作单元每一个阶段执行注册行为,如onPrepareCommit或onCleanup。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch查询报错fielddata=true</title>
    <link href="http://blog.weechang.xyz/2018/08/17/ElasticSearch%E6%9F%A5%E8%AF%A2%E6%8A%A5%E9%94%99fielddata-true/"/>
    <id>http://blog.weechang.xyz/2018/08/17/ElasticSearch查询报错fielddata-true/</id>
    <published>2018-08-17T09:01:18.000Z</published>
    <updated>2018-08-24T05:34:30.543Z</updated>
    
    <content type="html"><![CDATA[<p>记录下ElasticSearch查询报错的解决方案，今天在java中查询ElasticSearch的数据发生报错。</p><a id="more"></a><pre>java.lang.IllegalArgumentException: Fielddata is disabled on text fields by default. Set fielddata=true on [pkgts_date] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory.</pre><p>百度了一下。特汇总解决方法。<br>首先，看到这个报错。很自然的就去将pkgts_date字段设置  fielddata=true.但是这样会占用比较多的内存。导致性能下降。因此找到了另外的解决方法。<br>遇到这个错误是因为你尝试对一个text类型的字段做排序，而text类型的字段是要分词的。 一来词典很大，性能会很差；二来排序结果是词典里的词，而并非整个text的内容。 出于这2点原因，ES5.x以后对于text类型默认禁用了fielddata，防止对text字段一些错误的操作（排序，聚合，script)而给heap造成很大的压力。<br>如果一定有对该字段按照文本字母序做排序的需求，可以将该字段定义为multi-filed，例如:</p><pre>    PUT my_index    {      "mappings": {        "my_type": {          "properties": {            "city": {              "type": "text",              "fields": {                "raw": {                   "type":  "keyword"                }              }            }          }        }      }    }</pre><p>上面的city是text类型，适合做全文搜索，然后排序的时候可以用其keyword类型即city.raw。  这样排序结果是正确的，并且keyword字段是通过doc values排序的，内存消耗远小于fielddata。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下ElasticSearch查询报错的解决方案，今天在java中查询ElasticSearch的数据发生报错。&lt;/p&gt;
    
    </summary>
    
      <category term="日常记录" scheme="http://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="http://blog.weechang.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="ElasticSearch" scheme="http://blog.weechang.xyz/tags/ElasticSearch/"/>
    
  </entry>
  
</feed>
