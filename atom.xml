<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>耒耒耒耒耒</title>
  
  <subtitle>张未的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.weechang.xyz/"/>
  <updated>2018-09-04T09:24:40.224Z</updated>
  <id>http://blog.weechang.xyz/</id>
  
  <author>
    <name>张未</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AxonFramework-事件序列化器调优</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E4%BA%8B%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E8%B0%83%E4%BC%98/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-事件序列化器调优/</id>
    <published>2018-08-31T03:20:34.000Z</published>
    <updated>2018-09-04T09:24:40.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XStream序列化器"><a href="#XStream序列化器" class="headerlink" title="XStream序列化器"></a>XStream序列化器</h2><p>XStream是完全可配置和可扩展的。如果你只使用一个无格式XStreamSerializer，有一些速效方案随时取用。<br><a id="more"></a></p><p>XStream允许你为包名称和事件类名称配置别名。别名通常更短(特别是如果你有长包名)，使事件的序列化形式更小。由于我们讨论的是XML，所以每个字符从XML中移除是两次(一个开始标记，一个结束标记)。</p><p>在XStream中一个更高级的话题创建自定义转换器。默认的基于反射的转换器是简单的，但不会生成最紧凑的XML。总是仔细观察生成的XML，看看是否真正需要重建原始实例的所有信息。</p><p>如果有可能避免upcasters的使用。XStream允许别名用于字段，当他们已经改变了名字。想象版本为0事件,使用一个名为“clientId”字段。业务更喜欢“客户”一词，所以版本1使用被称为“customerId”的字段创建。在XStream中这个使用字段别名完全可以配置。你需要配置两个别名，按照以下顺序：别名“customerId”到“clientId”然后别名“customerId”到“customerId”。这将告诉XStream，如果遇到一个叫做“customerId”字段，它将调用相应的XML元素“customerId”(第二个别名覆盖第一个)。但如果XStream遇到一个XML称为“clientId”的元素，这是一个已知的别名，将解析为字段名称“customerId”。查看XStream文档了解更多信息。</p><p>对于终极性能，没有基于反射机制的alltogether你可能更好。在这种情况下，创建一个自定义的序列化机制，这可能是最明智的。DataInputStream和DataOutputStream允许你容易将事件的内容写入输出流。ByteArrayOutputStream和ByteArrayInputStream允许写入和读取字节数组。</p><h2 id="防止重复序列化"><a href="#防止重复序列化" class="headerlink" title="防止重复序列化"></a>防止重复序列化</h2><p>特别是在分布式系统中，事件消息需要在多个场合进行序列化。Axon的组件检测这个并支持SerializationAware消息。如果检测到SerializationAware消息，其方法用来序列化一个对象,而不是简单地传递载荷到序列化器。这允许对性能进行优化。</p><p>当你序列化你自己消息时，希望受益于SerializationAware优化，使用MessageSerializer类序列化消息的有效负载和元数据。所有优化逻辑是在这个类中实现。更多细节请参考MessageSerializer的JavaDoc。</p><h2 id="自定义标识符生成器"><a href="#自定义标识符生成器" class="headerlink" title="自定义标识符生成器"></a>自定义标识符生成器</h2><p>AxonFramework使用IdentifierFactory生成所有的标识符，不论它们是事件或命令。默认情况下，IdentifierFactory随机生成基于java.util.UUID的标识符。尽管它们使用起来非常安全，但生成它们的过程的性能并出色。</p><p>IdentifierFactory是一个抽象工厂，使用Java的ServiceLoader(从Java 6)机制找到实现来使用。这意味着你可以创建自己的工厂的实现，将实现的名称放在一个叫做“/META-INF/services/org.axonframework.common.IdentifierFactory”文件中。Java的ServiceLoader机制将检测到文件并尝试创建名为inside类的实例。</p><p>IdentifierFactory有几个的需求。必须实现：</p><ul><li>在类路径中让它的完全限定类名作为/META-INF/services/org.axonframework.common.IdentifierFactory文件的内容,</li><li>有一个可访问的无参数构造函数,</li><li>扩展IdentifierFactory,</li><li>通过应用程序的类加载器上下文或类加载器加载IdentifierFactory类来访问，并且必须的</li><li>是线程安全的。</li></ul><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/801dade37318" target="_blank" rel="noopener">https://www.jianshu.com/p/801dade37318</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XStream序列化器&quot;&gt;&lt;a href=&quot;#XStream序列化器&quot; class=&quot;headerlink&quot; title=&quot;XStream序列化器&quot;&gt;&lt;/a&gt;XStream序列化器&lt;/h2&gt;&lt;p&gt;XStream是完全可配置和可扩展的。如果你只使用一个无格式XStreamSerializer，有一些速效方案随时取用。&lt;br&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-高级定制</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E9%AB%98%E7%BA%A7%E5%AE%9A%E5%88%B6/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-高级定制/</id>
    <published>2018-08-31T03:14:03.000Z</published>
    <updated>2018-09-04T09:24:40.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参数解析器"><a href="#参数解析器" class="headerlink" title="参数解析器"></a>参数解析器</h2><p>你可以配置额外的ParameterResolvers，通过扩展ParameterResolverFactory类和创建一个名为/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory的文件，包含实现类的完全限定名称。</p><a id="more"></a><blockquote><p><b>警告</b><br>此时，OSGi支持仅限于在清单文件中被提到的所需的头这一事实。ParameterResolverFactory实例的自动检测在OSGi上工作，但由于类加载器的局限性，它可能需要复制/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory 文件的内容到OSGi包，包含用于解析参数的类（即事件处理程序）。</p></blockquote><h2 id="Meta-Annotations"><a href="#Meta-Annotations" class="headerlink" title="Meta Annotations"></a>Meta Annotations</h2><p>TODO</p><h2 id="Customizing-Message-Handler-behavior"><a href="#Customizing-Message-Handler-behavior" class="headerlink" title="Customizing Message Handler behavior"></a>Customizing Message Handler behavior</h2><p>TODO</p><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p>待办事项:更新Axon3<br>本章包含一个清单和在为生产级性能做准备时需要考虑的一些指导方针。现在，你可能已经使用了测试固件测试你的命令处理逻辑和sagas。然而，生产环境不像测试环境那么宽容。聚合往往存活得更久，更频繁地和并发的使用。对于额外的性能和稳定性，你最好调整配置满足你的具体需求。</p><h2 id="数据库索引和列类型"><a href="#数据库索引和列类型" class="headerlink" title="数据库索引和列类型"></a>数据库索引和列类型</h2><h2 id="SQL-DatabasesSQL数据库"><a href="#SQL-DatabasesSQL数据库" class="headerlink" title="SQL DatabasesSQL数据库"></a>SQL DatabasesSQL数据库</h2><p>如果你使用你的JPA实现自动生成表(例如Hibernate)，你可能没有把所有正确的索引设置在你的表上。为获得最佳性能，事件存储的不同用法需要不同的索引设置。该列表显示，为默认EventStorageEngine实现使用的不同类型的查询添加不同类型的索引：</p><ul><li><p>标准操作使用(存储和加载事件):<br>Table ‘DomainEventEntry’, columns aggregateIdentifier and sequenceNumber (unique index)<br>Table ‘DomainEventEntry’, eventIdentifier (unique index)</p></li><li><p>快照：<br>Table ‘SnapshotEventEntry’, aggregateIdentifier column.<br>Table ‘SnapshotEventEntry’, eventIdentifier (unique index)</p></li><li><p>Sagas<br>Table ‘AssociationValueEntry’, columns associationKey and sagaId,</p></li></ul><p>默认生成的列长度可以工作，例如Hibernate，但不会是最优的。例如，一个UUID总是有相同的长度。而不是可变长度列255个字符，你可以为聚合标识符使用一个固定长度36个字符的列。</p><p>“时间戳”列在DomainEventEntry表只储存ISO 8601时间戳。如果所有时间存储在UTC时区，他们需要一个长度为24个字符的列。如果你使用另一个时区，这可能高达28位。使用可变长度列通常是没有必要的，因为时间戳总是具有相同的长度。</p><blockquote><p><b>警告</b><br>强烈建议所有时间戳以UTC格式存储。在夏令时的国家，用当地时间存储时间戳，在时区转换时可能会导致事件生成的顺序错误。使用UTC时不会发生这种情况。有些服务器配置为始终使用UTC。另外你应该在存储它们之前配置事件存储将时间戳转换成UTC。</p></blockquote><p>在DomainEventEntry中的“type”列存储聚合的标识符类型。一般来说，这些都是聚合的简单的名称。在Spring中事件臭名昭著的“AbstractDependencyInjectionSpringContextTests”只算45个字符。在这里，再一次，一个长度较短(但可变)的字段应该足够了。</p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>默认情况下，MongoEventStore只会为正确的操作生成它需要的索引。这意味着当事件存储被创建时，所需的惟一索引在“聚合标识符”、“聚合类型”和“事件序列号”上也被创建。然而，当为某些操作使用MongoEventStore时，可能是值得添加一些额外索引的。</p><p>注意，在查询优化和更新速度之间的总有一个平衡点。负载测试最终是发现哪些索引提供最佳性能的最好方法。</p><ul><li><p>正常操作使用：<br>在“aggregateIdentifier”上自动创建一个索引，“type”和“sequenceNumber”在领域事件(缺省名称:“domainevents”)集合中。</p></li><li><p>Snapshotting：<br>在事件快照(缺省名称:“snapshotevents”)集合中把(unique)索引放“aggregateIdentifier”,“type”和“sequenceNumber“上。</p></li><li><p>Replaying events:<br>在领域事件(缺省名称:“domainevents”)集合中，把非唯一索引放在“timestamp”和“sequenceNumber”上。</p></li><li>Sagas：<br>在saga（默认名称：“sagas”）集合中把(唯一)索引放到“sagaIdentifier”上。<br>在saga（默认名称：“sagas”）集合中把索引放到”sagaType”、“associations.key”和“associations.value“属性上。</li></ul><h2 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h2><p>一个设计良好的命令处理模块当实现缓存时应该不会构成任何问题。尤其是当使用事件溯源时，从事件存储中加载一个聚合是一项昂贵的操作。用正确配置的缓存，加载一个聚合可以转化为一个纯粹的in-memory过程。</p><p>下面是一些帮助您最大限度地利用缓存解决方案的指导原则：</p><ul><li><p>确保工作单元永远不需要为功能原因执行回滚。<br>回滚意味着一个聚合已经达到了一个无效的状态。Axon会自动将相关的缓存项失效。下一个请求将迫使聚合从事件中重建。如果你使用异常作为一个潜在的(功能的)返回值，你可以在命令总线上配置一个RollbackConfiguration。默认情况下，当运行时异常时这个工作单元将回滚。</p></li><li><p>单个聚合的所有命令必须到达在缓存中具有该聚合的机器上。<br>这意味着命令应该始终被路由到同一台机器，只要这台机器是“健康”的。路由命令总是阻止缓存过期。命中一个过期缓存将导致一个命令被执行，并且事件存储在事件存储中会失败。</p></li><li><p>配置一个合理的生存时间/闲置时间<br>默认情况下，缓存倾向于有一个相对较短的生存时间，即几分钟。对于具有一致的路由的命令处理组件，一个较长的闲置时间和生存时间通常是更好的。这可以防止需要初始化一个基于它的事件的聚合，仅仅因为它的缓存条目过期了。缓存的生存时间应该与你的聚合的预期寿命相匹配。</p></li></ul><h2 id="Snapshotting"><a href="#Snapshotting" class="headerlink" title="Snapshotting"></a>Snapshotting</h2><p>快照删除需要重载和重放大量的事件。单个快照代表在在某一特定时刻整个聚合状态。然而，快照的处理本身也需要处理时间。因此，在构建快照时所花费的时间和阻止许多事件被读取节省的时间应该保持平衡。</p><p>对所有类型的应用程序都没有默认行为。一些将指定一些事件之后将创建一个快照，而其他应用程序需要一个基于时间的快照间隔。无论你选择何种方式为您的应用程序，如果你有long-living聚合，确保快照就位。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/1dc158d81511" target="_blank" rel="noopener">https://www.jianshu.com/p/1dc158d81511</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参数解析器&quot;&gt;&lt;a href=&quot;#参数解析器&quot; class=&quot;headerlink&quot; title=&quot;参数解析器&quot;&gt;&lt;/a&gt;参数解析器&lt;/h2&gt;&lt;p&gt;你可以配置额外的ParameterResolvers，通过扩展ParameterResolverFactory类和创建一个名为/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory的文件，包含实现类的完全限定名称。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-SpringBoot自动配置</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-SpringBoot自动配置/</id>
    <published>2018-08-31T03:10:15.000Z</published>
    <updated>2018-09-04T09:24:40.211Z</updated>
    
    <content type="html"><![CDATA[<p>Axon支持的SpringBoot自动配置是迄今为止开始配置Axon基础设施组件最简单的选择。只需添加axon-spring-boot-starter依赖性，Axon会自动配置基础设施组件(命令总线，事件总线)，以及运行和储存聚合和Saga所需的任何组件。</p><a id="more"></a><p>根据在应用程序上下文中的其他组件，如果他们在应用程序上下文中不是已经明确定义，Axon将定义某些组件。这意味着只需要配置不同于默认值的组件。</p><h2 id="事件总线和事件存储配置"><a href="#事件总线和事件存储配置" class="headerlink" title="事件总线和事件存储配置"></a>事件总线和事件存储配置</h2><p>如果JPA可用，事件存储默认使用JPA事件存储引擎。这允许聚合的存储使用事件溯源而无需任何明确的配置。<br>如果JPA不可用，Axon默认使用SimpleEventBus，这意味着你需要为每个聚合指定一个非事件溯源存储库，或者在你的Spring配置中配置一个EventStorageEngine 。</p><p>配置一个不同的事件存储引擎，即使JPA在class path上，只需定义一个EventStorageEngine类型的bean (使用事件溯源)或EventBus(如果不需要事件溯源)。</p><h2 id="命令总线配置"><a href="#命令总线配置" class="headerlink" title="命令总线配置"></a>命令总线配置</h2><p>如果在应用程序上下文中没有显式定义CommandBus实现，Axon会配置一个SimpleCommandBus。这个CommandBus将使用PlatformTransactionManager管理事务，如果它在上下文中可用。</p><p>如果只有CommandBus bean定义是一个DistributedCommandBus实现，Axon仍将配置一个CommandBus实现作为DistributedCommandBus本地segment。这个bean将获取一个“localSegment”限定符。建议定义DistributedCommandBus为@Primary，以便它优先考虑依赖注入。</p><h2 id="聚合配置"><a href="#聚合配置" class="headerlink" title="聚合配置"></a>聚合配置</h2><p>@Aggregate注解(在org.axonframework.spring.stereotype包中)触发自动配置，配置使用带注解的类型的必要组件作为聚合 。注意，只有聚合根需要注解。</p><p>Axon会用命令总线自动注册所有带@CommandHandler注解的方法，并且如果不存在则建立一个存储库。</p><p>建立一个与默认情况不同的存储库，在应用程序上下文中定义一个。可选地，你可以定义要使用的存储库的名称，在@Aggregate上使用存储库属性。如果没有定义存储库属性，Axon将尝试以聚合的名称使用存储库(第一个字符小写)，后缀为存储库。依此类推，一个MyAggregate类的类型，默认的存储库名字叫myAggregateRepository。如果没有找到那个名称的bean，Axon将定义一个EventSourcingRepository(如果没有EventStore可用其会失败)。</p><h2 id="Saga配置"><a href="#Saga配置" class="headerlink" title="Saga配置"></a>Saga配置</h2><p>基础设施组件的配置操作的Saga是@Saga注解触发的(在org.axonframework.spring.stereotype包中)。Axon会配置一个SagaManagert和SagaRepository。SagaRepository将在上下文中使用一个可用的SagaStore(如果找到JPA默认为JPASagaStore)为实际Saga存储。</p><p>为Saga使用不同的SagaStores，在每个@Saga注解的sagaStore属性中，提供要使用的SagaStore的bean名称。<br>Saga将从应用程序上下文中注入资源。注意，这并不意味着Spring-injecting用于注入这些资源。@Autowired和@javax.inject.Inject注解可用于标定依赖关系，但它们由Axon通过寻找这些被注解的字段和方法来注入。构造函数注入(还)不支持。</p><h2 id="事件处理（Event-Handling）配置"><a href="#事件处理（Event-Handling）配置" class="headerlink" title="事件处理（Event Handling）配置"></a>事件处理（Event Handling）配置</h2><p>默认情况下，所有单例Spring bean组件包含带@EventHandler注解的方法，将订阅一个事件处理器去接收事件消息发布到事件总线。</p><p>EventHandlingConfiguration bean，在应用程序上下文可用，有方法来调整事件处理程序的配置。有关详细信息,请参阅配置API配置事件处理程序和事件处理器。</p><p>更新事件处理（EventHandling）配置，创建一个autowired方法,设置你想要的配置:</p><pre>@Autowiredpublic void configure(EventHandlingConfiguration config) {    config.usingTrackingProcessors(); // default all processors to tracking mode.}</pre><p>事件处理器(（Event Processors）的某些方面也可以在application.properties中配置。</p><pre>axon.eventhandling.processors["name"].mode=trackingaxon.eventhandling.processors["name"].source=eventBus</pre><p>使用application.yml:</p><pre>axon:    eventhandling:        processors:            name:                mode: tracking                source: eventBus</pre><p>源文件属性指的是bean的名称实现了SubscribableMessageSource或StreamableMessageSource，名称应该被用来做上述处理器的事件源。源文件默认事件总线或事件存储在应用程序上下文中定义。</p><h2 id="启用AMQP"><a href="#启用AMQP" class="headerlink" title="启用AMQP"></a>启用AMQP</h2><p>启用AMQP支持，确保axon-amqp模块在类路径上，并且在应用程序上下文中AMQP ConnectionFactory是可用的(例如通过引用spring-boot-starter-amqp)。<br>在应用程序中转发生成的事件到一个AMQP Channel，一行application.properties配置就够了：</p><pre>axon.amqp.exchange=ExchangeName</pre><p>这将以给定的名称自动发送所有已经发布的事件到AMQP Channel。</p><p>默认情况下，发送时没有使用AMQP事务。这可以使用axon.amqp.transaction-mode属性覆盖，并设置它为事务或publisher-ack。</p><p>从队列中接收事件，并在Axon应用程序内处理它们，你需要配置一个SpringAMQPMessageSource：</p><pre>@Beanpublic SpringAMQPMessageSource myQueueMessageSource(AMQPMessageConverter messageConverter) {    return new SpringAMQPMessageSource(messageConverter) {        @RabbitListener(queues = "myQueue")        @Override        public void onMessage(Message message, Channel channel) throws Exception {            super.onMessage(message, channel);        }    };}</pre><p>然后配置一个处理器，使用这个bean作为其消息来源:</p><pre>axon.eventhandling.processors["name"].source=myQueueMessageSource</pre><h2 id="使用JGroups分发命令"><a href="#使用JGroups分发命令" class="headerlink" title="使用JGroups分发命令"></a>使用JGroups分发命令</h2><p>进行中…如果你不能等，添加一个依赖项到axon-spring-boot-starter-jgroups模块。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/d843fe8bd7d1" target="_blank" rel="noopener">https://www.jianshu.com/p/d843fe8bd7d1</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Axon支持的SpringBoot自动配置是迄今为止开始配置Axon基础设施组件最简单的选择。只需添加axon-spring-boot-starter依赖性，Axon会自动配置基础设施组件(命令总线，事件总线)，以及运行和储存聚合和Saga所需的任何组件。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-Snapshotting</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-Snapshotting/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-Snapshotting/</id>
    <published>2018-08-31T03:07:08.000Z</published>
    <updated>2018-09-04T09:24:40.209Z</updated>
    
    <content type="html"><![CDATA[<p>当聚合存活很长一段时间，它们的状态不断变化，它们会生成大量的事件。不得不加载所有这些事件去复原一个聚合的状态，可能会有很大的性能影响。快照事件是一个有着特殊用途的领域事件：它将任意数量的事件归纳为单个事件。通过定期创建和存储快照事件，事件存储不必返回长的事件列表。只返回最后一个快照事件和在快照之后发生的所有事件</p><a id="more"></a><p>例如，库存物品往往会经常变化。每销售一件物品，事件就减少一件库存。每次一批新物品进来，库存就增加一些。如果你每天销售一百件，你每天会产生至少100个事件。几天之后，你的系统将会花太多的时间读取所有这些事件，只是为了弄清楚它是否应该raise一个“ItemOutOfStockEvent”。单个快照事件仅仅通过存储当前的库存数量就可以取代很多这些事件。</p><h2 id="Creating-a-snapshot创建一个快照"><a href="#Creating-a-snapshot创建一个快照" class="headerlink" title="Creating a snapshot创建一个快照"></a>Creating a snapshot创建一个快照</h2><p>快照的创建可由多种因素触发，例如，从上次快照创建以来的事件的数量，初始化一个聚合的时候超过了某个阈值，基于时间的，等等。目前，Axon提供了一种机制，允许你基于事件计数阈值触发快照。</p><p>当要创建快照时的定义，由SnapshotTriggerDefinition接口提供。</p><p>当加载聚合所需的事件数量超过一定的阈值时，EventCountSnapshotTriggerDefinition提供触发快照创建的机制。如果加载一个聚合需要的事件的数量超过某个可配置的阈值，触发器告诉Snapshotter为聚合创建一个快照。</p><p>快照触发器在一个事件溯源存储库上配置，并有很多属性允许你调整触发:</p><ul><li>快照设置实际的快照实例，负责创建和存储实际的快照事件;</li><li>触发器设置触发快照创建的阈值;</li></ul><p>Snapshotter负责快照的实际创建。通常，快照是一个应该尽可能少的扰乱操作进程的进程。因此,建议在不同的线程运行Snapshotter。Snapshotter接口声明了单独的方法：scheduleSnapshot()，以聚合的类型和标识符作为参数。</p><p>Axon提供了AggregateSnapshotter，它创建并存储AggregateSnapshot实例。这是一种特殊类型的快照，因为它包含了在它内部的实际的聚合实例。Axon提供的存储库知道这种类型的快照，并从它提取聚合，而不是实例化一个新的。快照事件之后加载的所有事件传输到取出的聚合实例。</p><blockquote><p><b>注意</b><br>确保你使用的序列化器实例(默认为XStreamSerializer)是能够序列化你的聚合的。XStreamSerializer要求使用Hotspot JVM，或者你的聚合要有一个可访问的默认的构造函数或实现Serializable接口。</p></blockquote><p>AbstractSnapshotter提供了一组基本的属性，允许你调整创建快照的方式：</p><ul><li>EventStore设置事件存储，用于加载过去的事件和存储快照。这个事件存储必须实现SnapshotEventStore接口。</li><li>Executor设计executor，比如ThreadPoolExecutor提供了线程来处理实际快照的创建。默认情况下，快照的创建是在线程中调用scheduleSnapshot()方法，一般不建议用于生产。</li></ul><p>AggregateSnapshotter提供另一个属性:</p><ul><li>AggregateFactories是允许你设置创建聚合实例工厂的属性。配置多个聚合工厂允许你使用一个单独的Snapshotter为各种聚合类型创建快照。EventSourcingRepository实现提供了访问他们使用的AggregateFactory。这可以用于配置相同的聚合工厂像在存储库中使用的Snapshotter一样。</li></ul><blockquote><p><b>注意</b><br>如果你使用一个executor在另一个线程中执行快照创建，如果必要的话，确保你为潜在的事件存储配置正确的事务管理。<br>Spring用户可以使用SpringAggregateSnapshotter，当需要创建一个快照时，它将从应用程序上下文自动查找合适的AggregateFactory。</p></blockquote><h2 id="存储快照事件"><a href="#存储快照事件" class="headerlink" title="存储快照事件"></a>存储快照事件</h2><p>当快照存储在事件存储中时，它会自动使用快照归纳所有之前的事件并将其返回到它们的位置。所有事件存储实现允许并发创建快照。这意味着它们允许快照被存储的同时，另一个进程为同一个聚合添加事件。这允许快照进程作为一个完全独立进程。</p><blockquote><p><b>注意</b><br>通常情况下，一旦它们是快照事件的一部分，你就可以归档所有的事件。快照事件将永远不会在常规操作场景中再次读取事件存储。然而,如果你希望能够重建快照创建前一刻的聚合状态，你必须保持事件为最新。</p></blockquote><p>Axon提供了一种特殊类型的快照事件：AggregateSnapshot,它将整个聚合存储为一个快照。动机很简单:你的聚合应该只包含与业务决策相关的的状态。这正是你想要在一个快照中捕获的信息。所有事件溯源存储库由Axon承认的AggregateSnapshot提供，并将从它提取的聚合。注意，使用这个快照事件要求事件序列化机制需要能够对聚合进行序列化。</p><h2 id="根据快照事件初始化聚合"><a href="#根据快照事件初始化聚合" class="headerlink" title="根据快照事件初始化聚合"></a>根据快照事件初始化聚合</h2><p>快照事件是一个和其他事件一样的事件。这意味着一个快照事件就像任何其他领域事件一样被处理。当使用注解来划分事件处理程序(@EventHandler)时，你可以注解一个方法，基于快照事件初始化全部的聚合状态。下面的代码示例演示了，如何像对待任何其他聚合中的领域事件一样对待快照事件。</p><pre>public class MyAggregate extends AbstractAnnotatedAggregateRoot {    // ... code omitted for brevity    @EventHandler    protected void handleSomeStateChangeEvent(MyDomainEvent event) {        // ...    }    @EventHandler    protected void applySnapshot(MySnapshotEvent event) {        // the snapshot event should contain all relevant state        this.someState = event.someState;        this.otherState = event.otherState;    }}</pre><p>有一种类型的快照事件处理方式不同:AggregateSnapshot。这种类型的快照事件包含实际的聚合。聚合工厂识别这种类型的事件并从快照中提取聚合。然后，将所有其他事件重新应用到提取的快照。这意味着聚合从不需要能够处理AggregateSnapshot实例自身。</p><h2 id="先进的冲突检测和解决方案"><a href="#先进的冲突检测和解决方案" class="headerlink" title="先进的冲突检测和解决方案"></a>先进的冲突检测和解决方案</h2><p>明确改变的含义作为一个主要的优势，就是你可以更精确地检测冲突的变化。通常,这些冲突的变化，发生在两个用户同时处理相同的数据(几乎)时。想象一下两个用户都查看一个特定版本的数据。他们都决定对这些数据进行修改。他们都将发送一个命令就像“在这个聚合的X版本上，那样做”，其中X是聚合的预期版本。其中一个会将修改实际应用于预期的版本。另一个用户不会。</p><p>当聚合已经被另一个进程修改时，你可以检查用户的意图与任何看不见的修改是否冲突，而不是简单地拒绝所有传入命令。<br>检测冲突，传递一个ConflictResolver类型的参数到你的聚合的 @CommandHandler方法。这个接口提供了detectConflicts方法，允许你在执行特定类型的命令时，定义被认为是冲突的事件类型。</p><blockquote><p><b>注意</b><br>注意ConflictResolver只会包含任何潜在的冲突事件，如果聚合用一个预期的版本加载。使用@TargetAggregateVersion在一个命令的字段上标示聚合的预期的版本。</p></blockquote><p>如果找到事件匹配的断言（predicate），抛出异常(detectConflicts可选的第二个参数允许你定义抛出的异常)。如果没有找到，处理将继续正常进行。</p><p>如果没有调用detectConflicts，并有潜在冲突的事件,@CommandHandler将失败。这可能是提供一个预期的版本的情况下，在@CommandHandler方法的参数中没有可用的ConflictResolver 。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/0cf9c4c0e037" target="_blank" rel="noopener">https://www.jianshu.com/p/0cf9c4c0e037</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当聚合存活很长一段时间，它们的状态不断变化，它们会生成大量的事件。不得不加载所有这些事件去复原一个聚合的状态，可能会有很大的性能影响。快照事件是一个有着特殊用途的领域事件：它将任意数量的事件归纳为单个事件。通过定期创建和存储快照事件，事件存储不必返回长的事件列表。只返回最后一个快照事件和在快照之后发生的所有事件&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-事件向上转换</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E4%BA%8B%E4%BB%B6%E5%90%91%E4%B8%8A%E8%BD%AC%E6%8D%A2/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-事件向上转换/</id>
    <published>2018-08-31T03:03:17.000Z</published>
    <updated>2018-09-04T09:24:40.218Z</updated>
    
    <content type="html"><![CDATA[<p>由于软件应用程序的不断变化的性质，很可能事件定义也随着时间而变化。由于事件存储被认为是只读和只追加（没有修改和删除）的数据源，所以应用程序必须能够读取所有事件，而不管它们何时添加。这时upcasting 出现了。</p><a id="more"></a><p>最初是面向对象编程的一个概念，“一个子类在需要的时候自动转换成超类”，upcasting 概念也可以应用于事件溯源。upcast一个事件意味着将它从原来的结构转换成新的结构。不像OOP的upcasting，事件的upcasting无法全部自动化完成，因为旧的事件对新事件的结构是不了解的。手工编写的Upcasters，必须提供指定如何将旧的结构upcast成新结构。</p><p>Upcasters类，获取一个x版本的输入事件，并且输出为零或更多版本x+1的新事件。此外，upcasters在一个链中被处理，这意味着一个upcaster的输出发送到下一个upcaster的输入。这允许你以增量的方式更新事件，为每一个新事件版次编写一个Upcaster ，使其小、隔离、并且容易理解。</p><blockquote><p><b>注意</b><br>也许upcasting最大的好处是，它允许你做非破坏性重构，即完整的事件历史仍然保持不变。</p></blockquote><p>在本节中，我们将解释如何编写upcaster，描述随着Axon不同的的Upcaster实现，并解释事件的序列化形式如何影响写upcasters。</p><p>允许upcaster看到什么版本的序列化对象被接收，Event Store存储版本号以及事件的完全限定名称。这个版本号是由RevisionResolver生成,在序列化器中配置。Axon提供了几个RevisionResolver的实现，比如AnnotationRevisionResolver，它检查在事件有效负载上的@Revision注解，SerialVersionUIDRevisionResolver 使用Java Serialization API和FixedValueRevisionResolver所定义的serialVersionUID，它总是返回一个预定义的值。后者在注入当前应用程序版本时是有用的。这将允许你看哪个版本的应用程序生成一个特定的事件。</p><p>Maven用户可以使用MavenArtifactRevisionResolver自动使用项目的版本。它使用项目获取的groupId，artifactId版本初始化。因为这只适用由Maven创建的JAR文件,版本不总能通过IDE来解析。如果无法解析版本，则返回null。</p><h2 id="编写一个upcaster"><a href="#编写一个upcaster" class="headerlink" title="编写一个upcaster"></a>编写一个upcaster</h2><p>事件的老版本:</p><pre>@Revision("1.0")public class ComplaintEvent {    private String id;    private String companyName;    // Constructor, getter, setter...}</pre><p>新版本的事件:</p><pre>@Revision("2.0")public class ComplaintEvent {    private String id;    private String companyName;    private String complain; // New field    // Constructor, getter, setter...}</pre><p>Upcaster:</p><pre>// Upcaster from 1.0 revision to 2.0 revisionpublic class ComplaintEventUpcaster extends SingleEventUpcaster {    private static SimpleSerializedType targetType = new SimpleSerializedType(ComplainEvent.class.getTypeName(), "1.0");    @Override    protected boolean canUpcast(IntermediateEventRepresentation intermediateRepresentation) {        return intermediateRepresentation.getType().equals(targetType);    }    @Override    protected IntermediateEventRepresentation doUpcast(IntermediateEventRepresentation intermediateRepresentation) {        return intermediateRepresentation.upcastPayload(                new SimpleSerializedType(targetType.getName(), "2.0"),                org.dom4j.Document.class,                document -> {                    document.getRootElement().addElement("complaint");                    document.getRootElement().element("complaint").setText("no complaint description"); // Default value                    return document;                }        );    }}</pre><p>Spring boot configuration:</p><pre>@Configurationpublic class AxonConfiguration {    @Bean    public SingleEventUpcaster myUpcaster() {        return new ComplaintEventUpcaster();    }    @Bean    public JpaEventStorageEngine eventStorageEngine(Serializer serializer,                                                    DataSource dataSource,                                                    SingleEventUpcaster myUpcaster,                                                    EntityManagerProvider entityManagerProvider,                                                    TransactionManager transactionManager) throws SQLException {        return new JpaEventStorageEngine(serializer,                myUpcaster::upcast,                dataSource,                entityManagerProvider,                transactionManager);    }}</pre><p>TODO - Describe</p><ul><li>Upcasters工作在中间的表现层</li><li>它们更新流到流</li><li>抽象一对一的upcasting实现</li><li>代码示例</li></ul><h2 id="Content-type-conversion（内容类型转换）"><a href="#Content-type-conversion（内容类型转换）" class="headerlink" title="Content type conversion（内容类型转换）"></a>Content type conversion（内容类型转换）</h2><p>一个upcaster工作在给定内容类型上(如dom4j文档)。upcasters之间提供额外的灵活性，内容类型在链接的upcasters之间可能会有所不同。Axon将尝试使用ContentTypeConverters在内容类型之间自动地转换。它将寻找从类型x到类型y最短的路径，执行转换并交值转换成请求的upcaster。考虑到性能因素 ，如果receiving upcaster上的canUpcast方法产生true，转换才会被执行</p><p>ContentTypeConverters可能依赖于使用的序列化器类型。试图把一个byte[]转换成dom4j文档，这没有任何意义，除非使用序列化器把事件作为XML来写。确保UpcasterChain有权访问serializer-specific ContentTypeConverters,你可以通过UpcasterChain的构造函数引用序列化器。</p><blockquote><p><b>提示</b><br>为了达到最佳性能,确保所有upcasters在同一链上(其中一个的输出是另一个的输入)处理相同的内容类型。</p></blockquote><p>如果你需要不是由Axon提供的内容类型转换，你可以使用ContentTypeConverter接口编写一个自己的。<br>XStreamSerializer支持Dom4J像支持 XOM一样作为XML文档表示。JacksonSerializer 支持Jackson的JsonNode。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/e4e943937993" target="_blank" rel="noopener">https://www.jianshu.com/p/e4e943937993</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于软件应用程序的不断变化的性质，很可能事件定义也随着时间而变化。由于事件存储被认为是只读和只追加（没有修改和删除）的数据源，所以应用程序必须能够读取所有事件，而不管它们何时添加。这时upcasting 出现了。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-EventStore实现</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-EventStore%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-EventStore实现/</id>
    <published>2018-08-31T02:52:45.000Z</published>
    <updated>2018-09-04T09:24:40.204Z</updated>
    
    <content type="html"><![CDATA[<p>事件溯源存储库需要一个事件存储（event store）从聚合中存储和加载事件。事件存储提供了一个事件总线的功能，增加了持久化已发布的事件，并能够基于聚合标识符检索事件。</p><a id="more"></a><p>Axon提供了一个开箱即用的事件存储，EmbeddedEventStore。它委托事件实际的存储和检索到EventStorageEngine。<br>有多个EventStorageEngine的实现：</p><h2 id="JpaEventStorageEngine"><a href="#JpaEventStorageEngine" class="headerlink" title="JpaEventStorageEngine"></a>JpaEventStorageEngine</h2><p>JpaEventStorageEngine存储事件在JPA-compatible数据源中。JPA事件存储存储事件在所谓的条目中。这些条目包含事件的序列化形式，以及存储一些领域元数据以快速查找这些条目。使用JpaEventStorageEngine，你必须在你的类路径中有JPA注解(javax.persistence)。</p><p>默认情况下，事件存储需要你配置你的持久化上下文(如在META-INF/persistence.xml中定义)包含DomainEventEntry和SnapshotEventEntry（两者都在org.axonframework.eventsourcing.eventstore.jpa包中)。<br>下面是一个持久化上下文配置的示例配置：</p><pre><persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">    <persistence-unit name="eventStore" transaction-type="RESOURCE_LOCAL"> (1)        <class>org...eventstore.jpa.DomainEventEntry</class> (2)        <class>org...eventstore.jpa.SnapshotEventEntry</class>    </persistence-unit></persistence></pre><p>在这个示例中，事件存储有一个特定的持久化单元。然而，你可能会选择将第三行添加到任何其他持久化单元的配置中。<br>本行注册DomainEventEntry(由JpaEventStore使用的类)到持久化上下文。</p><blockquote><p><b>注意</b><br>Axon使用锁来防止两个线程访问相同的聚合。然而，如果在同一数据库上你有多个jvm，这不会帮助你。在这种情况下，你不得不依靠数据库来检测冲突。并发访问事件存储将导致违反主键约束（Key Constraint Violation），因为表允许聚合只能有一个任何序列号的事件，所以，用已有的序列号为现有聚合插入第二个事件将导致错误。<br>JpaEventStorageEngine可以检测这个错误并把它转换成ConcurrencyException。然而，每个数据库系统以不同的方式报告此违规行为。如果你用JpaEventStore注册你的数据源，它将尝试检测数据库的类型，并找出错误代码是一个违反主键约束（Key Constraint Violation）。或者，你可能会提供一个PersistenceExceptionTranslator实例，如果一个给定的异常代表一个违反主键约束（Key Constraint Violation）它能分辨。<br>如果没有提供数据源或PersistenceExceptionTranslator，从数据库驱动程序按原样抛出异常。</p></blockquote><p>默认情况下，JPA事件存储引擎需要一个EntityManagerProvider实现，返回EventStorageEngine使用的EntityManager实例。这还允许应用程序管理所用的持久化上下文。EntityManagerProvider的责任是提供一个正确的EntityManager实例。</p><p>有几个EntityManagerProvider的实现可用，各有不同的需求。SimpleEntityManagerProvider仅在构建时返回EntityManager实例给它。这使得实现成为容器管理上下文一个简单的选择。ContainerManagedEntityManagerProvider作为一种选择，返回默认的持久化上下文，并且它的使用默认通过JPA事件存储。<br>如果你有一个持久化单元称为“myPersistenceUnit”，你希望在JpaEventStore中使用，这就是EntityManagerProvider实现，可能看起来像:</p><pre>public class MyEntityManagerProvider implements EntityManagerProvider {    private EntityManager entityManager;    @Override    public EntityManager getEntityManager() {        return entityManager;    }    @PersistenceContext(unitName = "myPersistenceUnit")    public void setEntityManager(EntityManager entityManager) {        this.entityManager = entityManager;    }}</pre>   <p>默认情况下，JPA事件存储把条目存储在DomainEventEntry和SnapshotEventEntry实体中。虽然在许多情况下这就足够了，你可能会遇到这些实体提供的元数据不够的情况。或者你可能想将不同的聚合类型的事件存储在不同的表。<br>如果是这样,你可以扩展JpaEventStorageEngine。它包含了一些protected方法，你可以重写来调整其行为。</p><blockquote><p><b>警告</b><br>注意持久化提供者，如Hibernate，在它们的EntityManager实现上使用一级缓存。通常，这意味着在查询中使用或返回的所有隶属于EntityManager的实体。它们只有在周围事务被提交或在事务中执行显式“清除”时才被清除。当查询在事务上下文中执行时尤其如此。<br>要解决这个问题，请确保仅仅查询非实体对象。你可以使用JPA的“SELECT new SomeClass(parameters) FROM …”风格的查询来解决这个问题。或者，获取一批事件后调用EntityManager.flush()和EntityManager.clear()。未能这样做当加截大事件流时可能导致OutOfMemoryExceptions。</p></blockquote><h2 id="JDBC-Event-Storage-Engine"><a href="#JDBC-Event-Storage-Engine" class="headerlink" title="JDBC Event Storage Engine"></a>JDBC Event Storage Engine</h2><p>JDBC事件存储引擎使用JDBC连接将事件存储在JDBC兼容的数据存储。通常，这些都是关系数据库。从理论上讲，任何一个JDBC驱动程序都可以用来支持JDBC事件存储引擎。</p><p>类似于JPA，JDBC事件存储引擎将事件存储在条目中。默认情况下，每个事件存储在一个单独的条目中，对应表中的一行。一个表用于事件，另一个用于快照。</p><p>JdbcEventStorageEngine使用ConnectionProvider来获取连接。通常，这些连接可以直接从数据源中获得。然而，Axon会将这些连接绑定到一个工作单元，以便在一个工作单元使用一个连接。这将确保一个单独的事务用于存储所有事件，即使在同一线程中嵌套多个工作单元。</p><blockquote><p><b>注意</b><br>Spring用户建议使用SpringDataSourceConnectionProvider从数据源附加连接到现有的事务。</p></blockquote><h2 id="MongoDB-Event-Storage-Engine"><a href="#MongoDB-Event-Storage-Engine" class="headerlink" title="MongoDB Event Storage Engine"></a>MongoDB Event Storage Engine</h2><p>MongoDB是一个基于文档的NoSQL存储。其可伸缩特性使它适合用于事件存储。Axon提供了MongoEventStorageEngine,使用MongoDB作为数据库支持。它包含在Axon Mongo模块(Maven artifactId axon-mongo)。</p><p>事件存储在两个独立的集合中：一个用于实际的事件流，一个用于快照。</p><p>默认情况下，MongoEventStorageEngine将存储各自的事件在各自的文档。然而，它是可能改变StorageStrategy使用。</p><p>Axon提供的选择是DocumentPerCommitStorageStrategy，为在一个单独的提交中存储所有事件，创建一个单独的文档(即在同一DomainEventStream)。</p><p>在一个单独的文档中存储整个提交的好处在于提交是原子存储的。此外，它只需要对任意数量的事件进行一次往返。缺点是,它变得更加难以直接在数据库中查询事件。例如，当重构领域模型时，如果他们被包含在“commit document”中，很难从一个聚合“transfer”事件到另一个聚合。</p><p>MongoDB不需要很多配置。它所需要的只是对一个存储事件集合的引用，然后你就可以开始了。在生产环境中，你可能想要对集合中的索引进行双重检查。</p><h2 id="Event-Store-Utilities"><a href="#Event-Store-Utilities" class="headerlink" title="Event Store Utilities"></a>Event Store Utilities</h2><p>Axon提供了一些事件存储引擎，可能在某些情况下是有用的。</p><p>SequenceEventStorageEngine是围绕其它两个事件存储引擎的包装器。当读取时,它从这两个事件存储引擎中返回事件。附加事件只是附加到第二个事件存储引擎。出于性能原因使用事件存储两种不同的实现的情况下，这是有用的，例如。第一个是一个更大的，但较慢事件存储，而第二个是优化的快速读取和写入。</p><p>还有一个常驻内存的存储事件EventStorageEngine实现：InMemoryEventStorageEngine。虽然它可能优于任何其他的事件存储，这并不意味着长期生产使用。然而，它在需要事件存储的short-lived工具或测试中非常有用,。</p><h2 id="Influencing-the-serialization-process（影响序列化过程）"><a href="#Influencing-the-serialization-process（影响序列化过程）" class="headerlink" title="Influencing the serialization process（影响序列化过程）"></a>Influencing the serialization process（影响序列化过程）</h2><p>事件存储需要为存储准备一种序列化事件的方法。默认情况下，Axon使用XStreamSerializer，其使用XStream序列化成XML事件。XStream是相当快的，比Java序列化更灵活。此外，XStream序列化的结果是人类可读的。对日志和调试而言非常有用。</p><p>XStreamSerializer可以配置。你可以定义它应该用于某些包、类甚至字段的别名。除了可以缩短潜在的长名称之外，还可以在事件的类定义更改时使用别名。有关别名的更多信息，访问XStream网站。</p><p>另外，Axon还提供了JacksonSerializer，使用Jackson将事件序列化为JSON。当它生成一个更紧凑的序列化形式，它要求类遵守Jackson所要求的约定(或配置)。</p><blockquote><p><b>注意</b><br>使用Java代码(或其他JVM语言)配置序列化器是很容易的。然而，由于它调用方法的局限性，在Spring XML程序上下文看配置它并不那么简单。其中一个选项是创建一个FactoryBean，创建一个XStreamSerializer实例，并配置它的代码。检查 Spring 参考更多的信息。</p></blockquote><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/7ffff660d9a1" target="_blank" rel="noopener">https://www.jianshu.com/p/7ffff660d9a1</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件溯源存储库需要一个事件存储（event store）从聚合中存储和加载事件。事件存储提供了一个事件总线的功能，增加了持久化已发布的事件，并能够基于聚合标识符检索事件。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-存储库</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%AD%98%E5%82%A8%E5%BA%93/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-存储库/</id>
    <published>2018-08-31T02:50:48.000Z</published>
    <updated>2018-09-04T09:24:40.241Z</updated>
    
    <content type="html"><![CDATA[<p>存储库是提供对聚合访问的机制。存储库充当了用于保存数据的实际存储机制的网关。在CQRS中，存储库只需要能够根据他们的惟一标识符找到聚合。任何其他类型的查询，应该在查询数据库中执行。</p><a id="more"></a><p>在Axon Framework中,所有存储库必须实现Repository接口。这个接口规定了三种方法:load(identifier, version)， load(identifier)和newInstance(factoryMethod)。load方法允许你从存储库加载聚合。version可选参数是用来检测并发修改(见Advanced conflict detection and resolution)。newInstance用于注册新创建的聚合到存储库中。</p><p>基于你潜在的持久性存储和审计需求，有一些基础实现提供大了部分存储库所需的基本功能。Axon Framework对保存聚合当前状态的存储库(见Standard Repositories)和那些存储聚合事件的存储库(见 Event Sourcing Repositories)进行了区分。</p><p>注意，存储库接口没有声明delete(identifier)方法。删除聚合是通过在一个聚合内部调用AggregateLifecycle.markDeleted()方法完成的。删除聚合是一个与其他迁移一样的状态迁移，唯一的区别是它在许多情况下是不可逆的。你应该在聚合上创建自己的有意义的方法，来将聚合的状态设置为“已删除”。这也允许你注册你想要发布的任何事件。</p><h2 id="Standard-repositories（标准存储库）"><a href="#Standard-repositories（标准存储库）" class="headerlink" title="Standard repositories（标准存储库）"></a>Standard repositories（标准存储库）</h2><p>标准存储库存储聚合的实际状态。在每次修改后，新的状态将覆盖旧的。这使得命令组件也可以使用应用程序的查询组件使用的相同信息。标准存储库存储聚合的实际状态。这可能取决于你正在创建的应用程序的类型，这是最简单的解决方案。如果是这样的话，Axon提供了一些帮助你实现这样一个存储库的构件。</p><p>Axon为标准存储库提供了一个开箱即用的实现：GenericJpaRepository。它认为聚合是一个有效的JPA实体。它使用EntityManagerProvider配置，EntityManagerProvider提供EntityManager来管理实际的持久化，并且一个类指定聚合的实际类型存储在存储库中。当聚合调用静态AggregateLifecycle.apply()方法时，你也可以通过EventBus去发布事件。</p><p>你也可以轻松实现自己的存储库。在这种情况下，最好从抽象类LockingRepository扩展。作为聚合的包装器类型，建议使用AnnotatedAggregate。看GenericJpaRepository的源码示例。</p><h2 id="Event-Sourcing-repositories（事件溯源存储库）"><a href="#Event-Sourcing-repositories（事件溯源存储库）" class="headerlink" title="Event Sourcing repositories（事件溯源存储库）"></a>Event Sourcing repositories（事件溯源存储库）</h2><p>聚合根能够根据事件重建它们的状态，也可以配置为通过事件溯源存储库加载。这些存储库不存储聚合本身，但存储聚合生成的一系列事件。基于这些事件，可以随时恢复聚合的状态。</p><p>在AxonFramework中，EventSourcingRepository实现提供了任何事件溯源存储库所需的基本功能。这依赖于EventStore(见Implementing your own Event Store)，它抽象了实际的存储机制。</p><p>根据情况，你可以提供一个聚合工厂。AggregateFactory指定了如何创建一个聚合实例。一旦创建了一个聚合，EventSourcingRepository可以使用从事件存储中加载的事件来初始化。Axon Framework自带了一些你可以使用的AggregateFactory实现。如果他们还不够，可以很容易创建你自己的实现。</p><h2 id="GenericAggregateFactory"><a href="#GenericAggregateFactory" class="headerlink" title="GenericAggregateFactory"></a>GenericAggregateFactory</h2><p>GenericAggregateFactory是一种特别的AggregateFactory实现，可用于任何类型的事件溯源聚合根。GenericAggregateFactory创建存储库管理的聚合类型的一个实例。聚合类必须是非抽象的，声明一个默认的不进行初始化的无参构造函数化。<br>GenericAggregateFactory适用于大多数场景，聚合不需要专门注入non-serializable资源。</p><h2 id="SpringPrototypeAggregateFactory"><a href="#SpringPrototypeAggregateFactory" class="headerlink" title="SpringPrototypeAggregateFactory"></a>SpringPrototypeAggregateFactory</h2><p>根据你的架构选择，使用Spring将依赖项注入到聚合中可能是有用的。例如，你可以将查询库注入到你的聚合，以确保某些值的存在(或不存在)。</p><p>注入依赖项到你的聚合，在定义了SpringPrototypeAggregateFactory的Spring上下文中，你需要配置一个聚合根的属性bean。不是使用构造函数创建的常规的实例，而是使用Spring应用程序上下文实例化你聚合。这也将在你的聚合中注入的任何依赖项。</p><h2 id="实现自己的AggregateFactory"><a href="#实现自己的AggregateFactory" class="headerlink" title="实现自己的AggregateFactory"></a>实现自己的AggregateFactory</h2><p>在某些情况下，GenericAggregateFactory不能提供你所需要的东西。例如，你可以有一个抽象的聚合类型与不同的场景的多个实现(例如，PublicUserAccount和BackOfficeAccount都扩展一个帐户)。而不是为每个聚合创建不同的存储库，你可以使用一个单独的存储库，并配置一个AggregateFactory意识到不同的实现。</p><p>聚合工厂大部分的工作是创建未初始化的聚合实例。它必须使用一个给定的聚合标识符和流中的第一个事件。通常，这个事件是一个创建事件，其中包含关于预期聚合类型的提示。你可以使用这些信息来选择一个实现并调用其构造函数。确保没有事件被应用于构造函数；聚合必须未初始化。</p><p>相对于简单的存储库直接加载聚合的实现，基于事件初始化聚合可能是一项耗时的工作,。CachingEventSourcingRepository提供一个可以从中加载聚合的缓存</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/585e95e31704" target="_blank" rel="noopener">https://www.jianshu.com/p/585e95e31704</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存储库是提供对聚合访问的机制。存储库充当了用于保存数据的实际存储机制的网关。在CQRS中，存储库只需要能够根据他们的惟一标识符找到聚合。任何其他类型的查询，应该在查询数据库中执行。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-分发事件</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%88%86%E5%8F%91%E4%BA%8B%E4%BB%B6/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-分发事件/</id>
    <published>2018-08-31T02:47:38.000Z</published>
    <updated>2018-09-04T09:24:40.226Z</updated>
    
    <content type="html"><![CDATA[<p>在某些情况下，有必要发布事件到外部系统,比如消息broker。</p><a id="more"></a><h2 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h2><p>Axon提供了开箱即用的支持从一个AMQP message broker中转递事件和传递事件到broker中，比如Rabbit MQ。</p><h2 id="将事件转发到AMQP-Echange"><a href="#将事件转发到AMQP-Echange" class="headerlink" title="将事件转发到AMQP Echange"></a>将事件转发到AMQP Echange</h2><p>SpringAMQPPublisher将事件转发给一个AMQP Exchange。它使用SubscribableMessageSource初始化，一般是EventBus或EventStore。从理论上讲，这可能是发布者可以订阅的任何事件源。</p><p>要配置SpringAMQPPublisher，只需一个实例定义为Spring Bean。有一些setter方法允许你指定你预期的行为，如事务支持，publisher 确认(如果由broker支持)，和交换名称。</p><p>默认的exchange名称为’Axon.EventBus’</p><blockquote><p><b>注意</b><br>注意，exchanges不会被自动创建。你还必须声明队列、Exchanges 和你希望使用的Bindings 。检查Spring文档了解更多信息。</p></blockquote><h2 id="从AMQP-队列中读取事件"><a href="#从AMQP-队列中读取事件" class="headerlink" title="从AMQP 队列中读取事件"></a>从AMQP 队列中读取事件</h2><p>Spring已经广泛的支持从一个AMQP队列读取消息。然而,这需要与Axon“架桥”，以便这些消息可以从Axon处理，就像它们是常规事件消息一样。</p><p>SpringAMQPMessageSource允许事件处理器从队列中读取消息，而不是事件存储或事件总线。它作为一个Spring AMQP和SubscribableMessageSource之间的适配器需要这些处理器。</p><p>配置SpringAMQPMessageSource最简单的方法，是通过定义一个bean，重写默认的onMessage方法并使用@RabbitListener注解，如下:</p><pre>@Beanpublic SpringAMQPMessageSource myMessageSource(Serializer serializer) {    return new SpringAMQPMessageSource(serializer) {        @RabbitListener(queues = "myQueue")        @Override        public void onMessage(Message message, Channel channel) throws Exception {            super.onMessage(message, channel);        }    };}</pre><p>Spring的@RabbitListener注解告诉Spring，这个方法需要被给定队列上的每个消息调用(myQueue的例子)。此方法简单地调用super.onMessage()方法，执行实际事件的发布到已经订阅它的所有处理器。</p><p>订阅这个MessageSource的处理器，将正确的SpringAMQPMessageSource实例传递给订阅处理器的构造函数:</p><pre>// in an @Configuration file:@Autowiredpublic void configure(EventHandlingConfiguration ehConfig, SpringAmqpMessageSource myMessageSource) {    ehConfig.registerSubscribingEventProcessor("myProcessor", c -> myMessageSource);}</pre><p>请注意跟踪处理器与SpringAMQPMessageSource不兼容。</p><h2 id="异步事件处理"><a href="#异步事件处理" class="headerlink" title="异步事件处理"></a>异步事件处理</h2><p>异步处理事件推荐的方法是使用跟踪事件处理器。这个实现可以保证所有事件的处理，甚至在发生系统故障的情况下(假定事件已经被持久化)。</p><p>然而,也有可能在SubscribingProcessor中异步处理事件。要做到这一点，SubscribingProcessor必须用EventProcessingStrategy配置。这种策略可以用来改变事件监听器的调用应如何管理。</p><p>默认策略(DirectEventProcessingStrategy)在传递事件的线程中调用这些事件处理程序。这允许处理器使用现有的事务。</p><p>其他Axon-provided strategy是AsynchronousEventProcessingStrategy。它使用一个Executor异步调用事件侦听器。</p><p>尽管AsynchronousEventProcessingStrategy异步执行，某些事件按顺序处理仍然是可取的。SequencingPolicy定义事件是否必须按顺序处理，并行或两者的结合。策略返回给定事件的序列标识符。如果两个事件的策略返回一个相等的标识符,这意味着他们必须由事件处理程序按顺序处理。一个空序列标识符意味着事件可能与任何其他事件并行处理。</p><p>Axon提供了一些可以使用的通用策略：</p><ul><li>FullConcurrencyPolicy会告诉Axon，事件处理程序可以处理所有并发事件。这意味着需要按特定顺序处理的事件之间没有关系。</li><li>SequentialPolicy告诉Axon，所有活动必须按照顺序进行处理。处理事件的操作将在处理前一个事件完成时开始。</li><li>SequentialPerAggregatePolicy将迫使领域事件从同一聚合顺序处理。然而，事件来自不同聚合可能并发处理。这通常是一个合适的政策，用于事件侦听器更新数据库中聚合的细节。</li></ul><p>除了这些提供的策略之外，你可以定义自己的策略。所有策略都必须实现SequencingPolicy接口。这个接口定义了一个方法getSequenceIdentifierFor，返回值为一个给定的事件序列标识符。返回相等序列标识符的事件必须按顺序处理。产生不同序列标识符的事件可以同时处理。出于性能原因，如果事件可以并行处理任何其他事件，则策略实现应该返回null。这样更快，因为Axon不必检查对事件处理的任何限制条件。</p><p>当使用AsynchronousEventProcessingStrategy时建议明确定义一个ErrorHandler。默认的ErrorHandler传播异常，但在异步执行中没有什么可以传播的，除了Executor。这可能导致事件没有被处理。相反，建议使用一个ErrorHandler报告错误，并允许继续处理。ErrorHandler被配置在SubscribingEventProcessor的构造函数上，还提供了EventProcessingStrategy。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/c333f2c05239" target="_blank" rel="noopener">https://www.jianshu.com/p/c333f2c05239</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在某些情况下，有必要发布事件到外部系统,比如消息broker。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-事件发布和处理</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-事件发布和处理/</id>
    <published>2018-08-31T02:44:40.000Z</published>
    <updated>2018-09-04T09:24:40.214Z</updated>
    
    <content type="html"><![CDATA[<p>由应用程序生成的事件需要被分发到更新查询数据库的组件，搜索引擎或其他需要它们的资源：事件处理程序（Event Handlers）。事件总线（Event Bus）的职责是分发事件消息到所有感兴趣的组件。接收端，事件处理器（Event Processors）负责处理这些事件，其中包括相应的事件处理程序（Event Handlers）的调用。</p><a id="more"></a><h2 id="发布事件（Publishing-Events）"><a href="#发布事件（Publishing-Events）" class="headerlink" title="发布事件（Publishing Events）"></a>发布事件（Publishing Events）</h2><p>在绝大多数情况下，聚合将通过申请（applying）它们发布事件。然而，有时候也有必要发布一个事件(可能来自另一个组件)，直接到事件总线。发布一个事件，在EventMessage中简单封装描述事件的有效负载（payload）。</p><p>GenericEventMessage.asEventMessage(Object)方法允许你将任何对象包装成EventMessage。如果传递的对象已经是EventMessage，它只是返回。</p><h2 id="事件总线（Event-Bus）"><a href="#事件总线（Event-Bus）" class="headerlink" title="事件总线（Event Bus）"></a>事件总线（Event Bus）</h2><p>EventBus是分发事件到已订阅的事件处理器的机制。Axon 提供了两个事件总线的实现：SimpleEventBus和EmbeddedEventStore。两个实现都支持订阅和跟踪处理器(processor)，EmbeddedEventStore持久化事件，它允许你在以后的阶段重放它们。SimpleEventBus有一个易失性存储器，然后一旦事件已经发布到订阅组件上，就会“忘记”它们。</p><p>当使用配置API时，默认情况下使用SimpleEventBus。配置EmbeddedEventStore则相反，需要提供一个StorageEngine的实现，它对事件进行实际存储。</p><pre>Configurer configurer = DefaultConfigurer.defaultConfiguration();configurer.configureEmbeddedEventStore(c -> new InMemoryEventStorageEngine());</pre><h2 id="Event-Processors"><a href="#Event-Processors" class="headerlink" title="Event Processors"></a>Event Processors</h2><p>事件处理程序（Event Handlers）定义了接收事件时执行的业务逻辑。事件处理器（Event Processors）负责解决该过程的技术方面的组件。它们启动一个工作单元，也可能一个事务，并且确保相关的数据在事件处理期间，可以正确附加到所有创建的消息上。</p><p>事件处理器大致有两种形式：订阅和跟踪。订阅事件处理器订阅它们自己给事件源，并由发布机制管理的线程调用。另一方面，跟踪事件处理器使用自己管理的线程从源中取出它们的消息。</p><h2 id="将处理程序分配给处理器"><a href="#将处理程序分配给处理器" class="headerlink" title="将处理程序分配给处理器"></a>将处理程序分配给处理器</h2><p>所有处理器都有一个名称，它跨JVM实例标识一个处理器实例。两个名称相同的处理器，可以被认为是同一处理器的两个实例。<br>所有事件处理程序都被附加到一个处理器，它的名字是事件处理程序类的包名。<br>例如, 下面的类：</p><ul><li>org.axonframework.example.eventhandling.MyHandler,</li><li>org.axonframework.example.eventhandling.MyOtherHandler</li><li>org.axonframework.example.eventhandling.module.MyHandler</li></ul><p>将触发两个处理器的创建：</p><ul><li>org.axonframework.example.eventhandling with 2 handlers, and</li><li>org.axonframework.example.eventhandling.module with a single handler</li></ul><p>配置API允许你为分配的类配置其他策略给处理器，甚至将特定实例分配给特定的处理器。</p><h2 id="配置处理器"><a href="#配置处理器" class="headerlink" title="配置处理器"></a>配置处理器</h2><p>默认情况下，Axon将使用订阅事件处理器。这是有可能改变处理程序是如何分配和如何使用配置API的EventHandlingConfiguration类配置处理器的。</p><p>EventHandlingConfiguration类定义了一些的方法，可用于定义处理器需要如何配置。</p><ul><li>registerEventProcessorFactory允许你定义一个默认的工厂方法，创建没有明确定义工厂的事件处理器。</li><li>registerEventProcessor(String name, EventProcessorBuilder builder)定义了用于创建一个带有给定名称的处理器的工厂方法。注意，此种处理器只有当名称被选择作为任何可用的事件处理程序bean的处理器时才会创建。</li><li>registerTrackingProcessor(String name)定义了一个带有给定名称的处理器，使用默认设置，应该被配置成一个跟踪事件处理器。它使用TransactionManager和TokenStore配置。</li><li>usingTrackingProcessors()设置默认跟踪处理器，而不是订阅处理器。</li></ul><p>跟踪处理器不像订阅处理器，需要一个令牌存储来存储它们的进程。跟踪处理器通过其事件流接收的每个消息都伴随着一个令牌。这个令牌允许处理器在任何以后的点重新打开流，并在最后一个事件中提取它。</p><p>配置API负责令牌存储，以及大多数其他组件处理器需要从全局配置实例。如果没有明确定义TokenStore ，在生产中不推荐使用InMemoryTokenStore。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/217ac0d8822d" target="_blank" rel="noopener">https://www.jianshu.com/p/217ac0d8822d</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由应用程序生成的事件需要被分发到更新查询数据库的组件，搜索引擎或其他需要它们的资源：事件处理程序（Event Handlers）。事件总线（Event Bus）的职责是分发事件消息到所有感兴趣的组件。接收端，事件处理器（Event Processors）负责处理这些事件，其中包括相应的事件处理程序（Event Handlers）的调用。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-分布式命令总线连接器</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%88%86%E5%B8%83%E5%BC%8F%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF%E8%BF%9E%E6%8E%A5%E5%99%A8/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-分布式命令总线连接器/</id>
    <published>2018-08-31T02:40:27.000Z</published>
    <updated>2018-09-04T09:24:40.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JGroupsConnector"><a href="#JGroupsConnector" class="headerlink" title="JGroupsConnector"></a>JGroupsConnector</h2><p>JGroupsConnector使用(正如它的名字已经说明)JGroups作为底层发现和调度机制。描述JGroups的特性有太多的参考指南,请参阅JGroups用户指南以了解更多的细节。</p><a id="more"></a><p>因为JGroups既处理节点的发现又处理它们之间的通信，所以JGroupsConnector既充当CommandBusConnector也充当CommandRouter。</p><blockquote><p><b>注意</b><br>你可以在axon-distributed-commandbus-jgroups模块中，为DistributedCommandBus找到JGroups特定组件。</p></blockquote><p>JGroupsConnector有四个强制性配置元素：</p><ul><li>第一种是JChannel，它定义了JGroups协议栈。一般来说，用JGroups配置文件的引用构造JChannel。JGroups附带的默认配置,可以用作自己配置的依据。请记住，IP多路广播一般不工作在云服务中，像亚马逊。中这种类型的环境中， TCP Gossip通常是一个好的开端。</li><li>集群名称定义了每个segment应登记到的集群的名称。具有相同的集群名称的Segment最终会探测到彼此，并在彼此间分发命令。</li><li>“本地segment”是命令总线实现，分发命令去往本地的JVM。这些命令可能已通过其他JVM或从本地的一个实例分发。</li><li>最后，序列化器是用来序列化之前通过线路发送的命令消息。</li></ul><blockquote><p><b>注意</b><br>当使用缓存时，当ConsistentHash更改以避免潜在的数据损坏时，它应该被清空（例如，当命令没有指定一个@TargetAggregateVersion和新成员快速加入和离开JGroup，修改聚合然而它还要缓存到其他地方）。</p></blockquote><p>最终，JGroupsConnector需要实际连接，按顺序分发消息到其他segment。这样做，调用connect()方法。</p><pre>JChannel channel = new JChannel("path/to/channel/config.xml");CommandBus localSegment = new SimpleCommandBus();Serializer serializer = new XStreamSerializer();JGroupsConnector connector = new JGroupsConnector(channel, "myCommandBus", localSegment, serializer);DistributedCommandBus commandBus = new DistributedCommandBus(connector, connector);// on one node:commandBus.subscribe(CommandType.class.getName(), handler);connector.connect();// on another node, with more CPU:commandBus.subscribe(CommandType.class.getName(), handler);commandBus.subscribe(AnotherCommandType.class.getName(), handler2);commandBus.updateLoadFactor(150); // defaults to 100connector.connect();// from now on, just deal with commandBus as if it is local...</pre><blockquote><p><b>注意</b><br>注意，并非所有的segment都必需具有相同类型的命令的命令处理器。你完全可以为不同的命令类型使用不同的segment。分布式命令总线总是选择一个节点分发命令到那个支持特定类型的命令。</p></blockquote><p>如果你使用Spring，你可能需要考虑使用JGroupsConnectorFactoryBean。它自动连接连接器当ApplicationContext启动后，并且在ApplicationContext关闭时完全的断开。此外,它为测试环境使用合理的默认值(但不应被视为生产准备)和自动装配配置。</p><h2 id="Spring-Cloud-Connector"><a href="#Spring-Cloud-Connector" class="headerlink" title="Spring Cloud Connector"></a>Spring Cloud Connector</h2><p>Spring Cloud连接器装置，用Spring Cloud来描述使用服务注册和发现机制来分配命令总线。因此，你可以自由选择使用哪一个Spring Cloud实现用来分发你的命令。实现的一个例子是 Eureka Discovery/Eureka 服务器组合。</p><blockquote><p><b>注意</b><br>当前版本(Axon 3.0.4)SpringCloudCommandRouter使用ServiceInstance。Metadata 字段来通知所有系统中的节点，通过CommandNameFilter它可以处理命令。这是很重要的,Spring Cloud实现选择支持ServiceInstance.Metadata字段的使用。例如Spring Cloud Consul目前不支持该字段，因此SpringCloudCommandRouter并不是一个可行的解决方案。我们正在研究一个额外的解决方案，从中检索CommandNameFilter 。</p></blockquote><p>提供每个SpringCloud实现的描述将推动本参考指南。因此，我们参考他们各自的文件以获得进一步的信息。</p><p>Spring Cloud连接器装置是一个SpringCloudCommandRouter和SpringHttpCommandBusConnector的组合，分别填充CommandRouter的地点和 DistributedCommandBus的CommandBusConnector。</p><blockquote><p><b>注意</b><br>Spring Cloud连接器特定的组件DistributedCommandBus可以在axon-distributed-commandbus-springcloud模块中找到 。</p></blockquote><p>SpringCloudCommandRouter必须由以下提供的来创建：</p><ul><li>一个DiscoveryClient类型“discovery client”。这可以通过用@EnableDiscoveryClient注解你的Spring Boot应用程序来提供,将在你的类路径中寻找Spring Cloud 的实现。</li><li>一个RoutingStrategy类型的”routing strategy”。目前axon-core模块提供了一些实现，但是一函数调用也可以满足要求。例如，如果你想路由命令基于“聚合标识符”，你可以使用AnnotationRoutingStrategy和注解有效载荷的字段，用@TargetAggregateIdentifier识别聚合。</li></ul><p>SpringHttpCommandBusConnector需要创建三个参数:</p><ul><li>一个CommandBus类型的“local command bus”。这是命令总线实现，它将分发命令到本地的JVM。这些命令可能是由其他JVM上的或本地的实例分发。</li><li>RestOperations对象来执行一个命令消息的发布到另一个实例。</li><li>最后一个Serializer类型的“序列serializer”。序列化器用于在命令发送到网络之前序列化命令消息。</li></ul><p>SpringCloudCommandRouter和SpringHttpCommandBusConnector应该都被用于创建DistributedCommandsBus。在Spring Java 配置中，看起来如下:</p><pre>// Simple Spring Boot App providing the `DiscoveryClient` bean@EnableDiscoveryClient@SpringBootApplicationpublic class MyApplication {    public static void main(String[] args) {        SpringApplication.run(MyApplication.class, args);    }    // Example function providing a Spring Cloud Connector    @Bean    public CommandRouter springCloudCommandRouter(DiscoveryClient discoveryClient) {        return new SpringCloudCommandRouter(discoveryClient, new AnnotationRoutingStrategy());    }    @Bean    public CommandBusConnector springHttpCommandBusConnector(@Qualifier("localSegment") CommandBus localSegment,                                                             RestOperations restOperations,                                                             Serializer serializer) {        return new SpringHttpCommandBusConnector(localSegment, restOperations, serializer);    }    @Primary // to make sure this CommandBus implementation is used for autowiring    @Bean    public DistributedCommandBus springCloudDistributedCommandBus(CommandRouter commandRouter,                                                                   CommandBusConnector commandBusConnector) {        return new DistributedCommandBus(commandRouter, commandBusConnector);    }}// if you don't use Spring Boot Autoconfiguration, you will need to explicitly define the local segment:@Bean@Qualifier("localSegment")public CommandBus localSegment() {    return new SimpleCommandBus();}</pre><blockquote><p><b>注意</b><br>注意，并非所有的segment都必需具有相同类型的命令的命令处理器。你完全可以为不同的命令类型使用不同的segment。分布式命令总线总是选择一个节点分发命令到那个支持特定类型的命令。</p></blockquote><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/ccef9924f8d7" target="_blank" rel="noopener">https://www.jianshu.com/p/ccef9924f8d7</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JGroupsConnector&quot;&gt;&lt;a href=&quot;#JGroupsConnector&quot; class=&quot;headerlink&quot; title=&quot;JGroupsConnector&quot;&gt;&lt;/a&gt;JGroupsConnector&lt;/h2&gt;&lt;p&gt;JGroupsConnector使用(正如它的名字已经说明)JGroups作为底层发现和调度机制。描述JGroups的特性有太多的参考指南,请参阅JGroups用户指南以了解更多的细节。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework命令拦截器</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%91%BD%E4%BB%A4%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-命令拦截器/</id>
    <published>2018-08-31T02:29:32.000Z</published>
    <updated>2018-09-04T09:24:40.234Z</updated>
    
    <content type="html"><![CDATA[<p>使用命令总线的优点之一，是能够基于所有传入的命令采取相应的行动。例子是，不论哪种命令类型，你都希望去做日志记录或身份验证。这是使用拦截器来完成的。</p><a id="more"></a><p>有不同类型的拦截器：Dispatch拦截器和Handler拦截器。前者在命令被分发到命令处理程序之前被调用。在那时，它甚至不能确定该命令有任何处理器的存在。后者在命令处理程序被调用之前调用。</p><h2 id="Message-Dispatch-Interceptors（消息分发拦截器）"><a href="#Message-Dispatch-Interceptors（消息分发拦截器）" class="headerlink" title="Message Dispatch Interceptors（消息分发拦截器）"></a>Message Dispatch Interceptors（消息分发拦截器）</h2><p>当命令在命令总线上被分发时调用消息分发拦截器。例如，它们可以通过添加元数据来更改命令消息，或通过抛出异常来阻塞命令。这些拦截器总是在分发命令的线程上被调用。</p><p>##Structural validation（结构性验证）</p><p>如果它没有包含正确格式的所有必需的信息，那么处理命令是没有意义的,。事实上，一个命令缺乏信息应该尽可能早地被阻塞，甚至最好是任何事务开始之前。因此，拦截器应该检查所有传入命令的信息的可用性。这就是所谓的结构性验证。</p><p>Axon Framework支持基于JSR 303 Bean Validation的验证。这允许你用像@NotEmpty和@Pattern这样的注解，去注解命令上的字段。你需要在你的类路径中include一个JSR 303实现(比如Hibernate-Validator)。然后，在命令总线上配置一个BeanValidationInterceptor，它会自动找到并配置你的验证器实现。虽然它使用合理的默认值，但你可以根据具体需要调整它。</p><blockquote><p><b>提示</b><br>你想在一个无效的命令上使用尽可能少的资源。因此，该拦截器通常是位于拦截器链的最前端。在某些情况下，一个日志或审计拦截器可能需要放在前面，紧跟着它的是验证拦截器。</p></blockquote><p>BeanValidationInterceptor还实现了MessageHandlerInterceptor，也允许你把它配置为一个处理程序（Handler）拦截器。</p><h2 id="Message-Handler-Interceptors（消息处理程序拦截器）"><a href="#Message-Handler-Interceptors（消息处理程序拦截器）" class="headerlink" title="Message Handler Interceptors（消息处理程序拦截器）"></a>Message Handler Interceptors（消息处理程序拦截器）</h2><p>消息处理程序拦截器可以在命令处理之前和之后执行操作。拦截器甚至可以完全阻止命令处理，例如出于安全原因。</p><p>拦截器必须实现MessageHandlerInterceptor接口。该接口声明了一个方法handle，它需要三个参数：命令消息，当前的UnitOfWork和InterceptorChain。InterceptorChain用于继续分发处理。</p><p>与分发拦截器不同，处理程序拦截器在命令处理程序上下文中被调用。这意味着它们可以根据正在处理消息的工作单元附上相关数据。然后这个相关数据将被附加到在工作单元的上下文中被创建的消息。</p><p>处理程序拦截器也通常用于管理围绕命令处理的事务。这么做，注册一个TransactionManagingInterceptor，使用TransactionManager依次配置启动和提交(或回滚)实际事务。</p><h2 id="Distributing-the-Command-Bus-分布式命令总线"><a href="#Distributing-the-Command-Bus-分布式命令总线" class="headerlink" title="Distributing the Command Bus(分布式命令总线)"></a>Distributing the Command Bus(分布式命令总线)</h2><p>CommandBus的实现在早期声称只允许命令消息在单个JVM上分发。有时候，你想把不同JVM中的命令总线的多个实例作为一个。当返回任何结果时，在一个JVM命令总线上发出的命令应该无缝地传到到另一个JVM中的命令处理程序。</p><p>这就是DistributedCommandBus（分布式命令总线）的由来。不像其他CommandBus的实现，DistributedCommandBus不调用任何处理器。它的作用是在不同的JVM的命令总线实现之间形成一座“桥”。每个JVM上的DistributedCommandBus实例称为“Segment”。</p><blockquote><p><b>注意</b><br>虽然分布式命令总线本身是Axon Framework核心模块的一部分，但它需要的组件，你可以在其中一个以axon-distributed-commandbus -开头的模块中找到。如果你使用Maven，确保你有适当的依赖集。groupId和version与核心模块相同。</p></blockquote><p>DistributedCommandBus依赖于两个组件：一个是CommandBusConnector，实现JVM的之间的通信协议；一个是CommandRouter，为每个传入的命令选择目的地。这个路由器定义分布式总线命令的segment应该given一个命令，根据路由键计算得到路由策略。两个具有相同路由键的命令将始终路由到相同的segment，只要segment数量和配置没有改变。一般来说，用目标聚合的标识符作为路由键。</p><p>提供两个RoutingStrategy的实现：MetaDataRoutingStrategy，它使用元数据属性在命令消息中查找路由键，而AnnotationRoutingStrategy，它使用注解在命令消息有效负载上的@TargetAggregateIdentifier来提取路由键。显然，你也可以提供自己的实现。</p><p>默认情况下，当命令消息没有键能被解析时，RoutingStrategy实现将抛出一个异常时。这种行为可以改变，通过在MetaDataRoutingStrategy或AnnotationRoutingStrategy的构造函数中提供一个UnresolvedRoutingKeyPolicy。有三个可能的策略:</p><ul><li>ERROR:这是默认值，当路由键不可用时，会抛出一个异常。</li><li>RANDOM_KEY：将返回一个随机值，当一个路由键不能从命令消息解析。这实际上意味着这些命令将被路由到命令总线的随机segment。</li><li>STATIC_KEY:将返回一个静态键(现有的“未被解析的”)为未被解析的路由键。这实际上意味着所有这些命令将被路由到相同的segment，只要segment的配置不改变。</li></ul><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/d603a00bc5cc" target="_blank" rel="noopener">https://www.jianshu.com/p/d603a00bc5cc</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用命令总线的优点之一，是能够基于所有传入的命令采取相应的行动。例子是，不论哪种命令类型，你都希望去做日志记录或身份验证。这是使用拦截器来完成的。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework命令总线</title>
    <link href="http://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF/"/>
    <id>http://blog.weechang.xyz/2018/08/31/AxonFramework-命令总线/</id>
    <published>2018-08-31T02:25:51.000Z</published>
    <updated>2018-09-04T09:24:40.231Z</updated>
    
    <content type="html"><![CDATA[<p>命令总线是将命令分发给各自的命令Handler的机制。每个命令总是被精确发送到一个命令Handler。如果没有可用的命令Handler为已分发的命令，将会抛出NoHandlerForCommandException异常。对同一命令类型订阅多个命令Handler将导致订阅互相取代。在这种情况下，最后一个订阅获胜。</p><a id="more"></a><h2 id="分发命令"><a href="#分发命令" class="headerlink" title="分发命令"></a>分发命令</h2><p>CommandBus提供了两个方法去分发命令到它们各自的Handler：dispatch(commandMessage,callback)和dispatch(commandMessage)。第一个参数是一个包含要发送的实际命令的消息。第二个可选的参数接收一个回调，允许在命令处理完成时通知分发组件。这个回调有两个方法:onSuccess()和onFailure()，分别会在命令处理返回后被调用，或者当它抛出一个异常时调用。</p><p>调用组件可能不采取在分发命令的同一线程中调用回调。如果调用线程在继续之前依赖于结果，你可以使用FutureCallback。这是一个Future(在java.concurrent包中定义)和Axon的CommandCallback的组合。或者，考虑使用命令网关。</p><p>如果一个应用程序不直接对命令的结果感兴趣，可以使用dispatch(commandMessage) 方法。</p><h2 id="SimpleCommandBus"><a href="#SimpleCommandBus" class="headerlink" title="SimpleCommandBus"></a>SimpleCommandBus</h2><p>SimpleCommandBus，顾名思义，最简单的实现。它在分发它们的线程中简单的处理命令。命令处理后，修改后的聚合在同一线程被保存和发布生成的事件。在大多数情况下，如web应用程序，该实现将符合你的需求。配置API中SimpleCommandBus是默认使用的实现。</p><p>像大多数CommandBus实现一样，SimpleCommandBus允许拦截器进行配置。在命令总线上分发一个命令后调用CommandDispatchInterceptors。在实际的命令handler 方法之前调用CommandHandlerInterceptors，允许你修改或阻塞命令。有关更多信息，请参考命令处理器拦截器。</p><p>因为所有命令处理都在同一线程中完成，这个实现仅限于JVM的边界。这个实现的性能是很好的，但不超凡。跨JVM边界，或使你的CPU cycles发挥最大的功效，看看其他CommandBus实现。</p><h2 id="AsynchronousCommandBus"><a href="#AsynchronousCommandBus" class="headerlink" title="AsynchronousCommandBus"></a>AsynchronousCommandBus</h2><p>顾名思义，AsynchronousCommandBus实现从分发它们的线程异步执行命令。它使用一个Executor在不同的线程来执行实际的处理逻辑。</p><p>默认情况下，AsynchronousCommandBus使用一个unbounded缓存的线程池。这意味着分发一个命令时会创建线程。完成处理命令的线程将被重新用于新命令。如果60秒线程没有处理命令，则会停止线程。</p><p>或者，Executor实例可以提供不同的线程策略配置。</p><p>注意，应用程序停止时应该关闭AsynchronousCommandBus，以确保任何等待线程正确关闭。关闭，调用shutdown()方法。这也将关闭任何Executor实例，如果它实现ExecutorService接口的话。</p><h2 id="DisruptorCommandBus"><a href="#DisruptorCommandBus" class="headerlink" title="DisruptorCommandBus"></a>DisruptorCommandBus</h2><p>SimpleCommandBus具有合理的性能特性，特别是当你经历了性能调优技巧。事实上，SimpleCommandBus需要锁来防止多个线程并发访问同一聚合，导致处理开销和锁争用。</p><p>DisruptorCommandBus采用不同的方法进行多线程处理。不是多个线程每个都执行同样的处理，而是有多个线程，每个负责一件处理。DisruptorCommandBus使用Disruptor，一个小的并发编程框架，通过不同的方法对多线程进行处理来实现更好的性能。任务不是在调用线程中进行处理，而是将任务移交给两组线程进行处理，每组线程负责一部分处理。第一组的线程将执行命令handler，更改一个聚合的状态。第二组将存储并将事件发布到事件存储。</p><p>虽然DisruptorCommandBus轻易优于SimpleCommandBus 4倍(!)，但有一些限制:</p><ul><li>DisruptorCommandBus仅支持事件溯源聚合。这个命令总线充当由Disruptor处理聚合的存储库。获取一个存储库的引用，使用createRepository(AggregateFactory)。</li><li>一个命令只能导致一个聚合实例状态变化。</li><li>当使用缓存时，它只允许给定的标识符为单个聚合。这意味着它是不可能有两个具有相同的标识符的不同类型的聚合。</li><li>命令一般不会引发需要回滚工作单元的故障。当发生回滚时，DisruptorCommandBus不能保证命令按照它们被分发的顺序进行处理。此外，它需要重试其他命令，从而造成不必要的计算。</li><li><p>在创建一个新的聚合实例时，命令更新所创建实例可能并不完全按照所提供的顺序进行。一旦创建了聚合，所有命令将按照它们被分发顺序执行。为了确保顺序，在创建命令上使用回调去等待正在创建的聚合。它不应该耗时超过几毫秒。<br>构建一个DisruptorCommandBus实例，你需要一个EventStore。该组件在Repositories and Event Stores中有解释。<br>或者，你可以提供一个DisruptorConfiguration实例，它允许你调整配置优化你的特定环境下的性能：</p></li><li><p>Buffer size:在ringBuffer上注册传入命令的槽数。更高的值可能会增加吞吐量,但也导致更高的延迟。必须是2的次方数，默认为4096。</p></li><li>ProducerType: 表示条目是由单线程或多线程生成的。默认为多线程。</li><li>WaitStrategy：当处理器线程（三个线程负责的实际处理）需要等待对方时使用的策略。最好的WaitStrategy取决于机器上可用的处理器数量，和正在运行的其他进程的数量。如果低延迟是至关重要的，DisruptorCommandBus可以自己认领内核，你可以使用BusySpinWaitStrategy。为了使命令总线索取更少的CPU并且允许其他线程处理，使用YieldingWaitStrategy。最后，你可以使用SleepingWaitStrategy和BlockingWaitStrategy允许其他进程共享CPU。如果命令总线不需要进行专职处理，则后者是合适的。默认为BlockingWaitStrategy。</li><li>Executor：设置Executor为DisruptorCommandBus提供线程。这个Executor必须能够提供至少4个线程。其中的3个线程，由DisruptorCommandBus的处理组件认领。额外的线程用于调用回调函数，并计划重试以防检测到错误的聚合状态。默认是CachedThreadPool提供线程从一个称为“DisruptorCommandBus”的线程组中。</li><li>TransactionManager：定义了事务管理器，应该确保存储和事件发布以事务的方式执行。</li><li>InvokerInterceptors:定义了在调用处理中使用的CommandHandlerInterceptors。这个处理调用实际的命令处理器方法。</li><li>PublisherInterceptors:定义了在发布处理中使用的CommandHandlerInterceptors。这个发布处理存储和发布生成的事件。</li><li>RollbackConfiguration:定义工作单元应该回滚的异常。默认配置为回滚未经检查的异常。</li><li>RescheduleCommandsOnCorruptState:指示已经执行过命令但损坏的聚合(如:因为一个工作单元是回滚)是否应该重新计划。如果为假，回调的onFailure()方法将被调用。如果为的(默认),命令将被重新计划。</li><li>CoolingDownPeriod:设置等待的秒数，以确保所有命令被处理。在冷却期间，不接受新命令，但是现有的命令仍然处理，并在必要时重新计划。冷却期间确保线程可供重新安排命令和调用回调之用。默认为1000(1秒)。</li><li>缓存:设置缓存存储从Event Store中恢复的聚合实例。缓存用disruptor存储不活跃的聚合实例。</li><li>InvokerThreadCount:给命令处理器的调用分配线程的数量。一个好的起始点是机器内核数量的一半。</li><li>PublisherThreadCount:用于发布事件的线程数量。一个好的起始点是一半的内核数量，如果IO上花费大量的时间，可以增加。</li><li>SerializerThreadCount:使用pre-serialize事件的线程数量。默认为1，但如果没有配置序列化器将被忽略。</li><li>Serializer:用于执行pre-serialization的序列化器。当配置序列化器时，DisruptorCommandBus将包装所有生成的事件在一个SerializationAware消息上。附加有效负载和元数据的序列化形式，在发布到事件存储之前。</li></ul><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/6aee33abd7f0" target="_blank" rel="noopener">https://www.jianshu.com/p/6aee33abd7f0</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;命令总线是将命令分发给各自的命令Handler的机制。每个命令总是被精确发送到一个命令Handler。如果没有可用的命令Handler为已分发的命令，将会抛出NoHandlerForCommandException异常。对同一命令类型订阅多个命令Handler将导致订阅互相取代。在这种情况下，最后一个订阅获胜。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-测试带注解的Saga</title>
    <link href="http://blog.weechang.xyz/2018/08/29/AxonFramework-%E6%B5%8B%E8%AF%95%E5%B8%A6%E6%B3%A8%E8%A7%A3%E7%9A%84Saga/"/>
    <id>http://blog.weechang.xyz/2018/08/29/AxonFramework-测试带注解的Saga/</id>
    <published>2018-08-29T03:30:56.000Z</published>
    <updated>2018-09-04T09:24:40.251Z</updated>
    
    <content type="html"><![CDATA[<p>与命令处理组件类似，saga有一个明确定义的接口：它们只对事件作出响应。另一方面，saga通常具有时间概念，并且可以作为事件处理过程的一部分与其他组件交互。Axon Framework的测试支持模块包含帮助你编写saga测试的固件。</p><a id="more"></a><p>每个测试固件包含三个阶段，类似于前面部分描述的命令处理组件固件。</p><ul><li>given 某些事件(从某些聚合),</li><li>when事件到达或时间流逝，</li><li>expect某些行为或状态。</li></ul><p>“given ”和“when”阶段都接受事件作为它们交互的一部分。在“given”阶段，可能会忽略所有副作用，如生成的命令。在“when”阶段，另一方面，从被记录和被验证的saga生成事件和命令。</p><pre>FixtureConfiguration fixture = new SagaTestFixture(InvoicingSaga.class);fixture.givenAggregate(invoiceId).published(new InvoiceCreatedEvent())        .whenTimeElapses(Duration.ofDays(31))        .expectDispatchedCommandsMatching(Matchers.listWithAllOf(aMarkAsOverdueCommand()));        // or, to match against the payload of a Command Message only        .expectDispatchedCommandsMatching(Matchers.payloadsMatching(Matchers.listWithAllOf(aMarkAsOverdueCommand())));</pre><p>saga可以分发命令使用一个回调函数通知命令处理的结果。由于在测试中没有实际的命令处理完成，该行为使用CallbackBehavior对象定义。这个对象使用setCallbackBehavior()在固件上注册，并定义当一个命令被分发后，是否和如何必须调用回调函数。</p><p>不是直接使用CommandBus，而是你还可以使用命令网关。见下文如何规定他们的行为。</p><p>通常，saga将与资源交互。这些资源不是saga状态的一部分，但在saga加载和创建后被注入。测试固件允许你注册需要被注入到saga中的资源。要注册一个资源，只需用资源作为参数调用fixture.registerResource(Object)方法。固件将在saga上检测合适的setter方法或字段(带有@Inject注解)并用一个可用的资源调用它。</p><blockquote><p><b>提示</b><br>注入模拟对象(例如Mockito或Easymock)到你的saga，可能是非常有益的。它允许你验证saga与外部资源的正确交互。</p></blockquote><p>命令网关为saga提供了一个更简单的方式来调度命令。使用自定义命令网关还可以更容易地创建模拟或桩来定义其在测试中的行为。然而，当提供一个模拟或桩时，实际的命令可能不不会被分发，因此无法验证测试固件中发送的命令。</p><p>因此，固件提供了两个方法，让你注册命令网关和一个可选的模拟定义其行为:registerCommandGateway(Class)和registerCommandGateway(Class, Object)。这两种方法都返回一个given类的实例，表示要使用的网关。这个实例也注册为资源，使它具有资源注入的资格。</p><p>当registerCommandGateway(Class)用来注册一个网关时，它分发命令到由固件管理的CommandBus。网关的行为主要是通过CallbackBehavior定义于固件。如果没有提供明确的CallbackBehavior，回调不调用，从而无法为网关提供任何返回值。</p><p>当registerCommandGateway(Class, Object)是用来注册一个网关，第二个参数是用于定义网关的行为。</p><p>测试固件试图尽可能消除系统时间迁延。这意味着它将会在测试执行时显得没有时间迁延。除非你显式地声明使用whenTimeElapses()。所有事件都将拥有测试固件创建那一刻的时间戳。</p><p>在测试期间暂停时间，可以更容易地预测在什么时间计划发布事件。如果你的测试用例验证一个事件在30秒后计划发布，它将保持30秒，而不管实际调度和测试执行之间的时间。</p><blockquote><p><b>注意</b><br>固件使用StubScheduler作为基于时间的活动，如调度事件和推进时间。固件将发送到saga实例的任何事件的时间戳设置为这个scheduler的时间。这意味着一旦固件开始，时间就“stopped”，并可能提前确定使用whenTimeAdvanceTo和whenTimeElapses方法。</p></blockquote><p>你还可以使用与测试固件无关的StubEventScheduler，如果你需要测试事件的调度。这个EventScheduler实现允许你验证哪个事件被安排在哪个时间，并且给你选择操纵时间的进展。你可以将时间提前到一个特定的时间，将时钟移动到一个特定的日期和时间，或者将时间提前到下一个计划的事件。所有这些操作将返回进度间隔内计划的事件。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/49429788e7da" target="_blank" rel="noopener">https://www.jianshu.com/p/49429788e7da</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与命令处理组件类似，saga有一个明确定义的接口：它们只对事件作出响应。另一方面，saga通常具有时间概念，并且可以作为事件处理过程的一部分与其他组件交互。Axon Framework的测试支持模块包含帮助你编写saga测试的固件。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework测试</title>
    <link href="http://blog.weechang.xyz/2018/08/29/AxonFramework-%E6%B5%8B%E8%AF%95/"/>
    <id>http://blog.weechang.xyz/2018/08/29/AxonFramework-测试/</id>
    <published>2018-08-29T02:30:35.000Z</published>
    <updated>2018-09-04T09:24:40.249Z</updated>
    
    <content type="html"><![CDATA[<p>CQRS最大的好处之一，尤其是事件溯源就事件和命令而言，单纯地表达测试是可能的。这两个功能组件，事件和命令对领域专家或业务所有者都有明确的含义。这不仅意味着测试表达就事件和命令而言有明确的功能含义，这也意味着他们不依靠任何实现选择。</p><a id="more"></a><p>本章描述的特性需要axon-test模块,可通过配置maven依赖(使用<artifactid>axon-test</artifactid> 和<scope>test&lt;/scope)或通过完整包下载。</scope></p><p>本章中描述的固件可用于任何测试框架，如JUnit和TestNG。</p><h2 id="命令组件测试"><a href="#命令组件测试" class="headerlink" title="命令组件测试"></a>命令组件测试</h2><p>在任何CQRS基础架构中命令处理组件通常是最复杂的。比其他组件更复杂，这也意味着该组件有额外的与测试相关的需求。</p><p>虽然更复杂，但是命令的API处理组件相当容易。它有一个命令进来，然后事件出去。在某些情况下，可能有一个查询作为命令执行的一部分。除此之外，命令和事件是API的唯一部分。这意味着可以在事件和命令的基础上完整地定义测试场景。典型地，以：</p><ul><li>given过去的某些事件，</li><li>when 执行这个命令，</li><li>expect 这些事件将被发布和/或存储</li></ul><p>Axon Framework提供了一个测试固件，使你能够做到这一点。AggregateTestFixture允许你配置某些基础设施，包括必要的命令处理器和存储库，并以given-when-then形式的事件和命令来表达你的场景。</p><p>下面的示例展示了用JUnit 4对given-when-then测试固件的使用：</p><pre>public class MyCommandComponentTest { private FixtureConfiguration fixture; @Before public void setUp() {     fixture = new AggregateTestFixture(MyAggregate.class); } @Test public void testFirstFixture() {     fixture.given(new MyEvent(1))            .when(new TestCommand())            .expectSuccessfulHandlerExecution()            .expectEvents(new MyEvent(2));     /*     These four lines define the actual scenario and its expected     result. The first line defines the events that happened in the     past. These events define the state of the aggregate under test.     In practical terms, these are the events that the event store     returns when an aggregate is loaded. The second line defines the     command that we wish to execute against our system. Finally, we     have two more methods that define expected behavior. In the     example, we use the recommended void return type. The last method     defines that we expect a single event as result of the command     execution.     /* }}</pre><p>given-when-then测试固件定义了三个阶段：配置、执行和验证。每个阶段由不同的接口表示：分别是，FixtureConfiguration, TestExecutor 和 ResultValidator。固件类的静态newGivenWhenThenFixture()方法提供了对第一个的引用，进而可能提供验证，等等。</p><blockquote><p><b>注意</b><br>为了最好地利用这些阶段之间的迁移，最好使用这些方法提供的流式接口，如上面的示例所示。</p></blockquote><p>在配置阶段（即在提供第一个“given”之前），你提供了执行测试所需的构件。作为固件的一部分提供事件总线、命令总线和事件存储的专用版本。有accessor方法来获得对它们的引用。任何命令处理器不直接在聚合上注册，需要显式地使用registerAnnotatedCommandHandler 方法配置。除了带注解的命令处理器外，你还可以配置各种组件和设置，定义应该如何设置测试周围的基础设施。</p><p>一旦固件配置好，你就可以定义“given”事件。测试固件将用DomainEventMessage包装这些事件。如果“given”事件实现消息，消息的有效负载和元数据将被纳入DomainEventMessage，否则given事件作为有效负载。DomainEventMessage 的序列号顺序，从0开始。</p><p>或者，你也可以为“given”场景提供命令。在这种情况下，在执行实际的测试命令时，这些命令生成的事件将被用于事件源聚合。使用“givenCommands(…)”方法提供命令对象。</p><p>执行阶段允许你提供一个针对命令处理组件执行的命令。对调用处理程序的行为(无论是在聚合或外部处理程序)进行监控，并与在验证阶段注册的预期进行比较。</p><blockquote><p><b>注意</b><br>在执行测试过程中，Axon试图检测测试中的所有在聚合上的非法状态的更改。它通过将聚合的状态与命令执行后的聚合状态进行比较，如果它从所有“given”和存储的事件溯源。如果状态不相同，这意味着状态变化发生在聚合事件处理器方法之外。比较时将忽略静态和瞬态字段，因为它们通常包含对资源的引用。<br>可以使用setReportIllegalStateChange方法在固件的配置中切换检测。</p></blockquote><p>最后一个阶段是验证阶段，允许你检查命令处理组件的活动。这完全是根据返回值和事件来完成的。</p><p>测试固件允许你验证命令处理程序的返回值。你可以显式地定义预期的返回值，或者简单地要求成功返回该方法。你也可以表达任何你期望的CommandHandler抛出的异常。</p><p>另一个组件是对已发布事件的验证。有两种匹配预期事件的方法。</p><p>第一是通过事件实例，它需要与实际的事件是行逐字的比较。将预期事件的所有属性与实际事件中的对应对象进行比较（使用equals()）。如果其中一个属性不相等，则测试失败，并生成一个广泛的错误报告。</p><p>表达期望的另一种方式是使用的匹配器(Hamcrest库提供的)。匹配器接口规定了两个方法matches(Object)和describeTo(Description)。第一个返回一个布尔值，指示是否匹配或不匹配。第二个让你表达你的期望。例如，一个“GreaterThanTwoMatcher”可以添加“任何值大于2的事件“的描述。描述允许创建关于测试用例失败的错误消息。</p><p>创建事件列表的匹配器可能是繁琐和容易出错的工作。为了简化问题，Axon提供了一组匹配器允许你提供一组特定于事件的匹配器，并告诉Axon应该如何匹配列表。</p><p>下面是可用的事件列表匹配器和他们的目的的概述：</p><ul><li><p>List with all of: Matchers.listWithAllOf(event matchers…)<br>如果所有的事件匹配器与真实事件列表中至少一个事件匹配，该匹配器将成功。不管是否有多个匹配器匹配相同的事件，或如果列表中一个事件不匹配任何匹配器。</p></li><li><p>List with any of: Matchers.listWithAnyOf(event matchers…)<br>如果一个或多个事件匹配器与实际的事件列表中一个或多个事件匹配，该匹配器将成功。一些匹配器甚至一个也不匹配，而另一个匹配多个。</p></li><li><p>Sequence of Events: Matchers.sequenceOf(event matchers…)<br>使用此匹配器来验证实际事件匹配器和提供的事件匹配器有相同的顺序。如果匹配器与后一个事件相匹配，与前一个匹配器匹配的事件相匹配，该匹配器将成功。这意味着可能出现不匹配事件的“gaps”。<br>如果评估事件之后，更多的匹配器是可用的，他们都是匹配“null”。它是由事件的匹配器来决定是否接受。</p></li><li><p>Exact sequence of Events: Matchers.exactSequenceOf(event matchers…)<br>“事件的序列”匹配器的变化不允许不匹配事件的空隙。这意味着每个匹配器必须与事件后面的事件相匹配，与前一个匹配器匹配的事件相匹配。每个匹配器都应该与它前一个匹配器相对应的事件的后续一个事件相匹配</p></li></ul><p>为了方便起见,提供了一些普遍需要的事件匹配器。他们与单个事件实例相匹配:</p><ul><li><p>Equal Event: Matchers.equalTo(instance…)<br>验证given对象在语义上等于given事件，这个匹配器将比较实际和预期的对象的所有字段的值使用一个null-safe相等方法。这意味着可以比较事件，即使它们不实现equals方法。存储在given参数字段上的对象用equals进行比较，要求他们正确实现。</p></li><li><p>No More Events: Matchers.andNoMore() or Matchers.nothing()<br>仅与空值匹配，这个匹配器可以作为最后一个匹配器添加到事件的准确顺序匹配器,以确保没有不匹配的事件依然存在。</p></li></ul><p>由于匹配器传递一个事件消息列表，有时你只是想验证消息的有效负载。有匹配器来帮助你:</p><ul><li><p>Payload Matching: Matchers.messageWithPayload(payload matcher)<br>验证消息的有效负载匹配给定的有效载荷匹配器。</p></li><li><p>Payloads Matching: Matchers.payloadsMatching(list matcher)<br>验证消息的有效负载匹配给定的有效载荷匹配器。给定的匹配器必须匹配列表包含的每个消息的有效负载。有效负载匹配匹配器通常用作外匹配器,以防止重复有效负载匹配器。</p></li></ul><p>下面是一个简单的代码示例，以显示这些匹配器的使用。在这个例子中,我们预期共有两个事件发布。第一个事件必须是一个“ThirdEvent”，第二个是“aFourthEventWithSomeSpecialThings”。可能没有第三个事件，因为那样”andNoMore”匹配器会失败。</p><pre>fixture.given(new FirstEvent(), new SecondEvent())       .when(new DoSomethingCommand("aggregateId"))       .expectEventsMatching(exactSequenceOf(           // we can match against the payload only:           messageWithPayload(equalTo(new ThirdEvent())),           // this will match against a Message           aFourthEventWithSomeSpecialThings(),           // this will ensure that there are no more events           andNoMore()       ));// or if we prefer to match on payloads only:       .expectEventsMatching(payloadsMatching(               exactSequenceOf(                   // we only have payloads, so we can equalTo directly                   equalTo(new ThirdEvent()),                   // now, this matcher matches against the payload too                   aFourthEventWithSomeSpecialThings(),                   // this still requires that there is no more events                   andNoMore()               )       ));</pre><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/2e893c9d48bf" target="_blank" rel="noopener">https://www.jianshu.com/p/2e893c9d48bf</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CQRS最大的好处之一，尤其是事件溯源就事件和命令而言，单纯地表达测试是可能的。这两个功能组件，事件和命令对领域专家或业务所有者都有明确的含义。这不仅意味着测试表达就事件和命令而言有明确的功能含义，这也意味着他们不依靠任何实现选择。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-Saga的基础设施</title>
    <link href="http://blog.weechang.xyz/2018/08/29/AxonFramework-Saga%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    <id>http://blog.weechang.xyz/2018/08/29/AxonFramework-Saga的基础设施/</id>
    <published>2018-08-29T02:17:20.000Z</published>
    <updated>2018-09-04T09:24:40.206Z</updated>
    
    <content type="html"><![CDATA[<p>事件需要被重定向到适当的saga实例。为此,一些基础设施类是必需的。最重要的组件是SagaManager和SagaRepository。</p><a id="more"></a><h2 id="Saga-Manager"><a href="#Saga-Manager" class="headerlink" title="Saga Manager"></a>Saga Manager</h2><p>与处理事件的任何组件一样，processing也是由事件处理器完成的。然而，因为saga不是单例实例处理事件，但是有独特的生命周期，它们需要管理。</p><p>Axon通过AnnotatedSagaManager来支持生命周期管理，这是提供给一个事件Processor来执行处理器的实际的调用。它的初始化使用saga的类型来管理，也使用可以存储和恢复的SagaRepository这种saga类型。一个AnnotatedSagaManager只能管理一个saga类型。</p><p>当使用配置API时，Axon将对大多数组件使用合理的默认设置。不管怎样，强烈建议定义一个SagaStore的实现使用。SagaStore是在某处物理存储saga实例的机制，AnnotatedSagaRepository(默认)要求它们使用SagaStore去存储和检索saga实例。</p><pre>Configurer configurer = DefaultConfigurer.defaultConfiguration();configurer.registerModule(        SagaConfiguration.subscribingSagaManager(MySagaType.class)                         // Axon defaults to an in-memory SagaStore, defining another is recommended                         .configureSagaStore(c -> new JpaSagaStore(...)));// alternatively, it is possible to register a single SagaStore for all Saga types:configurer.registerComponent(SagaStore.class, c -> new JpaSagaStore(...));</pre><h2 id="saga存储库和saga存储"><a href="#saga存储库和saga存储" class="headerlink" title="saga存储库和saga存储"></a>saga存储库和saga存储</h2><p>SagaRepository负责存储和检索saga，使用SagaManager。它能够通过标识符和关联值检索特定的saga实例。然而，有一些特殊的要求。因为在saga中的并发处理是一个非常微妙的过程，存储库必须确保每个概念的saga实例（具有相同的标识符）只有一个实例存在于JVM。</p><p>Axon提供了 AnnotatedSagaRepository 实现，允许saga实例的查找，同时保证在同一时间只有一个saga实例被访问。它使用一个SagaStore执行saga实例实际的持久化。</p><p>实现的选择主要取决于应用程序使用的存储引擎。Axon提供了JdbcSagaStore、InMemorySagaStore JpaSagaStore 和MongoSagaStore。</p><p>在某些情况下,应用程序受益于缓存Saga实例。在这种情况下，有一个CachingSagaStore包装另一个实现添加缓存行为。<br>请注意，CachingSagaStore 是一 个write-through 缓存，这意味着保存操作总是立即转发到后备存储器，以确保数据安全。</p><h2 id="JpaSagaStore"><a href="#JpaSagaStore" class="headerlink" title="JpaSagaStore"></a>JpaSagaStore</h2><p>JpaSagaStore使用JPA来存储状态和关联saga的值。saga本身并不需要任何JPA注解；Axon将使用序列化器序列化saga(类似于事件序列化，你可以使用JavaSerializer或XStreamSerializer)。</p><p>JpaSagaStore通过EntityManagerProvider来配置,它提供对EntityManager实例的访问。这种抽象允许使用应用程序管理和容器管理EntityManagers。根据情况,你可以定义序列化器去序列化saga实例。Axon默认为XStreamSerializer。</p><h2 id="JdbcSagaStore"><a href="#JdbcSagaStore" class="headerlink" title="JdbcSagaStore"></a>JdbcSagaStore</h2><p>JdbcSagaStore使用原来的JDBC存储saga实例及其关联值。类似于JpaSagaStore，saga实例不需要知道他们是如何存储的。序列化使用序列化器。</p><p>用DataSource 或ConnectionProvider初始化JdbcSagaStore 。虽然不是必需的，用ConnectionProvider初始化时，建议在UnitOfWorkAwareConnectionProviderWrapper包装实现。它将检查已经打开的数据库连接的当前工作单元，以确保工作单元中的所有活动都是在单个连接上完成的。</p><p>不像JPA，JdbcSagaRepository使用普通的SQL语句，存储和检索信息。这可能意味着某些操作依赖于数据库特有的SQL方言。情况也可能是这样，某些数据库供应商提供了你希望使用的非标准特性。允许这个，你可以提供自己的SagaSqlSchema。SagaSqlSchema接口定义的存储库的所有操作要在底层数据库上执行。它允许你定制为它们执行的SQL语句。默认是GenericSagaSqlSchema。其他可用的实现是PostgresSagaSqlSchema,Oracle11SagaSqlSchema 和HsqlSagaSchema。</p><h2 id="MongoSagaStore"><a href="#MongoSagaStore" class="headerlink" title="MongoSagaStore"></a>MongoSagaStore</h2><p>MongoSagaStore存储saga实例和它们的关联到MongoDB数据库中。MongoSagaStore存储在单个集合中的所有saga到MongoDB数据库中。每个saga实例创建一个文档。</p><p>MongoSagaStore还确保在任何时候，在单个JVM中任何唯一的saga只有一个saga实例存在。这样可以确保不因并发问题而丢失任何状态更改。</p><p>使用MongoTemplate和一个可选的序列化器初始化MongoSagaStore。MongoTemplate提供了一个对集合的引用存储Sagas。Axon 提供了DefaultMongoTemplate，DefaultMongoTemplate获取MongoClient实例，还获取数据库名称和集合的名称存储Sagas。数据库名称和集合的名称可以省略。在这种情况下，他们分别默认为“axonframework”和“sagas”。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>如果使用一个支持的saga存储的数据库，保存和加载Saga 实例可能是相对昂贵的操作。特别是在很短的时间段内多次调用同一个saga实例的情况下，缓存对应用程序的性能是有利的。</p><p>Axon 提供了CachingSagaStore实现。这个SagaStore包装实际的存储。加载saga或关联值时，CachingSagaStore将首先查阅其缓存，优于委托给包装的存储库。当存储信息时，所有调用总是被委托，以确保后备存储器总是有一个与saga的状态一致的视图。</p><p>配置缓存,简单包装任何SagaStore到CachingSagaStore中。CachingSagaStore的构造函数接受三个参数:分别是，包装的存储库、用于关联值的缓存和saga的实例。后两个参数可以引用相同或不同的缓存。这取决于你的具体的程序的逐出需求。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/57bd121412fa" target="_blank" rel="noopener">https://www.jianshu.com/p/57bd121412fa</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件需要被重定向到适当的saga实例。为此,一些基础设施类是必需的。最重要的组件是SagaManager和SagaRepository。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework跟踪最后期限</title>
    <link href="http://blog.weechang.xyz/2018/08/29/AxonFramework-%E8%B7%9F%E8%B8%AA%E6%9C%80%E5%90%8E%E6%9C%9F%E9%99%90/"/>
    <id>http://blog.weechang.xyz/2018/08/29/AxonFramework-跟踪最后期限/</id>
    <published>2018-08-29T02:11:46.000Z</published>
    <updated>2018-09-04T09:24:40.268Z</updated>
    
    <content type="html"><![CDATA[<p>当有事发生时，很容易使一个saga采取行动。毕竟，有一个事件要通知saga。但是如果你想让你的saga，在什么事情都没发生的情况下做些什么呢？这就是最后期限。在发票中，通常是几周，而信用卡支付的确认可能在几秒钟内。</p><a id="more"></a><p>在Axon中，你可以使用一个EventScheduler计划发布一个事件。在发票的例子中，你希望发票在30内付清。saga将在发送CreateInvoiceCommand后，安排一个InvoicePaymentDeadlineExpiredEvent在30天后发布。计划一个事件后EventScheduler返回ScheduleToken。这个令牌可以用来取消计划，例如已收到发票的付款。</p><p>Axon提供了两种EventScheduler实现:一个纯Java和一个使用Quartz 2作为调度机制支持。</p><p>这个纯java实现的EventScheduler使用ScheduledExecutorService去计划事件发布。虽然这个计划器的定时非常可靠，但它是一个纯内存实现。一旦JVM关闭，所有的计划都将丢失。这使得这种实现不适合长期限的计划。</p><p>SimpleEventScheduler 需要配置一个EventBus和一个SchedulingExecutorService（看java.util.concurrent.Executors类的静态方法的helper方法）。</p><p>QuartzEventScheduler是一个更可靠，企业信得过的实现。使用Quartz 作为底层调度机制，它提供了更强大的功能，如持久性、集群和失败的管理。这意味着事件发布将被保证。可能会晚一点，但会发布。</p><p>需要配置一个Quartz调度器和EventBus。另外，你可以设置以组的名称进行计划，默认为”AxonFramework-Events”</p><p>一个或多个组件将监听计划的事件。这些组件可能依赖于绑定到调用它们的线程的事务。计划的事件由EventScheduler管理的线程发布。管理事务在这些线程上，你可以配置一个TransactionManager或UnitOfWorkFactory创建一个事务绑定工作单元。</p><blockquote><p><b>注意</b><br>Spring用户可以使用quartzeventschedulerfactorybean或simpleeventschedulerfactorybean进行更简单的配置。它允许你直接设置PlatformTransactionManager。</p></blockquote><h2 id="注入资源"><a href="#注入资源" class="headerlink" title="注入资源"></a>注入资源</h2><p>saga一般做的不仅仅是维护基于事件的状态。它们与外部的组件进行交互。要做到这一点，他们需要访问处理组件所需的资源。通常，这些资源实际上并不是saga状态的一部分，也不应该持久化。但是，一旦重新构建一个saga，在事件被路由到该实例之前，必须注入这些资源。</p><p>为了这个目的有了ResourceInjector。它使用SagaRepository将资源注入到一个saga。Axon提供了SpringResourceInjector用应用程序上下文中的资源注入带注解的字段和方法，和一个SimpleResourceInjector，注册已经注册的资源到用@Inject注解的方法和字段。</p><blockquote><p><b>提示</b><br>由于资源与saga不应该被持久化，所以务必向这些字段添加临时关键字。这将防止序列化机制尝试将这些字段的内容写入存储库。存储库将在saga被反序列化之后自动重新注入所需的资源。</p></blockquote><p>Simpleresourceinjector允许一个预先指定的资源集合被注射。它扫描saga的(setter)方法和字段，以找到被@Inject注解的那个。</p><p>当使用配置API，Axon将默认为the ConfigurationResourceInjector。它将注入配置中可用的任何资源。组件像EventBus、EventStore CommandBus和CommandGateway默认情况下是可用的,但你也可以使用configurer.registerComponent()注册自己的组件。</p><p>Springresourceinjector使用Spring的依赖注入机制注入资源聚合。这意味着，如果需要，可以使用setter注入或直接字段注入。要注入的方法或字段需要注解，以便Spring识别它为依赖项。例如@Autowired。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/02e3636fc735" target="_blank" rel="noopener">https://www.jianshu.com/p/02e3636fc735</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当有事发生时，很容易使一个saga采取行动。毕竟，有一个事件要通知saga。但是如果你想让你的saga，在什么事情都没发生的情况下做些什么呢？这就是最后期限。在发票中，通常是几周，而信用卡支付的确认可能在几秒钟内。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework事件处理</title>
    <link href="http://blog.weechang.xyz/2018/08/27/AxonFramework-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://blog.weechang.xyz/2018/08/27/AxonFramework-事件处理/</id>
    <published>2018-08-27T06:47:54.000Z</published>
    <updated>2018-09-05T02:21:46.375Z</updated>
    
    <content type="html"><![CDATA[<p>saga中的事件处理非常接近一个普通的事件监听器。上述的对于方法和参数解析的规则在这里是有效的。不过,有一个主要区别。虽然存在事件监听器只有单个实例处理所有传入事件，但也存在一个saga有多个实例，每个实例都对不同的事件感兴趣。例如,关于Order的id为1的管理业务Saga对Order“2”的事件不感兴趣，反之亦然。</p><p>Axon不会将所有事件都发布给所有saga实例（这将是对资源的完全浪费），而是只发布与saga相关联的属性的事件。这个通过使用AssociationValues完成。一个AssociationValue由key和value组成。key代表标识符使用的类型，例如“orderId”或“order”。value表示前面例子中相应“1”或“2”值。</p><p>带@SagaEventHandler注解的方法被评估的顺序与带@EventHandler的相同。如果处理器方法的参数与传入的事件匹配，那么方法就匹配，如果saga有一个定义在处理器方法上的association属性。</p><p>@SagaEventHandler注解有两个attribute,其中associationProperty是最重要的。这是传入事件上property的名称，应该用来寻找相关的saga。association值的key是property的名称。这个值是由property的getter方法返回的值。</p><p>例如,考虑一个带”String getOrderId()”方法传入事件,返回“123”。如果一个带@SagaEventHandler(associationProperty = orderId)注解的方法接受这个事件,这个事件被路由到所有已经与带一个键为orderId和值为“123”的AssociationValues关联的saga。这可能是一个,多个,甚至没有。</p><p>有时,想要关联的属性的名称不是想要使用的关联的名称。例如,你有一个销售订单相匹配购买订单的saga。你可以有一个包含“buyOrderId”和“sellOrderId”的事务对象。如果你想要的saga将“orderId”作为关联的值，你可以定义一个不同的keyName 在@SagaEventHandler注解中。它将变成@SagaEventHandler(associationProperty=”sellOrderId”, keyName=”orderId”)。</p><h2 id="管理关联"><a href="#管理关联" class="headerlink" title="管理关联"></a>管理关联</h2><p>当一个saga事务管理跨多个域的概念，如订单、发货,、发票，等等，saga需要与这些概念的实例关联。一个关联需要两个参数：key，识别关联的类型(订单、发货等)和一个value，该值表示该概念的标识符。<br>在以下几个方面完成用概念关联到saga。第一，当新创建一个saga时将调用一个用@StartSaga注解的事件处理器时，它将自动与@SagaEventHandler方法中标识的关联。所有其他的关联用SagaLifecycle.associateWith(String key, String/Number value)方法创建。用SagaLifecycle.removeAssociationWith(String key, String/Number value)方法去移除一个特定的关联。</p><p>想象一下为一个围绕着订单的事务而已经被创建的一个saga。saga自动关联订单，方法被@StartSaga注解。saga是负责创建该订单的发票，并告诉航运创建一个载货量。一旦货物到达和发票支付,交易完成后,saga被关闭。<br>这是一个saga的代码：</p><p><pre><br>public class OrderManagementSaga {<br>private boolean paid = false;<br>private boolean delivered = false;<br>@Inject<br>private transient CommandGateway commandGateway;</pre></p><p>@StartSaga<br>@SagaEventHandler(associationProperty = “orderId”)<br>public void handle(OrderCreatedEvent event) {<br>    // client generated identifiers<br>    ShippingId shipmentId = createShipmentId();<br>    InvoiceId invoiceId = createInvoiceId();<br>    // associate the Saga with these values, before sending the commands<br>    associateWith(“shipmentId”, shipmentId);<br>    associateWith(“invoiceId”, invoiceId);<br>    // send the commands<br>    commandGateway.send(new PrepareShippingCommand(…));<br>    commandGateway.send(new CreateInvoiceCommand(…));<br>}</p><p>@SagaEventHandler(associationProperty = “shipmentId”)<br>public void handle(ShippingArrivedEvent event) {<br>    delivered = true;<br>    if (paid) { end(); }<br>}</p><p>@SagaEventHandler(associationProperty = “invoiceId”)<br>public void handle(InvoicePaidEvent event) {<br>    paid = true;<br>    if (delivered) { end(); }<br>}</p><p>// …<br>}<br><br>通过允许客户端生成标识符，可以很容易地与一个概念相关联，而不需要请求响应类型命令。在发布命令之前，我们将事件与这些概念关联起来。通过这种方式，我们也保证捕捉到作为该命令的一部分生成的事件。一旦发票付清，货物到达，saga也将结束。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/297622466ca9" target="_blank" rel="noopener">https://www.jianshu.com/p/297622466ca9</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;saga中的事件处理非常接近一个普通的事件监听器。上述的对于方法和参数解析的规则在这里是有效的。不过,有一个主要区别。虽然存在事件监听器只有单个实例处理所有传入事件，但也存在一个saga有多个实例，每个实例都对不同的事件感兴趣。例如,关于Order的id为1的管理业务Sag
      
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework管理复杂的业务事务</title>
    <link href="http://blog.weechang.xyz/2018/08/27/AxonFramework-%E7%AE%A1%E7%90%86%E5%A4%8D%E6%9D%82%E7%9A%84%E4%B8%9A%E5%8A%A1%E4%BA%8B%E5%8A%A1/"/>
    <id>http://blog.weechang.xyz/2018/08/27/AxonFramework-管理复杂的业务事务/</id>
    <published>2018-08-27T06:43:56.000Z</published>
    <updated>2018-09-05T02:21:46.300Z</updated>
    
    <content type="html"><![CDATA[<p>并不是每个命令都能够在一个ACID事务中完全执行。现金转账事务是一个很常见频繁出现的例子，用来作为论据。通常认为，把钱从一个账户转移到另一个账户，绝对需要原子性和一致性。其实并非如此，相反，这是完全不可能的。如果钱从A银行的帐户转移到B银行的帐户怎么办？A银行要获得B银行数据库的锁吗？如果转账正在进行的时候，A银行已经扣除了金额,但B银行并没收到它，这不是很奇怪吗?事实上不是，这是“正在进行”。另一方面,如果在向B银行的帐户中存资金时出现错误，A银行的客户就想要他的钱回退。所以我们需要某种形式的最终一致性。</p><a id="more"></a><p>虽然ACID事务在某些情况下不是必需的甚至是不可能的，但仍然需要某种形式的事务管理。通常，这些事务称为BASE事务：基本的可用性，软性状态，最终一致性。 与ACID相反，BASE事务无法轻松回滚。 要回滚，需要采取补偿措施来恢复作为事务一部分发生的任何事情。 在汇款的例子中，如果没有把钱存入B银行，将把钱退还给A银行。<br>在CQRS中，Sagas可用于管理这些BASE事务。 他们对事件做出响应，并可能调度命令，调用外部应用程序等。在领域驱动设计的上下文中，将Sagas用作多个限界上下文之间的协调机制并不罕见。</p><h2 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h2><p>一个saga是一种特殊类型的事件监听器：用来管理业务事务。一些事务可能运行数天甚至数周，而另一些则在几毫秒内完成。在Axon中，saga的每个实例负责管理一个业务事务。这意味着saga维护状态必须管理事务，持续或采取补偿动作回滚已经被采取任何动作。通常情况下，与常规的事件监听器相反，saga有一个起点和终点，都由事件触发。虽然saga的起点通常是非常明确的，但可能有多种方式结束一个saga。</p><p>在Axon中,Sagas是定义了一个或多个@SagaEventHandler方法的类。与常规事件处理器不同，在任何时间可能存在多个saga的实例。Saga由一个Processor管理(跟踪或订阅)，Processor通过事件致力于处理特定saga类型。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>一个单独的saga实例负责管理一个单独的事务。这意味着你需要能够标示一个saga生命周期的开始和结束。</p><p>在一个saga中，事件处理器用@SagaEventHandler注解。如果一个特定的事件标志着开始一个事务，在同一个方法上添加另一个注解:@StartSaga。这个注解将创建一个新的saga，并且当匹配事件后布后调用它的事件处理器方法。</p><p>默认情况下,只有在找不到匹配的saga时才能开启一个新的saga。你也可以强行创建一个新的saga实例，通过把@StartSaga注解上的forceNew属性设置为true。</p><p>结束一个saga可以以两种方式完成。如果一个特定的事件总是标示saga生命周期的结束，在saga上用@EndSaga注解事件的处理器。在调用处理器后，saga的生命周期将结束。作为一种选择,你可以调用end()从saga内部去结束生命周期。这允许你有条件地结束saga。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/9c8d7fb623a0" target="_blank" rel="noopener">https://www.jianshu.com/p/9c8d7fb623a0</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并不是每个命令都能够在一个ACID事务中完全执行。现金转账事务是一个很常见频繁出现的例子，用来作为论据。通常认为，把钱从一个账户转移到另一个账户，绝对需要原子性和一致性。其实并非如此，相反，这是完全不可能的。如果钱从A银行的帐户转移到B银行的帐户怎么办？A银行要获得B银行数据库的锁吗？如果转账正在进行的时候，A银行已经扣除了金额,但B银行并没收到它，这不是很奇怪吗?事实上不是，这是“正在进行”。另一方面,如果在向B银行的帐户中存资金时出现错误，A银行的客户就想要他的钱回退。所以我们需要某种形式的最终一致性。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework在聚合中处理命令</title>
    <link href="http://blog.weechang.xyz/2018/08/27/AxonFramework-%E5%9C%A8%E8%81%9A%E5%90%88%E4%B8%AD%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.weechang.xyz/2018/08/27/AxonFramework-在聚合中处理命令/</id>
    <published>2018-08-27T06:04:52.000Z</published>
    <updated>2018-09-05T02:21:46.324Z</updated>
    
    <content type="html"><![CDATA[<p>建议在包含处理状态命令的聚合中直接定义命令处理器，因为命令处理器有可能需要该集合的状态来执行其任务。</p><a id="more"></a><p>要在一个聚合上定义一个命令处理器,只需用@CommandHandler注解命令处理方法即可。带@CommandHandler注解方法的规则和其他处理方法都是一样的。然而,命令不仅通过他们的有效载荷(payload)进行路由。命令消息携带一个名字,该名称默认为命令对象的完全限定类名。</p><p>默认情况下,带@CommandHandler注解的方法允许以下参数类型:</p><ul><li><p>第一个参数是命令消息的有效载荷。它的类型也可能是Message或CommandMessage，如果@CommandHandler 注解明确定义命令处理器的名称。默认情况下，命令名是命令的有效载荷的完全限定类名。</p></li><li><p>用@MetaDataValue注解的参数，将用注解上的键对元数据值进行解析。如果需要为false（默认值），则在元数据值不存在时传递NULL。如果需要为True，在元数据值不存在时，该解析器将不匹配并阻止该方法被调用。</p></li><li><p>参数的类型元数据将注入整个CommandMessage的元数据。</p></li><li><p>UnitOfWork类型的参数获取当前工作单元注入。这允许命令处理器注册的行为在工作单元的特定阶段执行，或获得与它注册的资源的访问。</p></li><li><p>Message或CommandMessage类型的参数，将得到完整的消息，包括有效载荷和元数据。如果方法需要多个元数据字段或包装消息的其他属性，则此方法非常有用。</p></li></ul><p>为了使Axon知道哪一个聚合类型的实例应该处理命令消息，命令对象的属性传送聚合标识符，必须用@TargetAggregateIdentifier注解。注解可以放置在任何字段或访问器方法上（例如getter）。</p><p>创建聚合实例的命令不需要标识目标聚合标识符，虽然建议标注聚合标识符。</p><p>如果你喜欢使用另一个机制路由命令，这种行为可以通过提供一个自定义CommandTargetResolver来重写。这个类应该返回聚合标识符和预期的版本(如果有的话)基于给定的命令。</p><blockquote><p><b>注意</b><br>当@CommandHandler注解放在一个聚合的构造函数上时，相应的命令将创建一个新的聚合实例，并将它添加到存储库。这些命令不需要针对特的定聚合实例。因此，这些命令不需要任何@TargetAggregateIdentifier或@TargetAggregateVersion注解，也不会调用自定义CommandTargetResolver。<br>当一个命令创建一个聚合实例时，该命令的回调函数在命令执行成功执行后，将得到聚合标识符。</p></blockquote><pre>public class MyAggregate {    @AggregateIdentifier    private String id;    @CommandHandler    public MyAggregate(CreateMyAggregateCommand command) {        apply(new MyAggregateCreatedEvent(IdentifierFactory.getInstance().generateIdentifier()));    }    // no-arg constructor for Axon    MyAggregate() {    }    @CommandHandler    public void doSomething(DoSomethingCommand command) {    // do something...    }    // code omitted for brevity. The event handler for MyAggregateCreatedEvent must set the id field}public class DoSomethingCommand {    @TargetAggregateIdentifier    private String aggregateId;    // code omitted for brevity}</pre><p>Axon的配置API可用于配置聚合。例如:</p><pre>Configurer configurer = ...// to use defaults:configurer.configureAggreate(MyAggregate.class);// allowing customizations:configurer.configureAggregate(AggregateConfigurer.defaultConfiguration(MyAggregate.class).configureCommandTargetResolver(c -> new CustomCommandTargetResolver()));</pre><p>@CommandHandler注释并不局限于聚合根。把所有命令处理器放在根里，有时会导致聚合根中存在大量的方法,而它们中的许多只简单地调用转发给底层实体之一。如果是这样,你可以把@CommandHandler注解在一个底层的实体的方法上。Axon找到这些带注释的方法,聚合根中声明的实体字段必须用@AggregateMember标明。注意,命令处理器只检查带注解的字段的声明类型。如果一个字段值为空时传入命令到实体,就会抛出一个异常。</p><pre>public class MyAggregate {    @AggregateIdentifier    private String id;    @AggregateMember    private MyEntity entity;    @CommandHandler    public MyAggregate(CreateMyAggregateCommand command) {        apply(new MyAggregateCreatedEvent(...);    }    // no-arg constructor for Axon    MyAggregate() {    }    @CommandHandler    public void doSomething(DoSomethingCommand command) {        // do something...    }    // code omitted for brevity. The event handler for MyAggregateCreatedEvent must set the id field    // and somewhere in the lifecycle, a value for "entity" must be assigned to be able to accept    // DoSomethingInEntityCommand commands.}public class MyEntity {    @CommandHandler    public void handleSomeCommand(DoSomethingInEntityCommand command) {        // do something    }}</pre><p>请注意，在聚合中每个命令必须只对应一个处理器。这意味着你不能用@CommandHandler标注多个实体(either root nor not，包含是根和不是根的所有实体)来处理相同的命令类型。如果你需要有条件地路由命令到一个实体,这些实体的父类应该处理命令,并根据apply的条件转发该命令。</p><p>字段的运行时类型不需要精确地声明类型。然而，@CommandHandle方法只检查被@AggregateMember标记的字段的声明类型。</p><p>也可以用@AggregateMember去注释包含实体的集合和Map。在后一种情况下，map的值有望包含实体，而键包含一个用作它们引用的值。</p><p>作为一个命令需要被路由到正确的实例，这些实例必须被正确地标识。它们的“ID”字段必须用@ EntityId标记。命令的属性将用于查找该消息应被路由到的实体，默认为被标识的字段的名称。例如，当标记一个名为“myentityid”字段，命令必须具有相同名称的属性。这意味着必须提供个getmyentityid或myentityid()方法。如果字段的名称和路由属性不同，你可以提供一个值显式使用 @EntityId(routingKey = “customRoutingProperty”)。</p><p>如果在带注解的集合和Map中没有实体能被找到，Axon会抛出一个IllegalStateException异常。显然,聚合不能够在那个时间点上处理命令。</p><blockquote><p><b>注意</b><br>字段声明的集合或Map应该包含适当的泛型,允许Axon识别实体的类型包含在集合或Map中。如果不可能添加泛型在声明中(例如因为你已经使用了一个自定义泛型类型的实现),你必须指定实体的类型，用于entityType属性@AggregateMember注解。</p></blockquote><h2 id="外部命令处理器"><a href="#外部命令处理器" class="headerlink" title="外部命令处理器"></a>外部命令处理器</h2><p>在某些情况下,想要直接向一个聚合实例路由命令是不可能。在这种情况下,可以注册一个命令处理器对象。命令处理器对象是一个简单的(常规的)对象，是带@CommandHandle注解的方法。与集合的情况不同，命令处理器对象只有单个实例，该对象处理其方法中声明的所有命令类型。</p><pre>public class MyAnnotatedHandler {@CommandHandlerpublic void handleSomeCommand(SomeCommand command, @MetaDataValue("userId") StringuserId) {// whatever logic here}@CommandHandler(commandName = "myCustomCommand")public void handleCustomCommand(SomeCommand command) {// handling logic here}}// To register the annotated handlers to the command bus:Configurer configurer = ...configurer.registerCommandHandler(c -> new MyAnnotatedHandler());</pre><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/64ddd5a8f517" target="_blank" rel="noopener">https://www.jianshu.com/p/64ddd5a8f517</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建议在包含处理状态命令的聚合中直接定义命令处理器，因为命令处理器有可能需要该集合的状态来执行其任务。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework聚合事件溯源</title>
    <link href="http://blog.weechang.xyz/2018/08/27/AxonFramework-%E8%81%9A%E5%90%88%E4%BA%8B%E4%BB%B6%E6%BA%AF%E6%BA%90/"/>
    <id>http://blog.weechang.xyz/2018/08/27/AxonFramework-聚合事件溯源/</id>
    <published>2018-08-27T05:56:57.000Z</published>
    <updated>2018-09-05T02:21:46.238Z</updated>
    
    <content type="html"><![CDATA[<p>除了存储一个聚合的当前状态，还可以根据过去发布的事件恢复一个聚合的状态。为此，所有状态的更改必须由一个事件来表示。</p><a id="more"></a><p>主要部分，事件溯源聚合类似于“有规律”聚合：他们必须声明一个标识符并可以使用apply函数发布事件。然而，事件溯源聚合中状态的变化(也就字段的任何变化)必须在@EventSourcingHandler注解的方法中被排他地执行。这包括设置聚合标识符。</p><p>注意,聚合标识必须被设置在聚合发布的第一个事件的@EventSourcingHandler上，这通常是创建事件。</p><p>事件溯源聚合的聚合根还必须包含一个无参的构造函数，Axon Framework使用这个构造函数创建一个空的聚合实例，在使用过去的事件之前初始化它。没有提供这种构造函数加载聚合时将导致异常。</p><pre>public class MyAggregateRoot {    @AggregateIdentifier    private String aggregateIdentifier;    // fields containing state...    @CommandHandler    public MyAggregateRoot(CreateMyAggregate cmd) {        apply(new MyAggregateCreatedEvent(cmd.getId()));    }    // constructor needed for reconstruction    protected MyAggregateRoot() {    }    @EventSourcingHandler    private void handleMyAggregateCreatedEvent(MyAggregateCreatedEvent event) {        // make sure identifier is always initialized properly        this.aggregateIdentifier = event.getMyAggregateIdentifier();        // ... update state    }}</pre><p>带@EventSourcingHandler注解的方法使用特定的规则来解析。这些规则对于带@EventHandler注解的方法也同样适合，并在Defining Event Handlers这一章节中彻底解释。</p><blockquote><p><b>注意</b><br>事件处理器(Event handler)的方法可以是私有的，只要JVM的安全设置允许Axon Framework改变方法的可访问性。这使你能够清楚地分离聚合的公共API，该方法从处理事件的内部逻辑中公开生成事件的方法。大多数的IDE有一个选项来忽略“未使用的私有方法”的警告为特定注解的方法。或者,你可以添加一个@SuppressWarnings(UnusedDeclaration)注解到方法,以确保你不意外地删除事件处理器方法。</p></blockquote><p>有时候，特别是当聚合结构的增长远远超过两个实体时，对同一聚合的其他实体中事件发布的影响更明显。然而，由于重构聚合状态时事件处理器方法也会被调用，所以必须采取特殊的预防措施。</p><p>在事件溯源处理器方法内可以apply()新事件。这使得实体B可以apply一个事件来响应实体A做的一些事情成为可能。Axond重演历史事件时将忽略apply()调用。注意,在这种情况下，内部apply()调用事件只发布给实体，在所有实体收到第一个事件后。如果有更多的事件需要公布，在apply一个内部事件后的实体状态的基础上，可以用apply(…).andThenApply(…)</p><p>你还可以使用静态AggregateLifecycle.isLive()方法来检查聚合是否“存活”。基本上,一个聚合如果已经完成重演历史事件会被认为是存活的。当重演这些事件时，isLive()将返回false。在处理新生成的事件时，使用islive()方法是唯一可以执行的活动。</p><p>复杂的聚合结构</p><p>复杂的业务逻辑通常需要多个带聚合根的聚合来提供支持。在这种情况下，重要的是把复杂性分布在聚合内的多个实体中。当使用事件溯源时，不仅聚合根需要使用事件来触发状态转换，而且聚合内的实体也如此。</p><blockquote><p><b>注意</b><br>一个常见的误解，聚合的实体不应该包含任何属性访问方法来暴露状态。这并非如此。事实上，在同一聚合内的实体向其他的实体暴露状态，可能会使一个聚合受益很多。然而，建议不要向外部暴露聚合的状态。</p></blockquote><p>Axon在复杂的聚合结构中提供了对事件溯源的支持。实体，就像聚合根，简单的对象。子实体的字段声明必须使用@AggregateMember来注解。这个注释告诉Axon被注解的字段，包含一个应该对命令和事件处理程序进行检查的类。</p><p>当一个实体(包括聚合根)应用一个事件时，它首先是由聚合根处理，然后向下通过所有带@AggregateMember注解的字段到其子实体。</p><p>可能包含子实体的字段必须用@AggregateMember注解，此注释可用于多种字段类型：</p><p>字段直接引用的实体类型;<br>内部包含一个迭代器字段(包括所有集合,例如,列表,等等);<br>内部包含java.util.Map字段的值。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/7b88c5077006" target="_blank" rel="noopener">https://www.jianshu.com/p/7b88c5077006</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了存储一个聚合的当前状态，还可以根据过去发布的事件恢复一个聚合的状态。为此，所有状态的更改必须由一个事件来表示。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="http://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
</feed>
