<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>耒耒耒耒耒</title>
  
  <subtitle>张未的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.weechang.xyz/"/>
  <updated>2018-10-19T10:10:07.452Z</updated>
  <id>https://blog.weechang.xyz/</id>
  
  <author>
    <name>张未</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哈希算法究竟是个什么鬼</title>
    <link href="https://blog.weechang.xyz/2018/10/19/hash/"/>
    <id>https://blog.weechang.xyz/2018/10/19/hash/</id>
    <published>2018-10-19T05:28:01.000Z</published>
    <updated>2018-10-19T10:10:07.452Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直以来写博客都是抱着给别人看的心态写的，其实，别人看了又怎样，重要的是自己写的过程。这几天终于想明白了这个道理，但是博客该有的套路还是得一个不少的加上。最近感觉写Java方面的知识有些厌倦了，于是干脆写点自己想写的。</p></blockquote><a id="more"></a><p>曾经面试被问到过哈希算法，而曾经的我什么都不懂，就在那儿乱扯一通，现在看来那个时候的自己真的好笑。于是准备补上这个坑，搜集汇总哈希算法的相关只是于此。</p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>我们如何比较两个文件是否一致呢？</p><p>将文件读成二进制流，然后比较两个文件的二进制流？如果二进制流一开始就不一样还好说，或者是文件小都好说。但是如果是大文件呢？如果文件最后几位二进制不一样，这怎么办？耗时太久。</p><p>这个时候我们就需要一个高效而可靠办法，给每个文件一个唯一的ID，然后直接比较两个ID，这貌似是一个不错的方法。嗯，想一想很不错。但是如何确定两个文件的ID不同呢？这时候就可以用到HASH方法了。</p><h1 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h1><p><strong>散列算法（Hash Algorithm）</strong>，又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。</p><h1 id="三、应用"><a href="#三、应用" class="headerlink" title="三、应用"></a>三、应用</h1><p>哈希算法，目前在信息安全领域主要用到以下几个方面：</p><ul><li>文件校验</li></ul><p>我们常见的很多文件下载的时候，除了能够下载具体的文件外，还有很多会给出文件的MD5码。这就是用于文件校验使用的。因为在传统的加密渠道中，我们只能对文件传输过程中的信道进行容错处理，但是不能对抗恶意的文件篡改问题。所以如果有了MD5码，我们就能够通过MD5码，校验我们收到的问题件是否是未经篡改的文件。</p><ul><li>数字签名</li></ul><p>Hash 算法也是现代password体系中的一个重要组成部分。因为非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。 对 Hash 值，又称”数字摘要”进行数字签名，在统计上能够觉得与对文件本身进行数字签名是等效的。</p><ul><li>鉴权协议</li></ul><p>当数据在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。</p><h1 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h1><p>Hash算法最主要的目的就是为了将一个大范围映射到一个小范围。将大范围映射到小范围是为了节省空间。另外，还要使Hash值足够唯一，这样ID才具有唯一性。除此之外，Hash算法还得具有单向性。</p><p>具体说来，Hash算法应该具有以下几个限制点：</p><ul><li>Hash的主要原理就是把大范围映射到小范围；所以，你输入的实际值的个数必须和小范围相当或者比它更小。不然冲突就会非常多。</li><li>Hash逼近单向函数；所以，你能够用它来对数据进行加密。</li><li>不同的应用对Hash函数有着不同的要求；比方，用于加密的Hash函数主要考虑它和单项函数的差距，而用于查找的Hash函数主要考虑它映射到小范围的冲突率。</li></ul><p>明白了这几点，我们就能够对Hash函数的实现做一些了解了。总的说来，目前主流的Hash算法有以下几种实现方法：</p><h2 id="1-加法Hash"><a href="#1-加法Hash" class="headerlink" title="1. 加法Hash"></a>1. 加法Hash</h2><p>所谓的加法Hash就是把输入元素一个一个的加起来构成最后的结果。标准的加法Hash的构造例如以下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int additiveHash(String key, int prime)&#123;</span><br><span class="line">    int hash, i;</span><br><span class="line">    for (hash = key.length(), i = 0; i &lt; key.length(); i++)</span><br><span class="line">    hash += key.charAt(i);</span><br><span class="line">    return (hash % prime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的prime是随意的质数，看得出，结果的值域为[0,prime-1]。</p><h2 id="2-位运算Hash"><a href="#2-位运算Hash" class="headerlink" title="2. 位运算Hash"></a>2. 位运算Hash</h2><p>这类型Hash函数通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素。比方，标准的旋转Hash的构造例如以下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int rotatingHash(String key, int prime) &#123;</span><br><span class="line">    int hash, i;</span><br><span class="line">    for (hash=key.length(), i=0; i&lt;key.length(); ++i)</span><br><span class="line">        hash = (hash&lt;&lt;4)^(hash&gt;&gt;28)^key.charAt(i);</span><br><span class="line">    return (hash % prime);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>先移位，然后再进行各种位运算是这样的类型Hash函数的主要特点。比方，以上的那段计算hash的代码还能够有例如以下几种变形：</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = (hash&lt;&lt;5)^(hash&gt;&gt;27)^key.charAt(i);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash += key.charAt(i);</span><br><span class="line">hash += (hash &lt;&lt; 10);</span><br><span class="line">hash ^= (hash &gt;&gt; 6);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if((i&amp;1) == 0)&#123;</span><br><span class="line">    hash ^= (hash&lt;&lt;7) ^ key.charAt(i) ^ (hash&gt;&gt;3);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    hash ^= ~((hash&lt;&lt;11) ^ key.charAt(i) ^ (hash &gt;&gt;5));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash += (hash&lt;&lt;5) + key.charAt(i);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = key.charAt(i) + (hash&lt;&lt;6) + (hash&gt;&gt;16) – hash;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash ^= ((hash&lt;&lt;5) + key.charAt(i) + (hash&gt;&gt;2));</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-乘法Hash"><a href="#3-乘法Hash" class="headerlink" title="3. 乘法Hash"></a>3. 乘法Hash</h2><p>这种类型的Hash函数利用了乘法的不相关性（乘法的这种性质，最有名的莫过于平方取头尾的随机数生成算法，虽然这种算法效果并不好）。比如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int bernstein(String key) &#123;</span><br><span class="line">    int hash = 0;</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0; i&lt;key.length(); ++i) </span><br><span class="line">        hash = 33*hash + key.charAt(i);</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk5.0里面的String类的hashCode()方法也使用乘法Hash。不过，它使用的乘数是31。推荐的乘数还有：131, 1313, 13131, 131313等等。</p><p>使用这种方式的著名Hash函数还有：</p><ul><li>32位FNV算法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int M_SHIFT = 0;</span><br><span class="line">public int FNVHash(byte[] data) &#123;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(byte b : data)</span><br><span class="line">        hash = (hash * 16777619) ^ b;</span><br><span class="line">    if (M_SHIFT == 0)</span><br><span class="line">        return hash;</span><br><span class="line">    return (hash ^ (hash &gt;&gt; M_SHIFT)) &amp; M_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以及改进的FNV算法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static int FNVHash1(String data) &#123;</span><br><span class="line">    final int p = 16777619;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(int i=0;i&lt;data.length();i++)</span><br><span class="line">        hash = (hash ^ data.charAt(i)) * p;</span><br><span class="line">    hash += hash &lt;&lt; 13;</span><br><span class="line">    hash ^= hash &gt;&gt; 7;</span><br><span class="line">    hash += hash &lt;&lt; 3;</span><br><span class="line">    hash ^= hash &gt;&gt; 17;</span><br><span class="line">    hash += hash &lt;&lt; 5;</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了乘以一个固定的数，常见的还有乘以一个不断改变的数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static int RSHash(String str)&#123;</span><br><span class="line">    int b = 378551;</span><br><span class="line">    int a = 63689;</span><br><span class="line">    int hash = 0;</span><br><span class="line">    for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">        hash = hash * a + str.charAt(i);</span><br><span class="line">        a = a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然Adler32算法的应用没有CRC32广泛，不过，它可能是乘法Hash里面最有名的一个了。关于它的介绍，大家可以去看RFC 1950规范。</p><h2 id="4-除法Hash"><a href="#4-除法Hash" class="headerlink" title="4. 除法Hash"></a>4. 除法Hash</h2><p>除法和乘法一样，同样具有表面上看起来的不相关性。不过，因为除法太慢，这种方式几乎找不到真正的应用。需要注意的是，我们在前面看到的hash的 结果除以一个prime的目的只是为了保证结果的范围。如果你不需要它限制一个范围的话，可以使用如下的代码替代”hash%prime”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = hash ^ (hash&gt;&gt;10) ^ (hash&gt;&gt;20)</span><br></pre></td></tr></table></figure><h2 id="5-查表Hash"><a href="#5-查表Hash" class="headerlink" title="5. 查表Hash"></a>5. 查表Hash</h2><p>查表Hash最有名的样例莫过于CRC系列算法。尽管CRC系列算法本身并非查表，可是，查表是它的一种最快的实现方式。以下是CRC32的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static int crctab[256] = &#123;</span><br><span class="line">0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, </span><br><span class="line">0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, </span><br><span class="line">0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, </span><br><span class="line">0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, </span><br><span class="line">0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, </span><br><span class="line">0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, </span><br><span class="line">0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, </span><br><span class="line">0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, </span><br><span class="line">0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, </span><br><span class="line">0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, </span><br><span class="line">0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, </span><br><span class="line">0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, </span><br><span class="line">0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, </span><br><span class="line">0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, </span><br><span class="line">0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, </span><br><span class="line">0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, </span><br><span class="line">0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, </span><br><span class="line">0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, </span><br><span class="line">0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, </span><br><span class="line">0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, </span><br><span class="line">0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, </span><br><span class="line">0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, </span><br><span class="line">0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, </span><br><span class="line">0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, </span><br><span class="line">0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, </span><br><span class="line">0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, </span><br><span class="line">0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, </span><br><span class="line">0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, </span><br><span class="line">0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, </span><br><span class="line">0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, </span><br><span class="line">0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, </span><br><span class="line">0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d</span><br><span class="line">&#125;;</span><br><span class="line">int crc32(String key, int hash) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (hash=key.length(), i=0; i&lt;key.length(); ++i)</span><br><span class="line">        hash = (hash &gt;&gt; 8) ^ crctab[(hash &amp; 0xff) ^ k.charAt(i)];</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查表Hash中有名的样例有：Universal Hashing和Zobrist Hashing。他们的表格都是随机生成的。</p><h2 id="6-混合Hash"><a href="#6-混合Hash" class="headerlink" title="6. 混合Hash"></a>6. 混合Hash</h2><p>混合Hash算法利用了以上各种方式。各种常见的Hash算法，比如MD5、Tiger都属于这个范围。它们一般很少在面向查找的Hash函数里面使用。</p><h2 id="7-数组Hash"><a href="#7-数组Hash" class="headerlink" title="7. 数组Hash"></a>7. 数组Hash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline int hashcode(const int *v) &#123;</span><br><span class="line">    int s = 0;</span><br><span class="line">    for(int i=0; i&lt;k; i++)</span><br><span class="line">        s=((s&lt;&lt;2)+(v[i]&gt;&gt;4))^(v[i]&lt;&lt;10);</span><br><span class="line">    s = s % M;</span><br><span class="line">    s = s &lt; 0 ? s + M : s;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、碰撞"><a href="#五、碰撞" class="headerlink" title="五、碰撞"></a>五、碰撞</h1><p>通过前面说到的几种Hash算法的实现，我们可以发现，Hash算法虽然很多好，但是无法保证两个片段产生的Hash值不能重复。Hash算法产生冲突的情况，称之为Hash冲突，也称之为Hash碰撞。</p><p>通过构造性能良好的Hash算法，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是Hash算法的另一个关键问题。目前解决Hash冲突的主流方法大概有以下几种：</p><h2 id="1-开放寻址法-再散列法"><a href="#1-开放寻址法-再散列法" class="headerlink" title="1. 开放寻址法(再散列法)"></a>1. 开放寻址法(再散列法)</h2><p>开放寻址法的基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：</p><p>Hi=（H（key）+di）% m i=1，2，…，n</p><p>其中H（key）为哈希函数，m 为表长，di称为增量序列。</p><h2 id="2-再哈希法"><a href="#2-再哈希法" class="headerlink" title="2. 再哈希法"></a>2. 再哈希法</h2><p>这种方法的基本思想是：同时构造多个不同的哈希函数：</p><p>Hi=RH1（key） i=1，2，…，k</p><p>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p><h2 id="3-链地址法（拉链法）"><a href="#3-链地址法（拉链法）" class="headerlink" title="3. 链地址法（拉链法）"></a>3. 链地址法（拉链法）</h2><p>这种方法的基本思想是：将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p><h2 id="4-建立公共溢出区"><a href="#4-建立公共溢出区" class="headerlink" title="4. 建立公共溢出区"></a>4. 建立公共溢出区</h2><p>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p><p>目前用的比较多的就是 <strong>开放寻址法</strong> 和 <strong>拉链法</strong> ,针对 开放寻址法 和 拉链法 其具体的优缺点如下：</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><ul><li>优点：</li></ul><p>1.避免了动态调整的开销</p><p>2.由于底层是链表结构，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了</p><p>3.同样也是因为链表结构，删除记录时，比较方便，直接通过指针操作即可</p><ul><li>缺点：</li></ul><p>1.由于链表结构，所以查询比较耗时</p><p>2.由于链表结构，不利于序列化操作</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><ul><li>优点</li></ul><p>1.记录更容易进行序列化（serialize）操作</p><ul><li>缺点</li></ul><p>1.存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升</p><p>2.使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低</p><p>3.由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费</p><p>4.删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。</p><p><strong>总结：拉链法适合数据量不可预知，且写入多，查询少的情况。开放寻址法适合数据量可预知，查询多，写入少的情况。</strong></p><p>在传统的JDK中，采用的都是拉链法，自JDK1.8起，对拉链法做了改造。当链表长度超过预定值后将采用红黑树结构替代链表结构，这样对查询操作做了更好的优化。具体可参考我之前写的关于HashMap的文章 <a href="/2018/07/30/Java集合-0——HashMap类/">Java集合-0——HashMap类</a></p><p><strong>PS: 文中对Hash算法实现的代码均源于网络，若有侵权，请联系删除 <a href="https://blog.csdn.net/tanga842428/article/details/79850832" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;一直以来写博客都是抱着给别人看的心态写的，其实，别人看了又怎样，重要的是自己写的过程。这几天终于想明白了这个道理，但是博客该有的套路还是得一个不少的加上。最近感觉写Java方面的知识有些厌倦了，于是干脆写点自己想写的。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="https://blog.weechang.xyz/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="哈希算法" scheme="https://blog.weechang.xyz/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://blog.weechang.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Java学习之从头开始】Java多线程-3——synchronized是如何工作的</title>
    <link href="https://blog.weechang.xyz/2018/10/03/java-thread-03-synchronized/"/>
    <id>https://blog.weechang.xyz/2018/10/03/java-thread-03-synchronized/</id>
    <published>2018-10-03T14:15:42.000Z</published>
    <updated>2018-10-08T02:48:56.975Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是我Java多线程的第四篇博文了。本来计划一天一更的，但是国庆假期，都浪去了，没坚持更新。今天主要讲讲在Java多线程中，synchronized是如何工作的。</p></blockquote><a id="more"></a><h1 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h1><p>在Java中，每一个对象有且仅有一个同步锁。即同步锁是依赖于对象而存在。</p><p>当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。且不同线程对同步锁的访问是互斥的。</p><h1 id="synchronized-基本规则"><a href="#synchronized-基本规则" class="headerlink" title="synchronized 基本规则"></a>synchronized 基本规则</h1><p>synchronized 遵循以下三条规则：</p><ul><li><strong>一</strong>、当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li><li><strong>二</strong>、当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。</li><li><strong>三</strong>、当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li></ul><h1 id="synchronized-的几种使用方法"><a href="#synchronized-的几种使用方法" class="headerlink" title="synchronized 的几种使用方法"></a>synchronized 的几种使用方法</h1><p>在Java中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 既可以加在一段代码上，也可以加在方法上。下面将仔细了解 synchronized 关键字的几种使用方法。</p><h2 id="synchronized-作用于实例方法"><a href="#synchronized-作用于实例方法" class="headerlink" title="synchronized 作用于实例方法"></a>synchronized 作用于实例方法</h2><p>synchronized 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。</p><p>正确示列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceSync implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    static int i = 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void syncCount() &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int j = 0; j &lt; 100000; j++) &#123;</span><br><span class="line">            syncCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        InstanceSync instance = new InstanceSync();</span><br><span class="line">        Thread t1 = new Thread(instance);</span><br><span class="line">        Thread t2 = new Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200000</span><br></pre></td></tr></table></figure><p>错误示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceSyncBad implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    static int i = 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void syncCount() &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int j = 0; j &lt; 100000; j++) &#123;</span><br><span class="line">            syncCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(new InstanceSyncBad());</span><br><span class="line">        Thread t2 = new Thread(new InstanceSyncBad());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">175000</span><br></pre></td></tr></table></figure><p><strong>代码分析</strong> ：上面两个例子中，第一个获得了我们预期结果，第二个未获得预期结果。说明在第二个例子中 synchronized 方法出现了问题，因为第二个例子中， t1 和 t2 锁住的不是同一个对象。在t1、t2中变量是不共享的。解决这个问题的办法是，让 synchronized 锁住 静态方法。</p><p><strong>实例锁</strong>：锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。实例锁对应的就是synchronized关键字。（即修饰实例方法的锁）</p><h2 id="synchronized-作用于静态方法"><a href="#synchronized-作用于静态方法" class="headerlink" title="synchronized 作用于静态方法"></a>synchronized 作用于静态方法</h2><p>synchronized 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class StaticSync implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    static int i=0;</span><br><span class="line"></span><br><span class="line">    public static synchronized void increase()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int j=0;j&lt;100000;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // 新实例</span><br><span class="line">        Thread t1=new Thread(new StaticSync());</span><br><span class="line">        Thread t2=new Thread(new StaticSync());</span><br><span class="line"></span><br><span class="line">        // 启动线程</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200000</span><br></pre></td></tr></table></figure><p><strong>代码分析</strong>：该实例中，synchronized 锁住的是静态方法，与锁住实例方法不一样。锁住静态方法，就相当于锁住整个类。</p><p><strong>全局锁</strong>：该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）（即修饰静态方法的锁）。</p><h2 id="synchronized-作用于代码块"><a href="#synchronized-作用于代码块" class="headerlink" title="synchronized 作用于代码块"></a>synchronized 作用于代码块</h2><p>synchronized 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class BlockSync implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    static BlockSync instance = new BlockSync();</span><br><span class="line">    static int i = 0;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //使用同步代码块对变量i进行同步操作,锁对象为instance</span><br><span class="line">        synchronized (instance) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 100000; j++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(instance);</span><br><span class="line">        Thread t2 = new Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;这是我Java多线程的第四篇博文了。本来计划一天一更的，但是国庆假期，都浪去了，没坚持更新。今天主要讲讲在Java多线程中，synchronized是如何工作的。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://blog.weechang.xyz/tags/Java/"/>
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Java学习之从头开始】Java多线程-2——Thread中run()和start()的区别</title>
    <link href="https://blog.weechang.xyz/2018/10/02/java-thread-02-run-start/"/>
    <id>https://blog.weechang.xyz/2018/10/02/java-thread-02-run-start/</id>
    <published>2018-10-02T10:12:03.000Z</published>
    <updated>2018-10-08T02:48:56.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前一篇博文中，我们讨论了Java中多线程的常用实现方式及Thread和Runnable的区别。在本篇，我们将讨论Thread中run()和start()的区别。</p></blockquote><a id="more"></a><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>下面我们将通过代码来实现，两者的调用。并展示两者区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class RunAndStart &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread myThread = new MyThread(&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;*** myThread run method&quot;);</span><br><span class="line">        myThread.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;*** myThread start method&quot;);</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    public MyThread(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(&quot;my name is &quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** myThread run method</span><br><span class="line">my name is main</span><br><span class="line">*** myThread start method</span><br><span class="line">my name is test</span><br></pre></td></tr></table></figure><p>对以上运行结果呢，我做一下解释：</p><ul><li>Thread.currentThread().getName()是用于获取“当前线程”的名称。</li><li>myThread.run()是在“主线程main()”中调用的，该run()方法直接运行在“主线程main()”上。</li><li>myThread.start()会启动“线程myThread”，“线程myThread”启动之后，会调用run()方法。</li></ul><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>从以上代码的运行结果我们可以看到run() 和 start() 的区别：</p><ul><li>start() : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用（该处我没给出具体代码，感兴趣的同学可以自行验证）。</li><li>run() : run()就和普通的成员方法一样，直接调用的话会在当前线程中执行run()，而并不会启动新线程。且能多次重复调用。</li></ul><h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h1><ul><li>start()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">    // 检查线程启动状态</span><br><span class="line">    // 如果不是就绪状态，则抛出异常</span><br><span class="line">    if (threadStatus != 0)</span><br><span class="line">        throw new IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    // 将当前线程，加入group中</span><br><span class="line">    group.add(this);</span><br><span class="line"></span><br><span class="line">    boolean started = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 通过本地方法 start0 启动线程</span><br><span class="line">        start0();</span><br><span class="line">        started = true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!started) &#123;</span><br><span class="line">                group.threadStartFailed(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable ignore) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private native void start0();</span><br></pre></td></tr></table></figure><p>源码解释： 在调用start方法的时候，其实是通过本地方法start0() 来启动的。通过start0() 创建一个新的线程，且调用run()执行。</p><ul><li>run()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (target != null) &#123;</span><br><span class="line">        target.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码解析: 直接调用目标对象的 run() 方法，并不会创建新线程。</p><p><strong>PS：此章节内容相关源码已上传至<a href="https://github.com/weechang/java-zero/tree/master/p2-java-thread/src/main/java/io/github/weechang/java/thread/runAndStart" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;前一篇博文中，我们讨论了Java中多线程的常用实现方式及Thread和Runnable的区别。在本篇，我们将讨论Thread中run()和start()的区别。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://blog.weechang.xyz/tags/Java/"/>
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Java学习之从头开始】Java多线程-1——Java中如何实现多线程</title>
    <link href="https://blog.weechang.xyz/2018/10/01/java-thread-01-implements-thread/"/>
    <id>https://blog.weechang.xyz/2018/10/01/java-thread-01-implements-thread/</id>
    <published>2018-09-30T16:08:39.000Z</published>
    <updated>2018-10-08T02:48:56.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一节，学习了Java多线程的基本概念，接下来就要正式进入多线程的学了。首先学习的是，在Java中如何实现一个多线程。</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java中主要通过 <strong>Thread</strong> 和 <strong>Runnable</strong> 两种方式来实现多线程。另外通过JUC中的线程池也能实现线程，该方法暂时不在我的学习范围之内。</p><h1 id="关于-Thread-和-Runnable"><a href="#关于-Thread-和-Runnable" class="headerlink" title="关于 Thread 和 Runnable"></a>关于 Thread 和 Runnable</h1><ul><li>Runnable 是一个接口。其中只定义了一个 run() 方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Thread 是一个Java类。是通过实现Runnable而成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过实现Runnable接口来实现一个多线程。利用Thread方法，可以直接实现多线程。下面我们将通过具体的例子说明如何实现多线程。</p><h1 id="通过-Thread-实现多线程"><a href="#通过-Thread-实现多线程" class="headerlink" title="通过 Thread 实现多线程"></a>通过 Thread 实现多线程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ImplementThread &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ImplementThread implementThread = new ImplementThread();</span><br><span class="line">        implementThread.byThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 继承 Thread 方式</span><br><span class="line">     */</span><br><span class="line">    public void byThread()&#123;</span><br><span class="line">        MyThread t1 = new MyThread();</span><br><span class="line">        MyThread t2 = new MyThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private int count = 10;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            if (this.count &gt; 0) &#123;</span><br><span class="line">                System.out.println(this.getName() + &quot; 计数器：count&quot; + this.count--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 计数器：count10</span><br><span class="line">Thread-0 计数器：count10</span><br><span class="line">Thread-1 计数器：count9</span><br><span class="line">Thread-0 计数器：count9</span><br><span class="line">Thread-1 计数器：count8</span><br><span class="line">Thread-0 计数器：count8</span><br><span class="line">Thread-1 计数器：count7</span><br><span class="line">Thread-0 计数器：count7</span><br><span class="line">Thread-1 计数器：count6</span><br><span class="line">Thread-0 计数器：count6</span><br><span class="line">Thread-1 计数器：count5</span><br><span class="line">Thread-0 计数器：count5</span><br><span class="line">Thread-1 计数器：count4</span><br><span class="line">Thread-0 计数器：count4</span><br><span class="line">Thread-1 计数器：count3</span><br><span class="line">Thread-0 计数器：count3</span><br><span class="line">Thread-0 计数器：count2</span><br><span class="line">Thread-0 计数器：count1</span><br><span class="line">Thread-1 计数器：count2</span><br><span class="line">Thread-1 计数器：count1</span><br></pre></td></tr></table></figure><p>通Thread继承方式，我们发现。MyThread 继承自Thread 是一个自定义线程。在主线程main()中，创建并启动了2个子线程，这两个子线程分别计数10次。</p><h1 id="通过-Runnable-实现多线程"><a href="#通过-Runnable-实现多线程" class="headerlink" title="通过 Runnable 实现多线程"></a>通过 Runnable 实现多线程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class ImplementThread &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ImplementThread implementThread = new ImplementThread();</span><br><span class="line">        implementThread.byRunnable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现 Runnable方式</span><br><span class="line">     */</span><br><span class="line">    public void byRunnable()&#123;</span><br><span class="line">        MyRunnable myRunnable = new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(myRunnable);</span><br><span class="line">        Thread t2 = new Thread(myRunnable);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyRunnable implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private int count = 10;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            if (this.count &gt; 0) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; 计数器：count&quot; + this.count--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 计数器：count10</span><br><span class="line">Thread-1 计数器：count9</span><br><span class="line">Thread-0 计数器：count8</span><br><span class="line">Thread-0 计数器：count6</span><br><span class="line">Thread-0 计数器：count5</span><br><span class="line">Thread-1 计数器：count7</span><br><span class="line">Thread-0 计数器：count4</span><br><span class="line">Thread-0 计数器：count2</span><br><span class="line">Thread-1 计数器：count3</span><br><span class="line">Thread-0 计数器：count1</span><br></pre></td></tr></table></figure><p>通过Runnable方式我们可以发现，主线程main()中虽然启动了2个线程。但是这2个线程一共计数10次。说明这两个线程是基于MyRunnable共享的。</p><h1 id="Thread-与-Runnable的异同"><a href="#Thread-与-Runnable的异同" class="headerlink" title="Thread 与 Runnable的异同"></a>Thread 与 Runnable的异同</h1><p><strong>相同点</strong>：都是一种多线程的实现方式。<br><strong>不同点</strong>：<br>1) Thread 是 类， Runnable 是接口；<br>2) “一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性；<br>3) Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。</p><p><strong>建议使用Runnable去实现多线程</strong></p><h1 id="关于Thread的补充"><a href="#关于Thread的补充" class="headerlink" title="关于Thread的补充"></a>关于Thread的补充</h1><p>在很多博客上看到说，Runnable 相较于 Tread 能够实现资源共享，没有一个好的解释。就我上面的例子而言。可以看出Thread 与 Runnable 的写法不同。有些人肯定会心存疑虑。<br>所以在此，我对 Thread 的 写法做另一种补充以证清白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class ImplementThread &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ImplementThread implementThread = new ImplementThread();</span><br><span class="line">        implementThread.byThread2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Thread 资源不共享的补充说明</span><br><span class="line">     */</span><br><span class="line">    public void byThread2()&#123;</span><br><span class="line">        MyThread myThread = new MyThread();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(myThread);</span><br><span class="line">        Thread t2 = new Thread(myThread);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private int count = 10;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            if (this.count &gt; 0) &#123;</span><br><span class="line">                System.out.println(this.getName() + &quot; 计数器：count&quot; + this.count--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过和 Runnable一样的启动方式启动Thread 多线程。</p><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 计数器：count10</span><br><span class="line">Thread-0 计数器：count9</span><br><span class="line">Thread-0 计数器：count8</span><br><span class="line">Thread-0 计数器：count6</span><br><span class="line">Thread-0 计数器：count5</span><br><span class="line">Thread-0 计数器：count4</span><br><span class="line">Thread-0 计数器：count7</span><br><span class="line">Thread-0 计数器：count3</span><br><span class="line">Thread-0 计数器：count2</span><br><span class="line">Thread-0 计数器：count1</span><br></pre></td></tr></table></figure><p>从上述结果可以看到，在main()主线程中，只有一个线程的运行结果。这是为什么呢，因为Thread 一旦被start() 就没法再次start()。若想同时启动多个 Thread 只能创建多个不同的Thread实例。但是多个不同Thread 实例中，资源是不共享的。</p><p><strong>本博客代码已托管到<a href="https://github.com/weechang/java-zero/tree/master/p2-java-thread/src/main/java/io/github/weechang/java/thread/implementThread" rel="external nofollow noopener noreferrer" target="_blank">github</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;上一节，学习了Java多线程的基本概念，接下来就要正式进入多线程的学了。首先学习的是，在Java中如何实现一个多线程。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://blog.weechang.xyz/tags/Java/"/>
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Java学习之从头开始】Java多线程-0——基础概念</title>
    <link href="https://blog.weechang.xyz/2018/09/30/java-thread-00-base/"/>
    <id>https://blog.weechang.xyz/2018/09/30/java-thread-00-base/</id>
    <published>2018-09-30T08:59:22.000Z</published>
    <updated>2018-09-30T09:31:59.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java多线程，一直是Java里面一个绕不去的坎，对程序员的要求比较高。同时，得益于Java社区的日益强健，Java框架也随之丰富起来了，特别是Web框架。所以大多数做Web的程序员，都是拿来就用，我就是其中一员。Web中几乎不用程序员自身去操作多线程，所以这也就导致了大多数的Java Web程序员多线程方面较为薄弱。为了解决这一问题，下定决心学习Java多线程，同时记录自己的学习过程，以供日后翻阅。</p></blockquote><a id="more"></a><h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><p>线程与进程一直是相互关联，而又完全不同的两个概念。</p><p>其不同在于：</p><ul><li><p><strong>线程</strong>：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）</p></li><li><p><strong>进程</strong>：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位）</p></li></ul><p>其关联性在于：</p><p>1、一个进程可以有多个线程，但至少有一个线程；而一个线程只能在一个进程的地址空间内活动。</p><p>2、资源分配给进程，同一个进程的所有线程共享该进程所有资源。</p><p>3、CPU分配给线程，即真正在处理器运行的是线程。</p><p>4、线程在执行过程中需要协作同步，不同进程的线程间要利用消息通信的办法实现同步。</p><h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>Java中线程的状态分为五个阶段：</p><p>1、新建状态(New)： 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</p><p>2、就绪状态(Runnable)： 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</p><p>3、运行状态(Running)： 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</p><p>4、阻塞状态(Blocked)： 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p><p>01) 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</p><p>02) 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</p><p>03) 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p><p>5、死亡状态(Dead)： 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p><p>五种状态的转换关系如下：</p><p>更多关于线程的知识将在后续章节中，详细介绍，敬请期待……</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Java多线程，一直是Java里面一个绕不去的坎，对程序员的要求比较高。同时，得益于Java社区的日益强健，Java框架也随之丰富起来了，特别是Web框架。所以大多数做Web的程序员，都是拿来就用，我就是其中一员。Web中几乎不用程序员自身去操作多线程，所以这也就导致了大多数的Java Web程序员多线程方面较为薄弱。为了解决这一问题，下定决心学习Java多线程，同时记录自己的学习过程，以供日后翻阅。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://blog.weechang.xyz/tags/Java/"/>
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一个关于FastJson的高危漏洞</title>
    <link href="https://blog.weechang.xyz/2018/09/30/fastjson-bug/"/>
    <id>https://blog.weechang.xyz/2018/09/30/fastjson-bug/</id>
    <published>2018-09-29T16:12:22.000Z</published>
    <updated>2018-09-30T01:42:05.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近了解到一个关于FastJson的高危漏洞，在此列出来，给各位开发者提个醒。希望有用到该版本的开发者，及时升级版本，避免受到影响。</p></blockquote><a id="more"></a><p>具体漏洞情况如下，当FastJson版本低于1.2.49时，将json字符串泛解析为java对象的时候，在某些特定值的情况下。会导致长时间的阻塞（根据具体的CPU计算性能决定，时间长达几分钟）cup占用率飙升。</p><p>涉及到的地方包括：</p><ul><li>1.调用JSON.parseObject()方法。</li><li>2.使用@RequestBody 并且 HttpMessageConverter 为FastJson 的时候。</li></ul><p>且导致这一现象的代价微乎其微，效果堪比DDOS，由于该漏洞的具体细节，目前只是在小范围内传播，而且涉及范围过广，所以在此我也就不公布具体的漏洞细节了。</p><p>官方已在1.2.49及以后的版本中修复这一漏洞。</p><p><strong>希望有用到1.2.49以下版本的同学尽快升级</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近了解到一个关于FastJson的高危漏洞，在此列出来，给各位开发者提个醒。希望有用到该版本的开发者，及时升级版本，避免受到影响。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blog.weechang.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.weechang.xyz/tags/Java/"/>
    
      <category term="FastJson高危漏洞" scheme="https://blog.weechang.xyz/tags/FastJson%E9%AB%98%E5%8D%B1%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>说一说我所用到的hexo插件</title>
    <link href="https://blog.weechang.xyz/2018/09/29/hexo-plugins/"/>
    <id>https://blog.weechang.xyz/2018/09/29/hexo-plugins/</id>
    <published>2018-09-29T06:52:20.000Z</published>
    <updated>2018-09-29T09:20:15.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在我之前的博文中，介绍了如何用hexo搭建一个自己的博客系统。当然只是简单地搭建，还有很多东西需要补全的。今天我就介绍下，hexo常用插件，以此来丰富你的博客功能、改善用户体验。</p></blockquote><a id="more"></a><p>关于如何使用hexo搭建自己的博客系统，感兴趣的同学可以看我之前的文章<a href="https:blog.weechang.xyz//2018/09/19/六元一个的私有博客系统，了解一下？/" target="_blank" rel="noopener">六元一个的私有博客系统，了解一下？</a>。</p><p>下面将详细介绍，我的博客中所使用到的一些hexo插件，丰富博客功能、改善用户体验。</p><h1 id="字数统计插件"><a href="#字数统计插件" class="headerlink" title="字数统计插件"></a>字数统计插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount</span><br></pre></td></tr></table></figure><p>该插件能够做到统计每一篇文章的字数，以及预估阅读时间。但是如果自身的主题不支持的话，还得自己在主题中添加相关代码。如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;article-word-count&quot;&gt;</span><br><span class="line">&lt;span&gt;</span><br><span class="line">    &lt;i class=&quot;fas fa-file-word&quot;&gt;&lt;/i&gt;</span><br><span class="line">    共&lt;%= wordcount(post.content) %&gt;字，</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;span&gt;</span><br><span class="line">    &lt;i class=&quot;fas fa-clock&quot;&gt;&lt;/i&gt;</span><br><span class="line">    大约需要&lt;%= min2read(post.content) %&gt;分钟</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>添加后就能清楚地看到每篇博文的字数，及大概阅读用时了。</p><img src="/2018/09/29/hexo-plugins/wordcount.png" title="字数统计效果"><h1 id="sitemap-生成插件"><a href="#sitemap-生成插件" class="headerlink" title="sitemap 生成插件"></a>sitemap 生成插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure><p>该插件能够生成网站地图，供搜索引擎蜘蛛爬取所用。</p><h1 id="百度sitemap生成插件"><a href="#百度sitemap生成插件" class="headerlink" title="百度sitemap生成插件"></a>百度sitemap生成插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap</span><br></pre></td></tr></table></figure><p>由于百度蜘蛛的sitemap编写规则与谷歌等有所不同，所以需要针对百度生成一个专门的sitemap，可以使用该插件</p><h1 id="RSS-源生成插件"><a href="#RSS-源生成插件" class="headerlink" title="RSS 源生成插件"></a>RSS 源生成插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure><p>值得注意的是，rss源生成查件不仅仅需要安装，还得配置。需要在你的项目 _config.yml 里面添加配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># RSS plugin</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">type: atom</span><br><span class="line">path: atom.xml</span><br><span class="line">limit: 20</span><br></pre></td></tr></table></figure><h1 id="nofollow-插件"><a href="#nofollow-插件" class="headerlink" title="nofollow 插件"></a>nofollow 插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-autonofollow</span><br></pre></td></tr></table></figure><p>nofollow 插件能够给所有非本站的超链接加上 nofollow 标签，nofollow 标签的意义在于 指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重！</p><p>同时，nofollow插件也需要配置才能生效，同样在你的项目 _config.yml 添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#nofollow not include</span><br><span class="line">nofollow:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">  - blog.unknowns.info</span><br><span class="line">  - yanhaijing.com</span><br><span class="line">  - 友链domain</span><br></pre></td></tr></table></figure><h1 id="百度URL主动提交插件"><a href="#百度URL主动提交插件" class="headerlink" title="百度URL主动提交插件"></a>百度URL主动提交插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit</span><br></pre></td></tr></table></figure><p>百度url主动提交的意义在于，及时主动地向搜索引擎提交你站的新增文章url，对于搜索引擎的及时收录有一定的帮助。当然如果是一个高质量的老站，而且蜘蛛爬取频次很快的站的话，就当我没说过这句话吧。</p><p>需新增配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  # count表示一次提交几条最新的url</span><br><span class="line">  count: 1</span><br><span class="line">  host: 网站域名</span><br><span class="line">  token: 百度站长主动提交处得token</span><br><span class="line">  path: baidu_urls.txt</span><br></pre></td></tr></table></figure><p>token具体查看地址的，百度站长平台-用户中心-站点管理-数据引入-链接提交，token为图中token参数后面的值</p><img src="/2018/09/29/hexo-plugins/baiduurl.png" title="token"><p>另外需要，在修改 _config.yml 的deploy配置选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: baidu_url_submitter</span><br><span class="line">#  type: git</span><br><span class="line">  branch: master</span><br><span class="line">  repo:</span><br><span class="line">    coding: https://git.coding.net/weechang93/weechang93.coding.me.git</span><br><span class="line">    github: https://github.com/weechang/weechang.github.io.git</span><br><span class="line">  bucket: blog.weechang.xyz</span><br></pre></td></tr></table></figure><p><strong>其中deploy的type只能同时存在一个，这就需要在部署与提交url之间相互切换了。</strong></p><h1 id="静态资源压缩插件"><a href="#静态资源压缩插件" class="headerlink" title="静态资源压缩插件"></a>静态资源压缩插件</h1><p>静态资源压缩插件我知道的有两个，一个是全站压缩，一个是可选压缩，先说可选压缩的吧</p><h2 id="可选压缩"><a href="#可选压缩" class="headerlink" title="可选压缩"></a>可选压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-neat</span><br></pre></td></tr></table></figure><p>需要在 _config.yml 增加配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># hexo-neat</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css</span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">  - &apos;**/*.min.css&apos;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">  - &apos;**/*.min.js&apos;</span><br></pre></td></tr></table></figure><p>需要注意的是，css 及 js压缩需要排除掉已经压缩了的资源。另外需要压缩html就不能排除markdown的压缩。</p><h2 id="全站压缩"><a href="#全站压缩" class="headerlink" title="全站压缩"></a>全站压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-all-minifier</span><br></pre></td></tr></table></figure><p>该插件不需要配置，而且不仅能压缩html、css、js 还能压缩图片。所以我选择了这个插件。</p><p>还有个问题就是，压缩就是为了节省空间，毕竟博客放的github或者coding。两者节点都不在大陆，所以网速是个大问题，这才是我选择后者的关键原因，后者没有版权注释，前者有版权注释，感觉注释也是一种浪费啊。不是说版权不重要。</p><p><strong>注意，用压缩插件的时候。如果markdown里面有 pre 标签写的代码的话，建议尽快修改。因为这两个压缩插件对于 pre标签里面的java泛型都不是很友好，都会报错。</strong></p><p>OK，我所用到的hexo插件就介绍到这儿，希望对你有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;在我之前的博文中，介绍了如何用hexo搭建一个自己的博客系统。当然只是简单地搭建，还有很多东西需要补全的。今天我就介绍下，hexo常用插件，以此来丰富你的博客功能、改善用户体验。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Hexo博客" scheme="https://blog.weechang.xyz/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo插件" scheme="https://blog.weechang.xyz/tags/hexo%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>为你的博客添加版权</title>
    <link href="https://blog.weechang.xyz/2018/09/28/%E4%B8%BA%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83/"/>
    <id>https://blog.weechang.xyz/2018/09/28/为你的博客添加版权/</id>
    <published>2018-09-28T06:48:37.000Z</published>
    <updated>2018-09-29T09:28:04.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自己做自建博客也有一段时间了，有转载别人的博客，也有自己动手写博客。在没做独立博客之前，对版权意识并不是那么重视，也没了解过自己文章的收录情况。</p></blockquote><a id="more"></a><p>最近为了提高网站的收录量，开始将一些自己原创的博客放到oschina 等博客平台上去。但是发现自己的文章很快就被收录了，然后被别的权重较高的网站转载。结果就是自己辛辛苦苦写的文章为他人做了嫁衣，还没有自己的署名新。</p><p>于是开始研究为自己文章加上版权信息。人家的hexo博客主题都要自带的版权申明，奈何我的没有，于是只能自己写咯，谁让我要选择这个博客主题呢，谁让我要自己搞独立博客呢。</p><p>因为之前有过自己在博客主题里面添加信息的经历，所以此次添加就比较简单了。因为我的博客主题页面用的是Ejs模板写的，所以需要先写一个Ejs模板，模板主要写的就是版权的布局内容。</p><p>copyright.ejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;% if (!index || !post.excerpt) &#123; %&gt;</span><br><span class="line">    &lt;div class=&quot;post-copyright&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;author&quot;&gt;</span><br><span class="line">            &lt;b&gt;本文作者： &lt;/b&gt;</span><br><span class="line">           post.author</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;link&quot;&gt;</span><br><span class="line">            &lt;b&gt;本文链接： &lt;/b&gt;</span><br><span class="line">            &lt;a href=&quot; &lt;%= post.permalink %&gt;&quot; target=&quot;_blank&quot;&gt; &lt;%= post.permalink %&gt; &lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;copyright&quot;&gt;</span><br><span class="line">            &lt;b&gt; 版权声明： &lt;/b&gt;</span><br><span class="line">           本博客所有文章除特别声明外，均采用  &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0 &lt;/a&gt; 许可协议。转载请注明出处！</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>然后找到文章的布局模板,我是用的模板，文章布局模板文件是 article.ejs ，将 copyright.ejs 在你想要显示的地方插入。我是添加在文末，标签及分享按钮之前。所以插入位置如下</p><img src="/2018/09/28/为你的博客添加版权/插入.png" title="模板插入"><p>然后通过js文件调试自己的版权布局样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.post-copyright</span><br><span class="line">  padding: 20px</span><br><span class="line">  background: #F6F6F6</span><br><span class="line">  border-left: 4px solid #DDDDDD</span><br><span class="line">  line-height: 1.6rem</span><br></pre></td></tr></table></figure><p>Ok，大功告成。启动预览，点击文章。可以发现文章已经加入了版权信息，好开心啊。</p><p>这样人家的爬虫爬取你的文章的时候，就会加入你的定制版权信息了。就算转载了你的文章，也能在一定程度上增加你网站的外链。</p><p>另外，在自己原创文章发布后，可以立即向百度等搜索引擎提交自己的链接，这样对于收录也是有一定的好处的。</p><p><strong>另外，转载文章不留出处的方式，真的很恶心，希望大家都能尊重人家的劳动成果，加上署名及出处</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;自己做自建博客也有一段时间了，有转载别人的博客，也有自己动手写博客。在没做独立博客之前，对版权意识并不是那么重视，也没了解过自己文章的收录情况。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Hexo博客" scheme="https://blog.weechang.xyz/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="版权" scheme="https://blog.weechang.xyz/tags/%E7%89%88%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>记一次SQL优化</title>
    <link href="https://blog.weechang.xyz/2018/09/27/%E8%AE%B0%E4%B8%80%E6%AC%A1SQL%E4%BC%98%E5%8C%96/"/>
    <id>https://blog.weechang.xyz/2018/09/27/记一次SQL优化/</id>
    <published>2018-09-27T06:31:52.000Z</published>
    <updated>2018-09-29T07:47:11.418Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近收到项目的慢查询报警，刚好手上空下来了，就准备做一些优化。特开此贴记录一下此次的优化详情。</p></blockquote><a id="more"></a><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>由于项目保密原因，因此很多字段采取保密写法，望各位看官见谅。</p><p>其实呢，整个表的数据量其实也不大，也就170W+。字段大概在65个左右，除了几个单号，几个内容这种稍大一点的字段外，其他的基本都是状态和关联id的字段。所以行大小也不大。</p><p>但是，上个月的时候，产品提出一个需要根据单号模糊查询的功能，就是这个功能，导致了慢查询。优化前，根据现有逻辑以及模糊查询的需求，大概的sql是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">id,</span><br><span class="line">work_order_num AS workOrderNum,</span><br><span class="line">content,</span><br><span class="line">OTHERS_COLUMNS...</span><br><span class="line">FROM</span><br><span class="line">work_order</span><br><span class="line">WHERE</span><br><span class="line">work_order_num LIKE &apos;%201808221644820%&apos;</span><br><span class="line">AND sender_id = 11768</span><br><span class="line">AND status IN (2, 1, 0)</span><br><span class="line">AND record_status IN (4, 2)</span><br><span class="line">AND (locked = 0 OR locked = 2)</span><br><span class="line">AND yn = 1</span><br><span class="line">ORDER BY</span><br><span class="line">create_time DESC</span><br><span class="line">LIMIT 0, 10</span><br></pre></td></tr></table></figure><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>其中，上述Sql中，条件中的字段 work_order_num、sender_id 都是建了索引的，以下是慢查询统计情况</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>total_count</td><td>19</td></tr><tr><td>total_time</td><td>133.23</td></tr><tr><td>avg_time</td><td>7.01</td></tr><tr><td>max_time</td><td>7.6426</td></tr><tr><td>avg_return_rows</td><td>0.79</td></tr><tr><td>max_return_rows</td><td>1</td></tr><tr><td>avg_examined_rows</td><td>1695975.47</td></tr><tr><td>max_examined_rows</td><td>1734740</td></tr></tbody></table><p>可以看见的是，慢查询基本都是全表扫描。为什么会这样呢，我具体执行了一下Sql发现，以上条件根本就查不出数据啊。然后修改条件发现，是工单号有问题。该工单号不存在，，，不存在啊。所以导致了全表扫描。</p><h1 id="调优进行时"><a href="#调优进行时" class="headerlink" title="调优进行时"></a>调优进行时</h1><p>首先想的是去掉like 特别是like的左匹配，试了一下，去掉左匹配，速度能减少到50%。虽然有效，但是业务不允许这样做。</p><p>然后考虑的是用instr函数代替like，测试了一下，能够减少1S的时间，但是对于7S的查询来说，这TM有什么效果。还是不行。</p><p>最后想到了一次案例分享中的，先用子查询查询出符合条件的id，再用id作为筛选条件，去获取所有的列。最后修改后的sql如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">id,</span><br><span class="line">work_order_num AS workOrderNum,</span><br><span class="line">content,</span><br><span class="line">OTHERS_COLUMNS...</span><br><span class="line">FROM</span><br><span class="line">work_order</span><br><span class="line">WHERE</span><br><span class="line">id IN (</span><br><span class="line">SELECT</span><br><span class="line">id</span><br><span class="line">FROM</span><br><span class="line">ws_work_order</span><br><span class="line">WHERE</span><br><span class="line">work_order_num LIKE &apos;%201808221644820%&apos;</span><br><span class="line">AND sender_id = 11768</span><br><span class="line">AND STATUS IN (2, 1, 0)</span><br><span class="line">AND record_status IN (4, 2)</span><br><span class="line">AND (locked = 0 OR locked = 2)</span><br><span class="line">AND yn = 1</span><br><span class="line">)</span><br><span class="line">ORDER BY</span><br><span class="line">create_time DESC</span><br><span class="line">LIMIT 0, 10</span><br></pre></td></tr></table></figure><p>运行一下试试，，，果然，时间减少到了 0.03xxS。看着就有点小激动啊。</p><h1 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h1><p>原理呢，暂时忘了，先挖一个坑，等我想起了，再回来填坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近收到项目的慢查询报警，刚好手上空下来了，就准备做一些优化。特开此贴记录一下此次的优化详情。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="MySql" scheme="https://blog.weechang.xyz/tags/MySql/"/>
    
      <category term="Sql" scheme="https://blog.weechang.xyz/tags/Sql/"/>
    
  </entry>
  
  <entry>
    <title>论如何优雅地使用爬虫摸鱼</title>
    <link href="https://blog.weechang.xyz/2018/09/21/%E8%AE%BA%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%88%AC%E8%99%AB%E6%91%B8%E9%B1%BC/"/>
    <id>https://blog.weechang.xyz/2018/09/21/论如何优雅地使用爬虫摸鱼/</id>
    <published>2018-09-21T08:05:11.000Z</published>
    <updated>2018-09-30T07:29:08.343Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近手上项目空了下来，没什么事做。博客博客不想写，文章文章不想看。于是干脆看点小说吧，但是上班时间，大家都在认认真真敲代码，自己拿出手机看小说又不是很好（其实主要是数据线坏了，在公司没发充电），电脑上浏览器看，更是不行。于是想了想，干脆就自己爬着看吧，把内容打印在IDE的控制台，想一想这波操作就很骚，于是说动就动。</p></blockquote><a id="more"></a><h1 id="爬虫选择"><a href="#爬虫选择" class="headerlink" title="爬虫选择"></a>爬虫选择</h1><p>由于本人是一枚正经的Javaer，所以爬虫当然也要用Java咯。Java下也有几款比较好的爬虫软件，如nutch、crawler4j 等。但是我只是爬个网页，看个小说而已啊。于是就选了个Jsoup，直接解析Html信息，从中提取小说内容。</p><p>其实选择Jsoup还有个原因就是我好歹写过一阵子jQuery，对jQuery语法比较熟悉。因为Jsoup语法与jQuery语法非常一致。</p><h1 id="开始动工"><a href="#开始动工" class="headerlink" title="开始动工"></a>开始动工</h1><p>添加maven依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt; org.jsoup &lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt; jsoup &lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt; 1.9.2 &lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="爬取页面信息"><a href="#爬取页面信息" class="headerlink" title="爬取页面信息"></a>爬取页面信息</h1><p>Jsoup的爬取方式十分简单，是通过获取html文档到本地，然后再用jQuery的解析方式做的DOM解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class BiQuGeCrawler extends AbstractCrawler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getPage(String url) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            page = Jsoup.connect(url).get();</span><br><span class="line"></span><br><span class="line">            this.getNext();</span><br><span class="line">            this.getLast();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return this.getContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String getContent()&#123;</span><br><span class="line">        Element cntEl = page.getElementById(&quot;content&quot;);</span><br><span class="line">        // 八个空格，（制表符号）</span><br><span class="line">        return cntEl.text().replaceAll(&quot;        &quot;, &quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void getNext() &#123;</span><br><span class="line">        Element ul = page.getElementsByClass(&quot;page_chapter&quot;).get(0).child(0);</span><br><span class="line">        Element nextHref = ul.child(2).child(0);</span><br><span class="line">        nextUrl = nextHref.attr(&quot;abs:href&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void getLast() &#123;</span><br><span class="line">        Element ul = page.getElementsByClass(&quot;page_chapter&quot;).get(0).child(0);</span><br><span class="line">        Element lastHref = ul.child(0).child(0);</span><br><span class="line">        lastUrl = lastHref.attr(&quot;abs:href&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取小说正文内容及前一页、后一页链接等关键信息。</p><h1 id="设置翻页及退出"><a href="#设置翻页及退出" class="headerlink" title="设置翻页及退出"></a>设置翻页及退出</h1><p>每次抓取完页面后，监听控制台输入值，进行翻页、退出操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Function &#123;</span><br><span class="line"></span><br><span class="line">    // app配置</span><br><span class="line">    private AppConfig config;</span><br><span class="line">    // 爬虫类</span><br><span class="line">    private AbstractCrawler crawler;</span><br><span class="line"></span><br><span class="line">    public Function(String firstUrl)&#123;</span><br><span class="line">        config = new AppConfig();</span><br><span class="line">        crawler =  CrawlerFactory.build(config.sourceType);</span><br><span class="line">        startView(firstUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 页面浏览</span><br><span class="line">    private void startView(String pageUrl)&#123;</span><br><span class="line">        String content = crawler.getPage(pageUrl);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        this.inputListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 开始浏览</span><br><span class="line">    private void inputListener()&#123;</span><br><span class="line">        System.out.println(&quot;*************&quot;);</span><br><span class="line">        System.out.println(&quot;* L 上一页   *&quot;);</span><br><span class="line">        System.out.println(&quot;* Q 退出     *&quot;);</span><br><span class="line">        System.out.println(&quot;* 其他 下一页 *&quot;);</span><br><span class="line">        System.out.println(&quot;*************&quot;);</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String input = sc.nextLine();</span><br><span class="line">        if (&quot;l&quot;.equalsIgnoreCase(input))&#123;</span><br><span class="line">            // 上一页</span><br><span class="line">            startView(crawler.lastUrl);</span><br><span class="line">        &#125; else if (&quot;q&quot;.equalsIgnoreCase(input))&#123;</span><br><span class="line">            // 退出</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 下一页</span><br><span class="line">            startView(crawler.nextUrl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，整个摸鱼神器的关键代码就已经完成了，具体的完整代码，可以查看<a href="https://github.com/weechang/ReadingCrawler" rel="external nofollow noopener noreferrer" target="_blank">我的github项目</a></p><h1 id="Run一下"><a href="#Run一下" class="headerlink" title="Run一下"></a>Run一下</h1><p>首先配置需要看的小说网页信息及个人操作习惯设置。然后通过运行main方法。即可运行。</p><img src="/2018/09/21/论如何优雅地使用爬虫摸鱼/Run.png" title="效果预览"><h1 id="后续支持"><a href="#后续支持" class="headerlink" title="后续支持"></a>后续支持</h1><p>OK，到此爬虫已经能够正常爬取小说内容了。并且已经实现翻页、退出等基本功能。后续将支持更多小说来源如 <strong>纵横综合网</strong> 等网站。以及更多的功能如 <strong>日志混淆</strong>、 <strong>日志格式化</strong> 、<strong>断点续看</strong> 等功能。</p><p><strong>本文章涉及的代码已托管到github，欢迎各位客官使用<a href="https://github.com/weechang/ReadingCrawler" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/weechang/ReadingCrawler</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近手上项目空了下来，没什么事做。博客博客不想写，文章文章不想看。于是干脆看点小说吧，但是上班时间，大家都在认认真真敲代码，自己拿出手机看小说又不是很好（其实主要是数据线坏了，在公司没发充电），电脑上浏览器看，更是不行。于是想了想，干脆就自己爬着看吧，把内容打印在IDE的控制台，想一想这波操作就很骚，于是说动就动。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="爬虫" scheme="https://blog.weechang.xyz/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Jsoup" scheme="https://blog.weechang.xyz/tags/Jsoup/"/>
    
  </entry>
  
  <entry>
    <title>IDEA、WebStorm最新永久激活方式</title>
    <link href="https://blog.weechang.xyz/2018/09/21/IDEA%E3%80%81WebStorm%E6%9C%80%E6%96%B0%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB%E6%96%B9%E5%BC%8F/"/>
    <id>https://blog.weechang.xyz/2018/09/21/IDEA、WebStorm最新永久激活方式/</id>
    <published>2018-09-21T05:22:40.000Z</published>
    <updated>2018-09-29T08:37:32.625Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天早上一大早打开IDEA发现激活已过期，遂开始寻找激活码。但是一直不成功，后来终于找到一种比较靠谱的激活方式。在此记录下来，以备不时之需。</p></blockquote><a id="more"></a><p>目前网上现有的激活方式大概有这么三种</p><h1 id="激活码"><a href="#激活码" class="headerlink" title="激活码"></a>激活码</h1><p>这种方式一般是给出一段激活码，然后有些还需要改host。目前这种方式，很多激活码都不能使用了，就算能使用可能到了某一天你会发现他用不了了。所以不太推荐这种方式。</p><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>这种方式一般是填写一个服务器地址就行了，但是现在很多服务器都被官方封了。没被封的也在被封的路上。</p><h1 id="自建服务器"><a href="#自建服务器" class="headerlink" title="自建服务器"></a>自建服务器</h1><p>这种方式比较靠谱，自己搭建一个认证服务器。但是对于没有服务器的穷人来说，也是一个巨大的挑战。所以不是特别推荐。</p><p>接下来就推荐一种比较靠谱的方式。</p><h1 id="插件激活"><a href="#插件激活" class="headerlink" title="插件激活"></a>插件激活</h1><p>这种方式呢目前而言比较靠谱，由于插件在本地，不存在官方封域名及IP的说法，但是不排除被后期修复的问题。至少目前而言是没问题的，亲自验证过IDEA2017.3.5与2018.2是没有任何问题的。</p><p>下面将具体介绍这种方式的操作方法。</p><h2 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h2><p>首先下载插件jar包 <a href="http://idea.lanyus.com/jar/JetbrainsCrack-3.1-release-enc.jar" rel="external nofollow noopener noreferrer" target="_blank">http://idea.lanyus.com/jar/JetbrainsCrack-3.1-release-enc.jar</a></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>然后将插件移动到 IDEA 安装目录的bin下。如我的目录 D:\idea\IntelliJ IDEA 2018.2.4\bin</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>修改 IDEA 安装bin目录下的 idea64.exe.vmoptions 或者 idea.exe.vmoptions 具体修改哪一个看自己操作系统是64 位还是32位。64位修改 idea64.exe.vmoptions ， 32位修改 idea.exe.vmoptions。</p><img src="/2018/09/21/IDEA、WebStorm最新永久激活方式/配置文件.png" title="配置文件"><p>然后在文件末尾添加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:D:\idea\IntelliJ IDEA 2018.2.4\bin\JetbrainsCrack-3.1-release-enc.jar</span><br></pre></td></tr></table></figure><p>其中 D:\idea\IntelliJ IDEA 2018.2.4\bin\JetbrainsCrack-3.1-release-enc.jar 为插件的安装路径和文件名。注意，目录和文件名一定要一直，不然IDEA不能启动</p><img src="/2018/09/21/IDEA、WebStorm最新永久激活方式/修改配置.png" title="修改配置"><h2 id="重启IDEA、填写CODE"><a href="#重启IDEA、填写CODE" class="headerlink" title="重启IDEA、填写CODE"></a>重启IDEA、填写CODE</h2><p>重启IDEA，选择Activation Code填写激活码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ThisCrackLicenseId-&#123;</span><br><span class="line">&quot;licenseId&quot;:&quot;ThisCrackLicenseId&quot;,</span><br><span class="line">&quot;licenseeName&quot;:&quot;你想填的用户名&quot;,</span><br><span class="line">&quot;assigneeName&quot;:&quot;&quot;,</span><br><span class="line">&quot;assigneeEmail&quot;:&quot;你想填的邮箱&quot;,</span><br><span class="line">&quot;licenseRestriction&quot;:&quot;For This Crack, Only Test! Please support genuine!!!&quot;,</span><br><span class="line">&quot;checkConcurrentUse&quot;:false,</span><br><span class="line">&quot;products&quot;:[</span><br><span class="line">&#123;&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;</span><br><span class="line">],</span><br><span class="line">&quot;hash&quot;:&quot;2911276/0&quot;,</span><br><span class="line">&quot;gracePeriodDays&quot;:7,</span><br><span class="line">&quot;autoProlongated&quot;:false&#125;</span><br></pre></td></tr></table></figure><img src="/2018/09/21/IDEA、WebStorm最新永久激活方式/激活码.png" title="激活码"><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><p>OK，至此为止，你的IDEA 就激活成功，又可以继续浪了。</p><p><strong>Web Storm 激活步骤与此相同</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;今天早上一大早打开IDEA发现激活已过期，遂开始寻找激活码。但是一直不成功，后来终于找到一种比较靠谱的激活方式。在此记录下来，以备不时之需。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="IDEA永久激活" scheme="https://blog.weechang.xyz/tags/IDEA%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/"/>
    
      <category term="WebStorm永久激活" scheme="https://blog.weechang.xyz/tags/WebStorm%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>六元一个的私有博客系统，了解一下？</title>
    <link href="https://blog.weechang.xyz/2018/09/19/%E5%85%AD%E5%85%83%E4%B8%80%E4%B8%AA%E7%9A%84%E7%A7%81%E6%9C%89%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F/"/>
    <id>https://blog.weechang.xyz/2018/09/19/六元一个的私有博客系统，了解一下？/</id>
    <published>2018-09-19T06:33:09.000Z</published>
    <updated>2018-09-29T07:47:10.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神说要有光，于是便有了光"><a href="#神说要有光，于是便有了光" class="headerlink" title="神说要有光，于是便有了光"></a>神说要有光，于是便有了光</h1><p>写代码的，偶尔都想装点逼，想要自己写点博客。刚开始还能在各大社区写，比如说CSDN，开源中国，博客园什么的。但是越写就会越觉得，那些博客平台都不是自己想要的，虽然大平台，能够提高在搜索引擎的收录，但是我看着别人的博客，我也想要有一个自建的博客系统。于是开始了自建博客的入坑之旅，在这儿给大伙分享一下我的自建博客历程。</p><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>因为自己不是很懂，网上找的资料也很分散。所以整个历程大概经历了四天左右才把自己的博客系统搞好。首先需要准备以下资源</p><ol><li>github账号（应该都有吧，没有的自己去注册一个）<a href="https://www.github.com" target="_blank" rel="external nofollow noopener noreferrer">传送门</a></li><li>选择一个你喜欢的hexo主题，这个网上太多了。可以去<a href="http://hexo.io/themes/" target="_blank" rel="external nofollow noopener noreferrer">hexo官网</a>，或者<a href="https://github.com/search?q=hexo" target="_blank" rel="external nofollow noopener noreferrer">github</a>上看看</li><li>准备一个nodeJS环境，具体怎么搞，可以度娘一下 <a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="external nofollow noopener noreferrer">windows传送门</a>，<a herf="https://www.cnblogs.com/BinXu/p/6050850.html" target="_blank">Mac 传送门</a></li><li>一个阿里云账号（如果使用github提供的域名的话，这个可以省了）</li></ol><h1 id="新建github项目"><a href="#新建github项目" class="headerlink" title="新建github项目"></a>新建github项目</h1><p>新建github项目时项目命名规则为{username}.github.io如我的github用户名为weechang。则项目命名为weechang.github.io。<br><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/新建项目.png" title="新建项目"></p><p><strong>注意：命名规则必须按照这个规则来。</strong></p><h1 id="github项目配置"><a href="#github项目配置" class="headerlink" title="github项目配置"></a>github项目配置</h1><p>创建成功后就可以配置github项目了。github会自动根据项目名识别是否为github pages项目。如果是github pages项目，会出现github pages配置项目。在此，可以设置github pages项目所在分支及自定义域名等信息。<br><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/github项目配置.png" title="github项目配置"></p><p><strong>注意：自定义域名通过cname方式解析，由于github服务器在国外，所以可以不用备案。</strong></p><h1 id="查看页面"><a href="#查看页面" class="headerlink" title="查看页面"></a>查看页面</h1><p>在浏览器输入 http://{username}.github.io 即可访问你的个人页面。如: <a href="http://weechang.github.io" rel="external nofollow noopener noreferrer" target="_blank">http://weechang.github.io</a></p><p>如果访问不了页面，请检查以下问题：</p><ul><li>1.项目名是否准确</li><li>2.域名是否解析到了指定cname地址</li><li>3.分支选择是否正确</li></ul><h1 id="安装hexo客户端"><a href="#安装hexo客户端" class="headerlink" title="安装hexo客户端"></a>安装hexo客户端</h1><p>打开cmd命令行，选择一个你喜欢的目录（建议可以用git从github克隆工程到本地的本地目录），输入安装命令，开始安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/安装hexo客户端.png" title="安装hexo客户端"><p>安装完成后，输入命令，检查hexo是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/检查hexo.png" title="检查hexo"><h1 id="初始化项目文件夹"><a href="#初始化项目文件夹" class="headerlink" title="初始化项目文件夹"></a>初始化项目文件夹</h1><p>在项目文件夹下输入初始化命令，进行初始化（此处如果实在克隆项目进行的话，建议新建一个分支，比如我的就是hexo分支，该分支用来管理博客源文件与配置。当然如果想要新建项目管理这些东西的话，当我没说）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>hexo组件初始化完成后。需要安装依赖包,输入命令即可安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h1 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h1><p>OK到了此处,你的博客系统已经可运行了。</p><p><strong>首先</strong>，生成博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate // 或者 hexo g</span><br></pre></td></tr></table></figure><p><strong>本地部署</strong>，本地运行、预览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server // 或者 hexo s</span><br></pre></td></tr></table></figure><p>web服务启动后，在浏览器输入给出的预览地址，即可预览</p><p>如下，是我的本地预览效果图</p><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/预览.png" title="本地预览"><p><strong>推送到github</strong></p><p>通过hexo 配置，即可将生成的页面推送到github</p><p>修改_config.yml文件。配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  branch: master</span><br><span class="line">  repo:</span><br><span class="line">    github: https://github.com/weechang/weechang.github.io.git</span><br><span class="line">  bucket: blog.weechang.xyz</span><br></pre></td></tr></table></figure><p>通过命令推送到github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy // 或者 hexo d</span><br></pre></td></tr></table></figure><p>推送完毕后，即可通过访问 http://{username}.github.io 访问你刚部署的博客系统（由于服务器缓存等原因，可能需要等几分钟才能访问到最新页面）。</p><p>OK，至此为止。最基本的博客系统就构建完成了。如果需要了解更详细的信息，可以继续关注我的相关文章。</p><p>若有疑问可以查看我的项目配置 <a href="https://github.com/weechang/weechang.github.io" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/weechang/weechang.github.io</a></p><p>该项目 master分支是生成的博客文章信息。hexo是博客源码。如有疑惑之处，欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;神说要有光，于是便有了光&quot;&gt;&lt;a href=&quot;#神说要有光，于是便有了光&quot; class=&quot;headerlink&quot; title=&quot;神说要有光，于是便有了光&quot;&gt;&lt;/a&gt;神说要有光，于是便有了光&lt;/h1&gt;&lt;p&gt;写代码的，偶尔都想装点逼，想要自己写点博客。刚开始还能在各大社区写，比如说CSDN，开源中国，博客园什么的。但是越写就会越觉得，那些博客平台都不是自己想要的，虽然大平台，能够提高在搜索引擎的收录，但是我看着别人的博客，我也想要有一个自建的博客系统。于是开始了自建博客的入坑之旅，在这儿给大伙分享一下我的自建博客历程。&lt;/p&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="手把手教学" scheme="https://blog.weechang.xyz/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6/"/>
    
      <category term="Hexo博客" scheme="https://blog.weechang.xyz/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="GitHub Pages" scheme="https://blog.weechang.xyz/tags/GitHub-Pages/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-事件序列化器调优</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E4%BA%8B%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E8%B0%83%E4%BC%98/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-事件序列化器调优/</id>
    <published>2018-08-31T03:20:34.000Z</published>
    <updated>2018-09-27T06:22:48.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XStream序列化器"><a href="#XStream序列化器" class="headerlink" title="XStream序列化器"></a>XStream序列化器</h2><p>XStream是完全可配置和可扩展的。如果你只使用一个无格式XStreamSerializer，有一些速效方案随时取用。<br><a id="more"></a></p><p>XStream允许你为包名称和事件类名称配置别名。别名通常更短(特别是如果你有长包名)，使事件的序列化形式更小。由于我们讨论的是XML，所以每个字符从XML中移除是两次(一个开始标记，一个结束标记)。</p><p>在XStream中一个更高级的话题创建自定义转换器。默认的基于反射的转换器是简单的，但不会生成最紧凑的XML。总是仔细观察生成的XML，看看是否真正需要重建原始实例的所有信息。</p><p>如果有可能避免upcasters的使用。XStream允许别名用于字段，当他们已经改变了名字。想象版本为0事件,使用一个名为“clientId”字段。业务更喜欢“客户”一词，所以版本1使用被称为“customerId”的字段创建。在XStream中这个使用字段别名完全可以配置。你需要配置两个别名，按照以下顺序：别名“customerId”到“clientId”然后别名“customerId”到“customerId”。这将告诉XStream，如果遇到一个叫做“customerId”字段，它将调用相应的XML元素“customerId”(第二个别名覆盖第一个)。但如果XStream遇到一个XML称为“clientId”的元素，这是一个已知的别名，将解析为字段名称“customerId”。查看XStream文档了解更多信息。</p><p>对于终极性能，没有基于反射机制的alltogether你可能更好。在这种情况下，创建一个自定义的序列化机制，这可能是最明智的。DataInputStream和DataOutputStream允许你容易将事件的内容写入输出流。ByteArrayOutputStream和ByteArrayInputStream允许写入和读取字节数组。</p><h2 id="防止重复序列化"><a href="#防止重复序列化" class="headerlink" title="防止重复序列化"></a>防止重复序列化</h2><p>特别是在分布式系统中，事件消息需要在多个场合进行序列化。Axon的组件检测这个并支持SerializationAware消息。如果检测到SerializationAware消息，其方法用来序列化一个对象,而不是简单地传递载荷到序列化器。这允许对性能进行优化。</p><p>当你序列化你自己消息时，希望受益于SerializationAware优化，使用MessageSerializer类序列化消息的有效负载和元数据。所有优化逻辑是在这个类中实现。更多细节请参考MessageSerializer的JavaDoc。</p><h2 id="自定义标识符生成器"><a href="#自定义标识符生成器" class="headerlink" title="自定义标识符生成器"></a>自定义标识符生成器</h2><p>AxonFramework使用IdentifierFactory生成所有的标识符，不论它们是事件或命令。默认情况下，IdentifierFactory随机生成基于java.util.UUID的标识符。尽管它们使用起来非常安全，但生成它们的过程的性能并出色。</p><p>IdentifierFactory是一个抽象工厂，使用Java的ServiceLoader(从Java 6)机制找到实现来使用。这意味着你可以创建自己的工厂的实现，将实现的名称放在一个叫做“/META-INF/services/org.axonframework.common.IdentifierFactory”文件中。Java的ServiceLoader机制将检测到文件并尝试创建名为inside类的实例。</p><p>IdentifierFactory有几个的需求。必须实现：</p><ul><li>在类路径中让它的完全限定类名作为/META-INF/services/org.axonframework.common.IdentifierFactory文件的内容,</li><li>有一个可访问的无参数构造函数,</li><li>扩展IdentifierFactory,</li><li>通过应用程序的类加载器上下文或类加载器加载IdentifierFactory类来访问，并且必须的</li><li>是线程安全的。</li></ul><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/801dade37318" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/801dade37318</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XStream序列化器&quot;&gt;&lt;a href=&quot;#XStream序列化器&quot; class=&quot;headerlink&quot; title=&quot;XStream序列化器&quot;&gt;&lt;/a&gt;XStream序列化器&lt;/h2&gt;&lt;p&gt;XStream是完全可配置和可扩展的。如果你只使用一个无格式XStreamSerializer，有一些速效方案随时取用。&lt;br&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-高级定制</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E9%AB%98%E7%BA%A7%E5%AE%9A%E5%88%B6/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-高级定制/</id>
    <published>2018-08-31T03:14:03.000Z</published>
    <updated>2018-09-27T06:22:48.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参数解析器"><a href="#参数解析器" class="headerlink" title="参数解析器"></a>参数解析器</h2><p>你可以配置额外的ParameterResolvers，通过扩展ParameterResolverFactory类和创建一个名为/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory的文件，包含实现类的完全限定名称。</p><a id="more"></a><blockquote><p><b>警告</b><br>此时，OSGi支持仅限于在清单文件中被提到的所需的头这一事实。ParameterResolverFactory实例的自动检测在OSGi上工作，但由于类加载器的局限性，它可能需要复制/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory 文件的内容到OSGi包，包含用于解析参数的类（即事件处理程序）。</p></blockquote><h2 id="Meta-Annotations"><a href="#Meta-Annotations" class="headerlink" title="Meta Annotations"></a>Meta Annotations</h2><p>TODO</p><h2 id="Customizing-Message-Handler-behavior"><a href="#Customizing-Message-Handler-behavior" class="headerlink" title="Customizing Message Handler behavior"></a>Customizing Message Handler behavior</h2><p>TODO</p><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p>待办事项:更新Axon3<br>本章包含一个清单和在为生产级性能做准备时需要考虑的一些指导方针。现在，你可能已经使用了测试固件测试你的命令处理逻辑和sagas。然而，生产环境不像测试环境那么宽容。聚合往往存活得更久，更频繁地和并发的使用。对于额外的性能和稳定性，你最好调整配置满足你的具体需求。</p><h2 id="数据库索引和列类型"><a href="#数据库索引和列类型" class="headerlink" title="数据库索引和列类型"></a>数据库索引和列类型</h2><h2 id="SQL-DatabasesSQL数据库"><a href="#SQL-DatabasesSQL数据库" class="headerlink" title="SQL DatabasesSQL数据库"></a>SQL DatabasesSQL数据库</h2><p>如果你使用你的JPA实现自动生成表(例如Hibernate)，你可能没有把所有正确的索引设置在你的表上。为获得最佳性能，事件存储的不同用法需要不同的索引设置。该列表显示，为默认EventStorageEngine实现使用的不同类型的查询添加不同类型的索引：</p><ul><li><p>标准操作使用(存储和加载事件):<br>Table ‘DomainEventEntry’, columns aggregateIdentifier and sequenceNumber (unique index)<br>Table ‘DomainEventEntry’, eventIdentifier (unique index)</p></li><li><p>快照：<br>Table ‘SnapshotEventEntry’, aggregateIdentifier column.<br>Table ‘SnapshotEventEntry’, eventIdentifier (unique index)</p></li><li><p>Sagas<br>Table ‘AssociationValueEntry’, columns associationKey and sagaId,</p></li></ul><p>默认生成的列长度可以工作，例如Hibernate，但不会是最优的。例如，一个UUID总是有相同的长度。而不是可变长度列255个字符，你可以为聚合标识符使用一个固定长度36个字符的列。</p><p>“时间戳”列在DomainEventEntry表只储存ISO 8601时间戳。如果所有时间存储在UTC时区，他们需要一个长度为24个字符的列。如果你使用另一个时区，这可能高达28位。使用可变长度列通常是没有必要的，因为时间戳总是具有相同的长度。</p><blockquote><p><b>警告</b><br>强烈建议所有时间戳以UTC格式存储。在夏令时的国家，用当地时间存储时间戳，在时区转换时可能会导致事件生成的顺序错误。使用UTC时不会发生这种情况。有些服务器配置为始终使用UTC。另外你应该在存储它们之前配置事件存储将时间戳转换成UTC。</p></blockquote><p>在DomainEventEntry中的“type”列存储聚合的标识符类型。一般来说，这些都是聚合的简单的名称。在Spring中事件臭名昭著的“AbstractDependencyInjectionSpringContextTests”只算45个字符。在这里，再一次，一个长度较短(但可变)的字段应该足够了。</p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>默认情况下，MongoEventStore只会为正确的操作生成它需要的索引。这意味着当事件存储被创建时，所需的惟一索引在“聚合标识符”、“聚合类型”和“事件序列号”上也被创建。然而，当为某些操作使用MongoEventStore时，可能是值得添加一些额外索引的。</p><p>注意，在查询优化和更新速度之间的总有一个平衡点。负载测试最终是发现哪些索引提供最佳性能的最好方法。</p><ul><li><p>正常操作使用：<br>在“aggregateIdentifier”上自动创建一个索引，“type”和“sequenceNumber”在领域事件(缺省名称:“domainevents”)集合中。</p></li><li><p>Snapshotting：<br>在事件快照(缺省名称:“snapshotevents”)集合中把(unique)索引放“aggregateIdentifier”,“type”和“sequenceNumber“上。</p></li><li><p>Replaying events:<br>在领域事件(缺省名称:“domainevents”)集合中，把非唯一索引放在“timestamp”和“sequenceNumber”上。</p></li><li>Sagas：<br>在saga（默认名称：“sagas”）集合中把(唯一)索引放到“sagaIdentifier”上。<br>在saga（默认名称：“sagas”）集合中把索引放到”sagaType”、“associations.key”和“associations.value“属性上。</li></ul><h2 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h2><p>一个设计良好的命令处理模块当实现缓存时应该不会构成任何问题。尤其是当使用事件溯源时，从事件存储中加载一个聚合是一项昂贵的操作。用正确配置的缓存，加载一个聚合可以转化为一个纯粹的in-memory过程。</p><p>下面是一些帮助您最大限度地利用缓存解决方案的指导原则：</p><ul><li><p>确保工作单元永远不需要为功能原因执行回滚。<br>回滚意味着一个聚合已经达到了一个无效的状态。Axon会自动将相关的缓存项失效。下一个请求将迫使聚合从事件中重建。如果你使用异常作为一个潜在的(功能的)返回值，你可以在命令总线上配置一个RollbackConfiguration。默认情况下，当运行时异常时这个工作单元将回滚。</p></li><li><p>单个聚合的所有命令必须到达在缓存中具有该聚合的机器上。<br>这意味着命令应该始终被路由到同一台机器，只要这台机器是“健康”的。路由命令总是阻止缓存过期。命中一个过期缓存将导致一个命令被执行，并且事件存储在事件存储中会失败。</p></li><li><p>配置一个合理的生存时间/闲置时间<br>默认情况下，缓存倾向于有一个相对较短的生存时间，即几分钟。对于具有一致的路由的命令处理组件，一个较长的闲置时间和生存时间通常是更好的。这可以防止需要初始化一个基于它的事件的聚合，仅仅因为它的缓存条目过期了。缓存的生存时间应该与你的聚合的预期寿命相匹配。</p></li></ul><h2 id="Snapshotting"><a href="#Snapshotting" class="headerlink" title="Snapshotting"></a>Snapshotting</h2><p>快照删除需要重载和重放大量的事件。单个快照代表在在某一特定时刻整个聚合状态。然而，快照的处理本身也需要处理时间。因此，在构建快照时所花费的时间和阻止许多事件被读取节省的时间应该保持平衡。</p><p>对所有类型的应用程序都没有默认行为。一些将指定一些事件之后将创建一个快照，而其他应用程序需要一个基于时间的快照间隔。无论你选择何种方式为您的应用程序，如果你有long-living聚合，确保快照就位。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/1dc158d81511" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/1dc158d81511</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参数解析器&quot;&gt;&lt;a href=&quot;#参数解析器&quot; class=&quot;headerlink&quot; title=&quot;参数解析器&quot;&gt;&lt;/a&gt;参数解析器&lt;/h2&gt;&lt;p&gt;你可以配置额外的ParameterResolvers，通过扩展ParameterResolverFactory类和创建一个名为/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory的文件，包含实现类的完全限定名称。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-SpringBoot自动配置</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-SpringBoot自动配置/</id>
    <published>2018-08-31T03:10:15.000Z</published>
    <updated>2018-09-29T07:47:11.128Z</updated>
    
    <content type="html"><![CDATA[<p>Axon支持的SpringBoot自动配置是迄今为止开始配置Axon基础设施组件最简单的选择。只需添加axon-spring-boot-starter依赖性，Axon会自动配置基础设施组件(命令总线，事件总线)，以及运行和储存聚合和Saga所需的任何组件。</p><a id="more"></a><p>根据在应用程序上下文中的其他组件，如果他们在应用程序上下文中不是已经明确定义，Axon将定义某些组件。这意味着只需要配置不同于默认值的组件。</p><h2 id="事件总线和事件存储配置"><a href="#事件总线和事件存储配置" class="headerlink" title="事件总线和事件存储配置"></a>事件总线和事件存储配置</h2><p>如果JPA可用，事件存储默认使用JPA事件存储引擎。这允许聚合的存储使用事件溯源而无需任何明确的配置。<br>如果JPA不可用，Axon默认使用SimpleEventBus，这意味着你需要为每个聚合指定一个非事件溯源存储库，或者在你的Spring配置中配置一个EventStorageEngine 。</p><p>配置一个不同的事件存储引擎，即使JPA在class path上，只需定义一个EventStorageEngine类型的bean (使用事件溯源)或EventBus(如果不需要事件溯源)。</p><h2 id="命令总线配置"><a href="#命令总线配置" class="headerlink" title="命令总线配置"></a>命令总线配置</h2><p>如果在应用程序上下文中没有显式定义CommandBus实现，Axon会配置一个SimpleCommandBus。这个CommandBus将使用PlatformTransactionManager管理事务，如果它在上下文中可用。</p><p>如果只有CommandBus bean定义是一个DistributedCommandBus实现，Axon仍将配置一个CommandBus实现作为DistributedCommandBus本地segment。这个bean将获取一个“localSegment”限定符。建议定义DistributedCommandBus为@Primary，以便它优先考虑依赖注入。</p><h2 id="聚合配置"><a href="#聚合配置" class="headerlink" title="聚合配置"></a>聚合配置</h2><p>@Aggregate注解(在org.axonframework.spring.stereotype包中)触发自动配置，配置使用带注解的类型的必要组件作为聚合 。注意，只有聚合根需要注解。</p><p>Axon会用命令总线自动注册所有带@CommandHandler注解的方法，并且如果不存在则建立一个存储库。</p><p>建立一个与默认情况不同的存储库，在应用程序上下文中定义一个。可选地，你可以定义要使用的存储库的名称，在@Aggregate上使用存储库属性。如果没有定义存储库属性，Axon将尝试以聚合的名称使用存储库(第一个字符小写)，后缀为存储库。依此类推，一个MyAggregate类的类型，默认的存储库名字叫myAggregateRepository。如果没有找到那个名称的bean，Axon将定义一个EventSourcingRepository(如果没有EventStore可用其会失败)。</p><h2 id="Saga配置"><a href="#Saga配置" class="headerlink" title="Saga配置"></a>Saga配置</h2><p>基础设施组件的配置操作的Saga是@Saga注解触发的(在org.axonframework.spring.stereotype包中)。Axon会配置一个SagaManagert和SagaRepository。SagaRepository将在上下文中使用一个可用的SagaStore(如果找到JPA默认为JPASagaStore)为实际Saga存储。</p><p>为Saga使用不同的SagaStores，在每个@Saga注解的sagaStore属性中，提供要使用的SagaStore的bean名称。<br>Saga将从应用程序上下文中注入资源。注意，这并不意味着Spring-injecting用于注入这些资源。@Autowired和@javax.inject.Inject注解可用于标定依赖关系，但它们由Axon通过寻找这些被注解的字段和方法来注入。构造函数注入(还)不支持。</p><h2 id="事件处理（Event-Handling）配置"><a href="#事件处理（Event-Handling）配置" class="headerlink" title="事件处理（Event Handling）配置"></a>事件处理（Event Handling）配置</h2><p>默认情况下，所有单例Spring bean组件包含带@EventHandler注解的方法，将订阅一个事件处理器去接收事件消息发布到事件总线。</p><p>EventHandlingConfiguration bean，在应用程序上下文可用，有方法来调整事件处理程序的配置。有关详细信息,请参阅配置API配置事件处理程序和事件处理器。</p><p>更新事件处理（EventHandling）配置，创建一个autowired方法,设置你想要的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">public void configure(EventHandlingConfiguration config) &#123;</span><br><span class="line">    config.usingTrackingProcessors(); // default all processors to tracking mode.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件处理器(（Event Processors）的某些方面也可以在application.properties中配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axon.eventhandling.processors[&quot;name&quot;].mode=tracking</span><br><span class="line">axon.eventhandling.processors[&quot;name&quot;].source=eventBus</span><br></pre></td></tr></table></figure><p>使用application.yml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axon:</span><br><span class="line">    eventhandling:</span><br><span class="line">        processors:</span><br><span class="line">            name:</span><br><span class="line">                mode: tracking</span><br><span class="line">                source: eventBus</span><br></pre></td></tr></table></figure><p>源文件属性指的是bean的名称实现了SubscribableMessageSource或StreamableMessageSource，名称应该被用来做上述处理器的事件源。源文件默认事件总线或事件存储在应用程序上下文中定义。</p><h2 id="启用AMQP"><a href="#启用AMQP" class="headerlink" title="启用AMQP"></a>启用AMQP</h2><p>启用AMQP支持，确保axon-amqp模块在类路径上，并且在应用程序上下文中AMQP ConnectionFactory是可用的(例如通过引用spring-boot-starter-amqp)。<br>在应用程序中转发生成的事件到一个AMQP Channel，一行application.properties配置就够了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axon.amqp.exchange=ExchangeName</span><br></pre></td></tr></table></figure><p>这将以给定的名称自动发送所有已经发布的事件到AMQP Channel。</p><p>默认情况下，发送时没有使用AMQP事务。这可以使用axon.amqp.transaction-mode属性覆盖，并设置它为事务或publisher-ack。</p><p>从队列中接收事件，并在Axon应用程序内处理它们，你需要配置一个SpringAMQPMessageSource：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SpringAMQPMessageSource myQueueMessageSource(AMQPMessageConverter messageConverter) &#123;</span><br><span class="line">    return new SpringAMQPMessageSource(messageConverter) &#123;</span><br><span class="line"></span><br><span class="line">        @RabbitListener(queues = &quot;myQueue&quot;)</span><br><span class="line">        @Override</span><br><span class="line">        public void onMessage(Message message, Channel channel) throws Exception &#123;</span><br><span class="line">            super.onMessage(message, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后配置一个处理器，使用这个bean作为其消息来源:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axon.eventhandling.processors[&quot;name&quot;].source=myQueueMessageSource</span><br></pre></td></tr></table></figure><h2 id="使用JGroups分发命令"><a href="#使用JGroups分发命令" class="headerlink" title="使用JGroups分发命令"></a>使用JGroups分发命令</h2><p>进行中…如果你不能等，添加一个依赖项到axon-spring-boot-starter-jgroups模块。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/d843fe8bd7d1" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/d843fe8bd7d1</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Axon支持的SpringBoot自动配置是迄今为止开始配置Axon基础设施组件最简单的选择。只需添加axon-spring-boot-starter依赖性，Axon会自动配置基础设施组件(命令总线，事件总线)，以及运行和储存聚合和Saga所需的任何组件。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-Snapshotting</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-Snapshotting/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-Snapshotting/</id>
    <published>2018-08-31T03:07:08.000Z</published>
    <updated>2018-09-29T07:47:11.178Z</updated>
    
    <content type="html"><![CDATA[<p>当聚合存活很长一段时间，它们的状态不断变化，它们会生成大量的事件。不得不加载所有这些事件去复原一个聚合的状态，可能会有很大的性能影响。快照事件是一个有着特殊用途的领域事件：它将任意数量的事件归纳为单个事件。通过定期创建和存储快照事件，事件存储不必返回长的事件列表。只返回最后一个快照事件和在快照之后发生的所有事件</p><a id="more"></a><p>例如，库存物品往往会经常变化。每销售一件物品，事件就减少一件库存。每次一批新物品进来，库存就增加一些。如果你每天销售一百件，你每天会产生至少100个事件。几天之后，你的系统将会花太多的时间读取所有这些事件，只是为了弄清楚它是否应该raise一个“ItemOutOfStockEvent”。单个快照事件仅仅通过存储当前的库存数量就可以取代很多这些事件。</p><h2 id="Creating-a-snapshot创建一个快照"><a href="#Creating-a-snapshot创建一个快照" class="headerlink" title="Creating a snapshot创建一个快照"></a>Creating a snapshot创建一个快照</h2><p>快照的创建可由多种因素触发，例如，从上次快照创建以来的事件的数量，初始化一个聚合的时候超过了某个阈值，基于时间的，等等。目前，Axon提供了一种机制，允许你基于事件计数阈值触发快照。</p><p>当要创建快照时的定义，由SnapshotTriggerDefinition接口提供。</p><p>当加载聚合所需的事件数量超过一定的阈值时，EventCountSnapshotTriggerDefinition提供触发快照创建的机制。如果加载一个聚合需要的事件的数量超过某个可配置的阈值，触发器告诉Snapshotter为聚合创建一个快照。</p><p>快照触发器在一个事件溯源存储库上配置，并有很多属性允许你调整触发:</p><ul><li>快照设置实际的快照实例，负责创建和存储实际的快照事件;</li><li>触发器设置触发快照创建的阈值;</li></ul><p>Snapshotter负责快照的实际创建。通常，快照是一个应该尽可能少的扰乱操作进程的进程。因此,建议在不同的线程运行Snapshotter。Snapshotter接口声明了单独的方法：scheduleSnapshot()，以聚合的类型和标识符作为参数。</p><p>Axon提供了AggregateSnapshotter，它创建并存储AggregateSnapshot实例。这是一种特殊类型的快照，因为它包含了在它内部的实际的聚合实例。Axon提供的存储库知道这种类型的快照，并从它提取聚合，而不是实例化一个新的。快照事件之后加载的所有事件传输到取出的聚合实例。</p><blockquote><p><b>注意</b><br>确保你使用的序列化器实例(默认为XStreamSerializer)是能够序列化你的聚合的。XStreamSerializer要求使用Hotspot JVM，或者你的聚合要有一个可访问的默认的构造函数或实现Serializable接口。</p></blockquote><p>AbstractSnapshotter提供了一组基本的属性，允许你调整创建快照的方式：</p><ul><li>EventStore设置事件存储，用于加载过去的事件和存储快照。这个事件存储必须实现SnapshotEventStore接口。</li><li>Executor设计executor，比如ThreadPoolExecutor提供了线程来处理实际快照的创建。默认情况下，快照的创建是在线程中调用scheduleSnapshot()方法，一般不建议用于生产。</li></ul><p>AggregateSnapshotter提供另一个属性:</p><ul><li>AggregateFactories是允许你设置创建聚合实例工厂的属性。配置多个聚合工厂允许你使用一个单独的Snapshotter为各种聚合类型创建快照。EventSourcingRepository实现提供了访问他们使用的AggregateFactory。这可以用于配置相同的聚合工厂像在存储库中使用的Snapshotter一样。</li></ul><blockquote><p><b>注意</b><br>如果你使用一个executor在另一个线程中执行快照创建，如果必要的话，确保你为潜在的事件存储配置正确的事务管理。<br>Spring用户可以使用SpringAggregateSnapshotter，当需要创建一个快照时，它将从应用程序上下文自动查找合适的AggregateFactory。</p></blockquote><h2 id="存储快照事件"><a href="#存储快照事件" class="headerlink" title="存储快照事件"></a>存储快照事件</h2><p>当快照存储在事件存储中时，它会自动使用快照归纳所有之前的事件并将其返回到它们的位置。所有事件存储实现允许并发创建快照。这意味着它们允许快照被存储的同时，另一个进程为同一个聚合添加事件。这允许快照进程作为一个完全独立进程。</p><blockquote><p><b>注意</b><br>通常情况下，一旦它们是快照事件的一部分，你就可以归档所有的事件。快照事件将永远不会在常规操作场景中再次读取事件存储。然而,如果你希望能够重建快照创建前一刻的聚合状态，你必须保持事件为最新。</p></blockquote><p>Axon提供了一种特殊类型的快照事件：AggregateSnapshot,它将整个聚合存储为一个快照。动机很简单:你的聚合应该只包含与业务决策相关的的状态。这正是你想要在一个快照中捕获的信息。所有事件溯源存储库由Axon承认的AggregateSnapshot提供，并将从它提取的聚合。注意，使用这个快照事件要求事件序列化机制需要能够对聚合进行序列化。</p><h2 id="根据快照事件初始化聚合"><a href="#根据快照事件初始化聚合" class="headerlink" title="根据快照事件初始化聚合"></a>根据快照事件初始化聚合</h2><p>快照事件是一个和其他事件一样的事件。这意味着一个快照事件就像任何其他领域事件一样被处理。当使用注解来划分事件处理程序(@EventHandler)时，你可以注解一个方法，基于快照事件初始化全部的聚合状态。下面的代码示例演示了，如何像对待任何其他聚合中的领域事件一样对待快照事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyAggregate extends AbstractAnnotatedAggregateRoot &#123;</span><br><span class="line"></span><br><span class="line">    // ... code omitted for brevity</span><br><span class="line"></span><br><span class="line">    @EventHandler</span><br><span class="line">    protected void handleSomeStateChangeEvent(MyDomainEvent event) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @EventHandler</span><br><span class="line">    protected void applySnapshot(MySnapshotEvent event) &#123;</span><br><span class="line">        // the snapshot event should contain all relevant state</span><br><span class="line">        this.someState = event.someState;</span><br><span class="line">        this.otherState = event.otherState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种类型的快照事件处理方式不同:AggregateSnapshot。这种类型的快照事件包含实际的聚合。聚合工厂识别这种类型的事件并从快照中提取聚合。然后，将所有其他事件重新应用到提取的快照。这意味着聚合从不需要能够处理AggregateSnapshot实例自身。</p><h2 id="先进的冲突检测和解决方案"><a href="#先进的冲突检测和解决方案" class="headerlink" title="先进的冲突检测和解决方案"></a>先进的冲突检测和解决方案</h2><p>明确改变的含义作为一个主要的优势，就是你可以更精确地检测冲突的变化。通常,这些冲突的变化，发生在两个用户同时处理相同的数据(几乎)时。想象一下两个用户都查看一个特定版本的数据。他们都决定对这些数据进行修改。他们都将发送一个命令就像“在这个聚合的X版本上，那样做”，其中X是聚合的预期版本。其中一个会将修改实际应用于预期的版本。另一个用户不会。</p><p>当聚合已经被另一个进程修改时，你可以检查用户的意图与任何看不见的修改是否冲突，而不是简单地拒绝所有传入命令。<br>检测冲突，传递一个ConflictResolver类型的参数到你的聚合的 @CommandHandler方法。这个接口提供了detectConflicts方法，允许你在执行特定类型的命令时，定义被认为是冲突的事件类型。</p><blockquote><p><b>注意</b><br>注意ConflictResolver只会包含任何潜在的冲突事件，如果聚合用一个预期的版本加载。使用@TargetAggregateVersion在一个命令的字段上标示聚合的预期的版本。</p></blockquote><p>如果找到事件匹配的断言（predicate），抛出异常(detectConflicts可选的第二个参数允许你定义抛出的异常)。如果没有找到，处理将继续正常进行。</p><p>如果没有调用detectConflicts，并有潜在冲突的事件,@CommandHandler将失败。这可能是提供一个预期的版本的情况下，在@CommandHandler方法的参数中没有可用的ConflictResolver 。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/0cf9c4c0e037" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0cf9c4c0e037</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当聚合存活很长一段时间，它们的状态不断变化，它们会生成大量的事件。不得不加载所有这些事件去复原一个聚合的状态，可能会有很大的性能影响。快照事件是一个有着特殊用途的领域事件：它将任意数量的事件归纳为单个事件。通过定期创建和存储快照事件，事件存储不必返回长的事件列表。只返回最后一个快照事件和在快照之后发生的所有事件&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-事件向上转换</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E4%BA%8B%E4%BB%B6%E5%90%91%E4%B8%8A%E8%BD%AC%E6%8D%A2/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-事件向上转换/</id>
    <published>2018-08-31T03:03:17.000Z</published>
    <updated>2018-09-29T07:47:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于软件应用程序的不断变化的性质，很可能事件定义也随着时间而变化。由于事件存储被认为是只读和只追加（没有修改和删除）的数据源，所以应用程序必须能够读取所有事件，而不管它们何时添加。这时upcasting 出现了。</p><a id="more"></a><p>最初是面向对象编程的一个概念，“一个子类在需要的时候自动转换成超类”，upcasting 概念也可以应用于事件溯源。upcast一个事件意味着将它从原来的结构转换成新的结构。不像OOP的upcasting，事件的upcasting无法全部自动化完成，因为旧的事件对新事件的结构是不了解的。手工编写的Upcasters，必须提供指定如何将旧的结构upcast成新结构。</p><p>Upcasters类，获取一个x版本的输入事件，并且输出为零或更多版本x+1的新事件。此外，upcasters在一个链中被处理，这意味着一个upcaster的输出发送到下一个upcaster的输入。这允许你以增量的方式更新事件，为每一个新事件版次编写一个Upcaster ，使其小、隔离、并且容易理解。</p><blockquote><p><b>注意</b><br>也许upcasting最大的好处是，它允许你做非破坏性重构，即完整的事件历史仍然保持不变。</p></blockquote><p>在本节中，我们将解释如何编写upcaster，描述随着Axon不同的的Upcaster实现，并解释事件的序列化形式如何影响写upcasters。</p><p>允许upcaster看到什么版本的序列化对象被接收，Event Store存储版本号以及事件的完全限定名称。这个版本号是由RevisionResolver生成,在序列化器中配置。Axon提供了几个RevisionResolver的实现，比如AnnotationRevisionResolver，它检查在事件有效负载上的@Revision注解，SerialVersionUIDRevisionResolver 使用Java Serialization API和FixedValueRevisionResolver所定义的serialVersionUID，它总是返回一个预定义的值。后者在注入当前应用程序版本时是有用的。这将允许你看哪个版本的应用程序生成一个特定的事件。</p><p>Maven用户可以使用MavenArtifactRevisionResolver自动使用项目的版本。它使用项目获取的groupId，artifactId版本初始化。因为这只适用由Maven创建的JAR文件,版本不总能通过IDE来解析。如果无法解析版本，则返回null。</p><h2 id="编写一个upcaster"><a href="#编写一个upcaster" class="headerlink" title="编写一个upcaster"></a>编写一个upcaster</h2><p>事件的老版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Revision(&quot;1.0&quot;)</span><br><span class="line">public class ComplaintEvent &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String companyName;</span><br><span class="line"></span><br><span class="line">    // Constructor, getter, setter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新版本的事件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Revision(&quot;2.0&quot;)</span><br><span class="line">public class ComplaintEvent &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String companyName;</span><br><span class="line">    private String complain; // New field</span><br><span class="line"></span><br><span class="line">    // Constructor, getter, setter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Upcaster:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Upcaster from 1.0 revision to 2.0 revision</span><br><span class="line">public class ComplaintEventUpcaster extends SingleEventUpcaster &#123;</span><br><span class="line">    private static SimpleSerializedType targetType = new SimpleSerializedType(ComplainEvent.class.getTypeName(), &quot;1.0&quot;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean canUpcast(IntermediateEventRepresentation intermediateRepresentation) &#123;</span><br><span class="line">        return intermediateRepresentation.getType().equals(targetType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected IntermediateEventRepresentation doUpcast(IntermediateEventRepresentation intermediateRepresentation) &#123;</span><br><span class="line">        return intermediateRepresentation.upcastPayload(</span><br><span class="line">                new SimpleSerializedType(targetType.getName(), &quot;2.0&quot;),</span><br><span class="line">                org.dom4j.Document.class,</span><br><span class="line">                document -&gt; &#123;</span><br><span class="line">                    document.getRootElement().addElement(&quot;complaint&quot;);</span><br><span class="line">                    document.getRootElement().element(&quot;complaint&quot;).setText(&quot;no complaint description&quot;); // Default value</span><br><span class="line">                    return document;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring boot configuration:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AxonConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SingleEventUpcaster myUpcaster() &#123;</span><br><span class="line">        return new ComplaintEventUpcaster();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public JpaEventStorageEngine eventStorageEngine(Serializer serializer,</span><br><span class="line">                                                    DataSource dataSource,</span><br><span class="line">                                                    SingleEventUpcaster myUpcaster,</span><br><span class="line">                                                    EntityManagerProvider entityManagerProvider,</span><br><span class="line">                                                    TransactionManager transactionManager) throws SQLException &#123;</span><br><span class="line">        return new JpaEventStorageEngine(serializer,</span><br><span class="line">                myUpcaster::upcast,</span><br><span class="line">                dataSource,</span><br><span class="line">                entityManagerProvider,</span><br><span class="line">                transactionManager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO - Describe</p><ul><li>Upcasters工作在中间的表现层</li><li>它们更新流到流</li><li>抽象一对一的upcasting实现</li><li>代码示例</li></ul><h2 id="Content-type-conversion（内容类型转换）"><a href="#Content-type-conversion（内容类型转换）" class="headerlink" title="Content type conversion（内容类型转换）"></a>Content type conversion（内容类型转换）</h2><p>一个upcaster工作在给定内容类型上(如dom4j文档)。upcasters之间提供额外的灵活性，内容类型在链接的upcasters之间可能会有所不同。Axon将尝试使用ContentTypeConverters在内容类型之间自动地转换。它将寻找从类型x到类型y最短的路径，执行转换并交值转换成请求的upcaster。考虑到性能因素 ，如果receiving upcaster上的canUpcast方法产生true，转换才会被执行</p><p>ContentTypeConverters可能依赖于使用的序列化器类型。试图把一个byte[]转换成dom4j文档，这没有任何意义，除非使用序列化器把事件作为XML来写。确保UpcasterChain有权访问serializer-specific ContentTypeConverters,你可以通过UpcasterChain的构造函数引用序列化器。</p><blockquote><p><b>提示</b><br>为了达到最佳性能,确保所有upcasters在同一链上(其中一个的输出是另一个的输入)处理相同的内容类型。</p></blockquote><p>如果你需要不是由Axon提供的内容类型转换，你可以使用ContentTypeConverter接口编写一个自己的。<br>XStreamSerializer支持Dom4J像支持 XOM一样作为XML文档表示。JacksonSerializer 支持Jackson的JsonNode。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/e4e943937993" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/e4e943937993</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于软件应用程序的不断变化的性质，很可能事件定义也随着时间而变化。由于事件存储被认为是只读和只追加（没有修改和删除）的数据源，所以应用程序必须能够读取所有事件，而不管它们何时添加。这时upcasting 出现了。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-EventStore实现</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-EventStore%E5%AE%9E%E7%8E%B0/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-EventStore实现/</id>
    <published>2018-08-31T02:52:45.000Z</published>
    <updated>2018-09-29T07:47:10.937Z</updated>
    
    <content type="html"><![CDATA[<p>事件溯源存储库需要一个事件存储（event store）从聚合中存储和加载事件。事件存储提供了一个事件总线的功能，增加了持久化已发布的事件，并能够基于聚合标识符检索事件。</p><a id="more"></a><p>Axon提供了一个开箱即用的事件存储，EmbeddedEventStore。它委托事件实际的存储和检索到EventStorageEngine。<br>有多个EventStorageEngine的实现：</p><h2 id="JpaEventStorageEngine"><a href="#JpaEventStorageEngine" class="headerlink" title="JpaEventStorageEngine"></a>JpaEventStorageEngine</h2><p>JpaEventStorageEngine存储事件在JPA-compatible数据源中。JPA事件存储存储事件在所谓的条目中。这些条目包含事件的序列化形式，以及存储一些领域元数据以快速查找这些条目。使用JpaEventStorageEngine，你必须在你的类路径中有JPA注解(javax.persistence)。</p><p>默认情况下，事件存储需要你配置你的持久化上下文(如在META-INF/persistence.xml中定义)包含DomainEventEntry和SnapshotEventEntry（两者都在org.axonframework.eventsourcing.eventstore.jpa包中)。<br>下面是一个持久化上下文配置的示例配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot; version=&quot;1.0&quot;&gt;</span><br><span class="line">    &lt;persistence-unit name=&quot;eventStore&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt; (1)</span><br><span class="line">        &lt;class&gt;org...eventstore.jpa.DomainEventEntry&lt;/class&gt; (2)</span><br><span class="line">        &lt;class&gt;org...eventstore.jpa.SnapshotEventEntry&lt;/class&gt;</span><br><span class="line">    &lt;/persistence-unit&gt;</span><br><span class="line">&lt;/persistence&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，事件存储有一个特定的持久化单元。然而，你可能会选择将第三行添加到任何其他持久化单元的配置中。<br>本行注册DomainEventEntry(由JpaEventStore使用的类)到持久化上下文。</p><blockquote><p><b>注意</b><br>Axon使用锁来防止两个线程访问相同的聚合。然而，如果在同一数据库上你有多个jvm，这不会帮助你。在这种情况下，你不得不依靠数据库来检测冲突。并发访问事件存储将导致违反主键约束（Key Constraint Violation），因为表允许聚合只能有一个任何序列号的事件，所以，用已有的序列号为现有聚合插入第二个事件将导致错误。<br>JpaEventStorageEngine可以检测这个错误并把它转换成ConcurrencyException。然而，每个数据库系统以不同的方式报告此违规行为。如果你用JpaEventStore注册你的数据源，它将尝试检测数据库的类型，并找出错误代码是一个违反主键约束（Key Constraint Violation）。或者，你可能会提供一个PersistenceExceptionTranslator实例，如果一个给定的异常代表一个违反主键约束（Key Constraint Violation）它能分辨。<br>如果没有提供数据源或PersistenceExceptionTranslator，从数据库驱动程序按原样抛出异常。</p></blockquote><p>默认情况下，JPA事件存储引擎需要一个EntityManagerProvider实现，返回EventStorageEngine使用的EntityManager实例。这还允许应用程序管理所用的持久化上下文。EntityManagerProvider的责任是提供一个正确的EntityManager实例。</p><p>有几个EntityManagerProvider的实现可用，各有不同的需求。SimpleEntityManagerProvider仅在构建时返回EntityManager实例给它。这使得实现成为容器管理上下文一个简单的选择。ContainerManagedEntityManagerProvider作为一种选择，返回默认的持久化上下文，并且它的使用默认通过JPA事件存储。<br>如果你有一个持久化单元称为“myPersistenceUnit”，你希望在JpaEventStore中使用，这就是EntityManagerProvider实现，可能看起来像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyEntityManagerProvider implements EntityManagerProvider &#123;</span><br><span class="line"></span><br><span class="line">    private EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public EntityManager getEntityManager() &#123;</span><br><span class="line">        return entityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PersistenceContext(unitName = &quot;myPersistenceUnit&quot;)</span><br><span class="line">    public void setEntityManager(EntityManager entityManager) &#123;</span><br><span class="line">        this.entityManager = entityManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，JPA事件存储把条目存储在DomainEventEntry和SnapshotEventEntry实体中。虽然在许多情况下这就足够了，你可能会遇到这些实体提供的元数据不够的情况。或者你可能想将不同的聚合类型的事件存储在不同的表。<br>如果是这样,你可以扩展JpaEventStorageEngine。它包含了一些protected方法，你可以重写来调整其行为。</p><blockquote><p><b>警告</b><br>注意持久化提供者，如Hibernate，在它们的EntityManager实现上使用一级缓存。通常，这意味着在查询中使用或返回的所有隶属于EntityManager的实体。它们只有在周围事务被提交或在事务中执行显式“清除”时才被清除。当查询在事务上下文中执行时尤其如此。<br>要解决这个问题，请确保仅仅查询非实体对象。你可以使用JPA的“SELECT new SomeClass(parameters) FROM …”风格的查询来解决这个问题。或者，获取一批事件后调用EntityManager.flush()和EntityManager.clear()。未能这样做当加截大事件流时可能导致OutOfMemoryExceptions。</p></blockquote><h2 id="JDBC-Event-Storage-Engine"><a href="#JDBC-Event-Storage-Engine" class="headerlink" title="JDBC Event Storage Engine"></a>JDBC Event Storage Engine</h2><p>JDBC事件存储引擎使用JDBC连接将事件存储在JDBC兼容的数据存储。通常，这些都是关系数据库。从理论上讲，任何一个JDBC驱动程序都可以用来支持JDBC事件存储引擎。</p><p>类似于JPA，JDBC事件存储引擎将事件存储在条目中。默认情况下，每个事件存储在一个单独的条目中，对应表中的一行。一个表用于事件，另一个用于快照。</p><p>JdbcEventStorageEngine使用ConnectionProvider来获取连接。通常，这些连接可以直接从数据源中获得。然而，Axon会将这些连接绑定到一个工作单元，以便在一个工作单元使用一个连接。这将确保一个单独的事务用于存储所有事件，即使在同一线程中嵌套多个工作单元。</p><blockquote><p><b>注意</b><br>Spring用户建议使用SpringDataSourceConnectionProvider从数据源附加连接到现有的事务。</p></blockquote><h2 id="MongoDB-Event-Storage-Engine"><a href="#MongoDB-Event-Storage-Engine" class="headerlink" title="MongoDB Event Storage Engine"></a>MongoDB Event Storage Engine</h2><p>MongoDB是一个基于文档的NoSQL存储。其可伸缩特性使它适合用于事件存储。Axon提供了MongoEventStorageEngine,使用MongoDB作为数据库支持。它包含在Axon Mongo模块(Maven artifactId axon-mongo)。</p><p>事件存储在两个独立的集合中：一个用于实际的事件流，一个用于快照。</p><p>默认情况下，MongoEventStorageEngine将存储各自的事件在各自的文档。然而，它是可能改变StorageStrategy使用。</p><p>Axon提供的选择是DocumentPerCommitStorageStrategy，为在一个单独的提交中存储所有事件，创建一个单独的文档(即在同一DomainEventStream)。</p><p>在一个单独的文档中存储整个提交的好处在于提交是原子存储的。此外，它只需要对任意数量的事件进行一次往返。缺点是,它变得更加难以直接在数据库中查询事件。例如，当重构领域模型时，如果他们被包含在“commit document”中，很难从一个聚合“transfer”事件到另一个聚合。</p><p>MongoDB不需要很多配置。它所需要的只是对一个存储事件集合的引用，然后你就可以开始了。在生产环境中，你可能想要对集合中的索引进行双重检查。</p><h2 id="Event-Store-Utilities"><a href="#Event-Store-Utilities" class="headerlink" title="Event Store Utilities"></a>Event Store Utilities</h2><p>Axon提供了一些事件存储引擎，可能在某些情况下是有用的。</p><p>SequenceEventStorageEngine是围绕其它两个事件存储引擎的包装器。当读取时,它从这两个事件存储引擎中返回事件。附加事件只是附加到第二个事件存储引擎。出于性能原因使用事件存储两种不同的实现的情况下，这是有用的，例如。第一个是一个更大的，但较慢事件存储，而第二个是优化的快速读取和写入。</p><p>还有一个常驻内存的存储事件EventStorageEngine实现：InMemoryEventStorageEngine。虽然它可能优于任何其他的事件存储，这并不意味着长期生产使用。然而，它在需要事件存储的short-lived工具或测试中非常有用,。</p><h2 id="Influencing-the-serialization-process（影响序列化过程）"><a href="#Influencing-the-serialization-process（影响序列化过程）" class="headerlink" title="Influencing the serialization process（影响序列化过程）"></a>Influencing the serialization process（影响序列化过程）</h2><p>事件存储需要为存储准备一种序列化事件的方法。默认情况下，Axon使用XStreamSerializer，其使用XStream序列化成XML事件。XStream是相当快的，比Java序列化更灵活。此外，XStream序列化的结果是人类可读的。对日志和调试而言非常有用。</p><p>XStreamSerializer可以配置。你可以定义它应该用于某些包、类甚至字段的别名。除了可以缩短潜在的长名称之外，还可以在事件的类定义更改时使用别名。有关别名的更多信息，访问XStream网站。</p><p>另外，Axon还提供了JacksonSerializer，使用Jackson将事件序列化为JSON。当它生成一个更紧凑的序列化形式，它要求类遵守Jackson所要求的约定(或配置)。</p><blockquote><p><b>注意</b><br>使用Java代码(或其他JVM语言)配置序列化器是很容易的。然而，由于它调用方法的局限性，在Spring XML程序上下文看配置它并不那么简单。其中一个选项是创建一个FactoryBean，创建一个XStreamSerializer实例，并配置它的代码。检查 Spring 参考更多的信息。</p></blockquote><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/7ffff660d9a1" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/7ffff660d9a1</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件溯源存储库需要一个事件存储（event store）从聚合中存储和加载事件。事件存储提供了一个事件总线的功能，增加了持久化已发布的事件，并能够基于聚合标识符检索事件。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-存储库</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%AD%98%E5%82%A8%E5%BA%93/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-存储库/</id>
    <published>2018-08-31T02:50:48.000Z</published>
    <updated>2018-09-27T06:22:48.071Z</updated>
    
    <content type="html"><![CDATA[<p>存储库是提供对聚合访问的机制。存储库充当了用于保存数据的实际存储机制的网关。在CQRS中，存储库只需要能够根据他们的惟一标识符找到聚合。任何其他类型的查询，应该在查询数据库中执行。</p><a id="more"></a><p>在Axon Framework中,所有存储库必须实现Repository接口。这个接口规定了三种方法:load(identifier, version)， load(identifier)和newInstance(factoryMethod)。load方法允许你从存储库加载聚合。version可选参数是用来检测并发修改(见Advanced conflict detection and resolution)。newInstance用于注册新创建的聚合到存储库中。</p><p>基于你潜在的持久性存储和审计需求，有一些基础实现提供大了部分存储库所需的基本功能。Axon Framework对保存聚合当前状态的存储库(见Standard Repositories)和那些存储聚合事件的存储库(见 Event Sourcing Repositories)进行了区分。</p><p>注意，存储库接口没有声明delete(identifier)方法。删除聚合是通过在一个聚合内部调用AggregateLifecycle.markDeleted()方法完成的。删除聚合是一个与其他迁移一样的状态迁移，唯一的区别是它在许多情况下是不可逆的。你应该在聚合上创建自己的有意义的方法，来将聚合的状态设置为“已删除”。这也允许你注册你想要发布的任何事件。</p><h2 id="Standard-repositories（标准存储库）"><a href="#Standard-repositories（标准存储库）" class="headerlink" title="Standard repositories（标准存储库）"></a>Standard repositories（标准存储库）</h2><p>标准存储库存储聚合的实际状态。在每次修改后，新的状态将覆盖旧的。这使得命令组件也可以使用应用程序的查询组件使用的相同信息。标准存储库存储聚合的实际状态。这可能取决于你正在创建的应用程序的类型，这是最简单的解决方案。如果是这样的话，Axon提供了一些帮助你实现这样一个存储库的构件。</p><p>Axon为标准存储库提供了一个开箱即用的实现：GenericJpaRepository。它认为聚合是一个有效的JPA实体。它使用EntityManagerProvider配置，EntityManagerProvider提供EntityManager来管理实际的持久化，并且一个类指定聚合的实际类型存储在存储库中。当聚合调用静态AggregateLifecycle.apply()方法时，你也可以通过EventBus去发布事件。</p><p>你也可以轻松实现自己的存储库。在这种情况下，最好从抽象类LockingRepository扩展。作为聚合的包装器类型，建议使用AnnotatedAggregate。看GenericJpaRepository的源码示例。</p><h2 id="Event-Sourcing-repositories（事件溯源存储库）"><a href="#Event-Sourcing-repositories（事件溯源存储库）" class="headerlink" title="Event Sourcing repositories（事件溯源存储库）"></a>Event Sourcing repositories（事件溯源存储库）</h2><p>聚合根能够根据事件重建它们的状态，也可以配置为通过事件溯源存储库加载。这些存储库不存储聚合本身，但存储聚合生成的一系列事件。基于这些事件，可以随时恢复聚合的状态。</p><p>在AxonFramework中，EventSourcingRepository实现提供了任何事件溯源存储库所需的基本功能。这依赖于EventStore(见Implementing your own Event Store)，它抽象了实际的存储机制。</p><p>根据情况，你可以提供一个聚合工厂。AggregateFactory指定了如何创建一个聚合实例。一旦创建了一个聚合，EventSourcingRepository可以使用从事件存储中加载的事件来初始化。Axon Framework自带了一些你可以使用的AggregateFactory实现。如果他们还不够，可以很容易创建你自己的实现。</p><h2 id="GenericAggregateFactory"><a href="#GenericAggregateFactory" class="headerlink" title="GenericAggregateFactory"></a>GenericAggregateFactory</h2><p>GenericAggregateFactory是一种特别的AggregateFactory实现，可用于任何类型的事件溯源聚合根。GenericAggregateFactory创建存储库管理的聚合类型的一个实例。聚合类必须是非抽象的，声明一个默认的不进行初始化的无参构造函数化。<br>GenericAggregateFactory适用于大多数场景，聚合不需要专门注入non-serializable资源。</p><h2 id="SpringPrototypeAggregateFactory"><a href="#SpringPrototypeAggregateFactory" class="headerlink" title="SpringPrototypeAggregateFactory"></a>SpringPrototypeAggregateFactory</h2><p>根据你的架构选择，使用Spring将依赖项注入到聚合中可能是有用的。例如，你可以将查询库注入到你的聚合，以确保某些值的存在(或不存在)。</p><p>注入依赖项到你的聚合，在定义了SpringPrototypeAggregateFactory的Spring上下文中，你需要配置一个聚合根的属性bean。不是使用构造函数创建的常规的实例，而是使用Spring应用程序上下文实例化你聚合。这也将在你的聚合中注入的任何依赖项。</p><h2 id="实现自己的AggregateFactory"><a href="#实现自己的AggregateFactory" class="headerlink" title="实现自己的AggregateFactory"></a>实现自己的AggregateFactory</h2><p>在某些情况下，GenericAggregateFactory不能提供你所需要的东西。例如，你可以有一个抽象的聚合类型与不同的场景的多个实现(例如，PublicUserAccount和BackOfficeAccount都扩展一个帐户)。而不是为每个聚合创建不同的存储库，你可以使用一个单独的存储库，并配置一个AggregateFactory意识到不同的实现。</p><p>聚合工厂大部分的工作是创建未初始化的聚合实例。它必须使用一个给定的聚合标识符和流中的第一个事件。通常，这个事件是一个创建事件，其中包含关于预期聚合类型的提示。你可以使用这些信息来选择一个实现并调用其构造函数。确保没有事件被应用于构造函数；聚合必须未初始化。</p><p>相对于简单的存储库直接加载聚合的实现，基于事件初始化聚合可能是一项耗时的工作,。CachingEventSourcingRepository提供一个可以从中加载聚合的缓存</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/585e95e31704" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/585e95e31704</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存储库是提供对聚合访问的机制。存储库充当了用于保存数据的实际存储机制的网关。在CQRS中，存储库只需要能够根据他们的惟一标识符找到聚合。任何其他类型的查询，应该在查询数据库中执行。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-分发事件</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%88%86%E5%8F%91%E4%BA%8B%E4%BB%B6/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-分发事件/</id>
    <published>2018-08-31T02:47:38.000Z</published>
    <updated>2018-09-29T07:47:11.333Z</updated>
    
    <content type="html"><![CDATA[<p>在某些情况下，有必要发布事件到外部系统,比如消息broker。</p><a id="more"></a><h2 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h2><p>Axon提供了开箱即用的支持从一个AMQP message broker中转递事件和传递事件到broker中，比如Rabbit MQ。</p><h2 id="将事件转发到AMQP-Echange"><a href="#将事件转发到AMQP-Echange" class="headerlink" title="将事件转发到AMQP Echange"></a>将事件转发到AMQP Echange</h2><p>SpringAMQPPublisher将事件转发给一个AMQP Exchange。它使用SubscribableMessageSource初始化，一般是EventBus或EventStore。从理论上讲，这可能是发布者可以订阅的任何事件源。</p><p>要配置SpringAMQPPublisher，只需一个实例定义为Spring Bean。有一些setter方法允许你指定你预期的行为，如事务支持，publisher 确认(如果由broker支持)，和交换名称。</p><p>默认的exchange名称为’Axon.EventBus’</p><blockquote><p><b>注意</b><br>注意，exchanges不会被自动创建。你还必须声明队列、Exchanges 和你希望使用的Bindings 。检查Spring文档了解更多信息。</p></blockquote><h2 id="从AMQP-队列中读取事件"><a href="#从AMQP-队列中读取事件" class="headerlink" title="从AMQP 队列中读取事件"></a>从AMQP 队列中读取事件</h2><p>Spring已经广泛的支持从一个AMQP队列读取消息。然而,这需要与Axon“架桥”，以便这些消息可以从Axon处理，就像它们是常规事件消息一样。</p><p>SpringAMQPMessageSource允许事件处理器从队列中读取消息，而不是事件存储或事件总线。它作为一个Spring AMQP和SubscribableMessageSource之间的适配器需要这些处理器。</p><p>配置SpringAMQPMessageSource最简单的方法，是通过定义一个bean，重写默认的onMessage方法并使用@RabbitListener注解，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SpringAMQPMessageSource myMessageSource(Serializer serializer) &#123;</span><br><span class="line">    return new SpringAMQPMessageSource(serializer) &#123;</span><br><span class="line">        @RabbitListener(queues = &quot;myQueue&quot;)</span><br><span class="line">        @Override</span><br><span class="line">        public void onMessage(Message message, Channel channel) throws Exception &#123;</span><br><span class="line">            super.onMessage(message, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的@RabbitListener注解告诉Spring，这个方法需要被给定队列上的每个消息调用(myQueue的例子)。此方法简单地调用super.onMessage()方法，执行实际事件的发布到已经订阅它的所有处理器。</p><p>订阅这个MessageSource的处理器，将正确的SpringAMQPMessageSource实例传递给订阅处理器的构造函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// in an @Configuration file:</span><br><span class="line">@Autowired</span><br><span class="line">public void configure(EventHandlingConfiguration ehConfig, SpringAmqpMessageSource myMessageSource) &#123;</span><br><span class="line">    ehConfig.registerSubscribingEventProcessor(&quot;myProcessor&quot;, c -&gt; myMessageSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意跟踪处理器与SpringAMQPMessageSource不兼容。</p><h2 id="异步事件处理"><a href="#异步事件处理" class="headerlink" title="异步事件处理"></a>异步事件处理</h2><p>异步处理事件推荐的方法是使用跟踪事件处理器。这个实现可以保证所有事件的处理，甚至在发生系统故障的情况下(假定事件已经被持久化)。</p><p>然而,也有可能在SubscribingProcessor中异步处理事件。要做到这一点，SubscribingProcessor必须用EventProcessingStrategy配置。这种策略可以用来改变事件监听器的调用应如何管理。</p><p>默认策略(DirectEventProcessingStrategy)在传递事件的线程中调用这些事件处理程序。这允许处理器使用现有的事务。</p><p>其他Axon-provided strategy是AsynchronousEventProcessingStrategy。它使用一个Executor异步调用事件侦听器。</p><p>尽管AsynchronousEventProcessingStrategy异步执行，某些事件按顺序处理仍然是可取的。SequencingPolicy定义事件是否必须按顺序处理，并行或两者的结合。策略返回给定事件的序列标识符。如果两个事件的策略返回一个相等的标识符,这意味着他们必须由事件处理程序按顺序处理。一个空序列标识符意味着事件可能与任何其他事件并行处理。</p><p>Axon提供了一些可以使用的通用策略：</p><ul><li>FullConcurrencyPolicy会告诉Axon，事件处理程序可以处理所有并发事件。这意味着需要按特定顺序处理的事件之间没有关系。</li><li>SequentialPolicy告诉Axon，所有活动必须按照顺序进行处理。处理事件的操作将在处理前一个事件完成时开始。</li><li>SequentialPerAggregatePolicy将迫使领域事件从同一聚合顺序处理。然而，事件来自不同聚合可能并发处理。这通常是一个合适的政策，用于事件侦听器更新数据库中聚合的细节。</li></ul><p>除了这些提供的策略之外，你可以定义自己的策略。所有策略都必须实现SequencingPolicy接口。这个接口定义了一个方法getSequenceIdentifierFor，返回值为一个给定的事件序列标识符。返回相等序列标识符的事件必须按顺序处理。产生不同序列标识符的事件可以同时处理。出于性能原因，如果事件可以并行处理任何其他事件，则策略实现应该返回null。这样更快，因为Axon不必检查对事件处理的任何限制条件。</p><p>当使用AsynchronousEventProcessingStrategy时建议明确定义一个ErrorHandler。默认的ErrorHandler传播异常，但在异步执行中没有什么可以传播的，除了Executor。这可能导致事件没有被处理。相反，建议使用一个ErrorHandler报告错误，并允许继续处理。ErrorHandler被配置在SubscribingEventProcessor的构造函数上，还提供了EventProcessingStrategy。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/c333f2c05239" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c333f2c05239</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在某些情况下，有必要发布事件到外部系统,比如消息broker。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
</feed>
