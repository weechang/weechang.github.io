<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>耒耒耒耒耒</title>
  
  <subtitle>张未的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.weechang.xyz/"/>
  <updated>2018-09-29T09:20:15.213Z</updated>
  <id>https://blog.weechang.xyz/</id>
  
  <author>
    <name>张未</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>说一说我所用到的hexo插件</title>
    <link href="https://blog.weechang.xyz/2018/09/29/hexo-plugins/"/>
    <id>https://blog.weechang.xyz/2018/09/29/hexo-plugins/</id>
    <published>2018-09-29T06:52:20.000Z</published>
    <updated>2018-09-29T09:20:15.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在我之前的博文中，介绍了如何用hexo搭建一个自己的博客系统。当然只是简单地搭建，还有很多东西需要补全的。今天我就介绍下，hexo常用插件，以此来丰富你的博客功能、改善用户体验。</p></blockquote><a id="more"></a><p>关于如何使用hexo搭建自己的博客系统，感兴趣的同学可以看我之前的文章<a href="https:blog.weechang.xyz//2018/09/19/六元一个的私有博客系统，了解一下？/" target="_blank" rel="noopener">六元一个的私有博客系统，了解一下？</a>。</p><p>下面将详细介绍，我的博客中所使用到的一些hexo插件，丰富博客功能、改善用户体验。</p><h1 id="字数统计插件"><a href="#字数统计插件" class="headerlink" title="字数统计插件"></a>字数统计插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount</span><br></pre></td></tr></table></figure><p>该插件能够做到统计每一篇文章的字数，以及预估阅读时间。但是如果自身的主题不支持的话，还得自己在主题中添加相关代码。如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;article-word-count&quot;&gt;</span><br><span class="line">&lt;span&gt;</span><br><span class="line">    &lt;i class=&quot;fas fa-file-word&quot;&gt;&lt;/i&gt;</span><br><span class="line">    共&lt;%= wordcount(post.content) %&gt;字，</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;span&gt;</span><br><span class="line">    &lt;i class=&quot;fas fa-clock&quot;&gt;&lt;/i&gt;</span><br><span class="line">    大约需要&lt;%= min2read(post.content) %&gt;分钟</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>添加后就能清楚地看到每篇博文的字数，及大概阅读用时了。</p><img src="/2018/09/29/hexo-plugins/wordcount.png" title="字数统计效果"><h1 id="sitemap-生成插件"><a href="#sitemap-生成插件" class="headerlink" title="sitemap 生成插件"></a>sitemap 生成插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure><p>该插件能够生成网站地图，供搜索引擎蜘蛛爬取所用。</p><h1 id="百度sitemap生成插件"><a href="#百度sitemap生成插件" class="headerlink" title="百度sitemap生成插件"></a>百度sitemap生成插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap</span><br></pre></td></tr></table></figure><p>由于百度蜘蛛的sitemap编写规则与谷歌等有所不同，所以需要针对百度生成一个专门的sitemap，可以使用该插件</p><h1 id="RSS-源生成插件"><a href="#RSS-源生成插件" class="headerlink" title="RSS 源生成插件"></a>RSS 源生成插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure><p>值得注意的是，rss源生成查件不仅仅需要安装，还得配置。需要在你的项目 _config.yml 里面添加配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># RSS plugin</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">type: atom</span><br><span class="line">path: atom.xml</span><br><span class="line">limit: 20</span><br></pre></td></tr></table></figure><h1 id="nofollow-插件"><a href="#nofollow-插件" class="headerlink" title="nofollow 插件"></a>nofollow 插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-autonofollow</span><br></pre></td></tr></table></figure><p>nofollow 插件能够给所有非本站的超链接加上 nofollow 标签，nofollow 标签的意义在于 指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重！</p><p>同时，nofollow插件也需要配置才能生效，同样在你的项目 _config.yml 添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#nofollow not include</span><br><span class="line">nofollow:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">  - blog.unknowns.info</span><br><span class="line">  - yanhaijing.com</span><br><span class="line">  - 友链domain</span><br></pre></td></tr></table></figure><h1 id="百度URL主动提交插件"><a href="#百度URL主动提交插件" class="headerlink" title="百度URL主动提交插件"></a>百度URL主动提交插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit</span><br></pre></td></tr></table></figure><p>百度url主动提交的意义在于，及时主动地向搜索引擎提交你站的新增文章url，对于搜索引擎的及时收录有一定的帮助。当然如果是一个高质量的老站，而且蜘蛛爬取频次很快的站的话，就当我没说过这句话吧。</p><p>需新增配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  # count表示一次提交几条最新的url</span><br><span class="line">  count: 1</span><br><span class="line">  host: 网站域名</span><br><span class="line">  token: 百度站长主动提交处得token</span><br><span class="line">  path: baidu_urls.txt</span><br></pre></td></tr></table></figure><p>token具体查看地址的，百度站长平台-用户中心-站点管理-数据引入-链接提交，token为图中token参数后面的值</p><img src="/2018/09/29/hexo-plugins/baiduurl.png" title="token"><p>另外需要，在修改 _config.yml 的deploy配置选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: baidu_url_submitter</span><br><span class="line">#  type: git</span><br><span class="line">  branch: master</span><br><span class="line">  repo:</span><br><span class="line">    coding: https://git.coding.net/weechang93/weechang93.coding.me.git</span><br><span class="line">    github: https://github.com/weechang/weechang.github.io.git</span><br><span class="line">  bucket: blog.weechang.xyz</span><br></pre></td></tr></table></figure><p><strong>其中deploy的type只能同时存在一个，这就需要在部署与提交url之间相互切换了。</strong></p><h1 id="静态资源压缩插件"><a href="#静态资源压缩插件" class="headerlink" title="静态资源压缩插件"></a>静态资源压缩插件</h1><p>静态资源压缩插件我知道的有两个，一个是全站压缩，一个是可选压缩，先说可选压缩的吧</p><h2 id="可选压缩"><a href="#可选压缩" class="headerlink" title="可选压缩"></a>可选压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-neat</span><br></pre></td></tr></table></figure><p>需要在 _config.yml 增加配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># hexo-neat</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css</span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">  - &apos;**/*.min.css&apos;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">  - &apos;**/*.min.js&apos;</span><br></pre></td></tr></table></figure><p>需要注意的是，css 及 js压缩需要排除掉已经压缩了的资源。另外需要压缩html就不能排除markdown的压缩。</p><h2 id="全站压缩"><a href="#全站压缩" class="headerlink" title="全站压缩"></a>全站压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-all-minifier</span><br></pre></td></tr></table></figure><p>该插件不需要配置，而且不仅能压缩html、css、js 还能压缩图片。所以我选择了这个插件。</p><p>还有个问题就是，压缩就是为了节省空间，毕竟博客放的github或者coding。两者节点都不在大陆，所以网速是个大问题，这才是我选择后者的关键原因，后者没有版权注释，前者有版权注释，感觉注释也是一种浪费啊。不是说版权不重要。</p><p><strong>注意，用压缩插件的时候。如果markdown里面有 pre 标签写的代码的话，建议尽快修改。因为这两个压缩插件对于 pre标签里面的java泛型都不是很友好，都会报错。</strong></p><p>OK，我所用到的hexo插件就介绍到这儿，希望对你有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;在我之前的博文中，介绍了如何用hexo搭建一个自己的博客系统。当然只是简单地搭建，还有很多东西需要补全的。今天我就介绍下，hexo常用插件，以此来丰富你的博客功能、改善用户体验。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Hexo博客" scheme="https://blog.weechang.xyz/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo插件" scheme="https://blog.weechang.xyz/tags/hexo%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>为你的博客添加版权</title>
    <link href="https://blog.weechang.xyz/2018/09/28/%E4%B8%BA%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83/"/>
    <id>https://blog.weechang.xyz/2018/09/28/为你的博客添加版权/</id>
    <published>2018-09-28T06:48:37.000Z</published>
    <updated>2018-09-29T07:47:10.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自己做自建博客也有一段时间了，有转载别人的博客，也有自己动手写博客。在没做独立博客之前，对版权意识并不是那么重视，也没了解过自己文章的收录情况。</p></blockquote><a id="more"></a><p>最近为了提高网站的收录量，开始将一些自己原创的博客放到oschina 等博客平台上去。但是发现自己的文章很快就被收录了，然后被别的权重较高的网站转载。结果就是自己辛辛苦苦写的文章为他人做了嫁衣，还没有自己的署名新。</p><p>于是开始研究为自己文章加上版权信息。人家的hexo博客主题都要自带的版权申明，奈何我的没有，于是只能自己写咯，谁让我要选择这个博客主题呢，谁让我要自己搞独立博客呢。</p><p>因为之前有过自己在博客主题里面添加信息的经历，所以此次添加就比较简单了。因为我的博客主题页面用的是Ejs模板写的，所以需要先写一个Ejs模板，模板主要写的就是版权的布局内容。</p><p>copyright.ejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;lt;% if (!index || !post.excerpt) &#123; %&gt;</span><br><span class="line">    &amp;lt;div class=&quot;post-copyright&quot;&gt;</span><br><span class="line">        &amp;lt;div class=&quot;author&quot;&gt;</span><br><span class="line">            &amp;lt;b&gt;本文作者： &amp;lt;/b&gt;</span><br><span class="line">           post.author</span><br><span class="line">        &amp;lt;/div&gt;</span><br><span class="line">        &amp;lt;div class=&quot;link&quot;&gt;</span><br><span class="line">            &amp;lt;b&gt;本文链接： &amp;lt;/b&gt;</span><br><span class="line">            &amp;lt;a href=&quot; &amp;lt;%= post.permalink %&gt;&quot; target=&quot;_blank&quot;&gt; &amp;lt;%= post.permalink %&gt; &amp;lt;/a&gt;</span><br><span class="line">        &amp;lt;/div&gt;</span><br><span class="line">        &amp;lt;div class=&quot;copyright&quot;&gt;</span><br><span class="line">            &amp;lt;b&gt; 版权声明： &amp;lt;/b&gt;</span><br><span class="line">           本博客所有文章除特别声明外，均采用  &amp;lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0 &amp;lt;/a&gt; 许可协议。转载请注明出处！</span><br><span class="line">        &amp;lt;/div&gt;</span><br><span class="line">    &amp;lt;/div&gt;</span><br><span class="line">&amp;lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>然后找到文章的布局模板,我是用的模板，文章布局模板文件是 article.ejs ，将 copyright.ejs 在你想要显示的地方插入。我是添加在文末，标签及分享按钮之前。所以插入位置如下</p><img src="/2018/09/28/为你的博客添加版权/插入.png" title="模板插入"><p>然后通过js文件调试自己的版权布局样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.post-copyright</span><br><span class="line">  padding: 20px</span><br><span class="line">  background: #F6F6F6</span><br><span class="line">  border-left: 4px solid #DDDDDD</span><br><span class="line">  line-height: 1.6rem</span><br></pre></td></tr></table></figure><p>Ok，大功告成。启动预览，点击文章。可以发现文章已经加入了版权信息，好开心啊。</p><p>这样人家的爬虫爬取你的文章的时候，就会加入你的定制版权信息了。就算转载了你的文章，也能在一定程度上增加你网站的外链。</p><p>另外，在自己原创文章发布后，可以立即向百度等搜索引擎提交自己的链接，这样对于收录也是有一定的好处的。</p><p><strong>另外，转载文章不留出处的方式，真的很恶心，希望大家都能尊重人家的劳动成果，加上署名及出处</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;自己做自建博客也有一段时间了，有转载别人的博客，也有自己动手写博客。在没做独立博客之前，对版权意识并不是那么重视，也没了解过自己文章的收录情况。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Hexo博客" scheme="https://blog.weechang.xyz/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="版权" scheme="https://blog.weechang.xyz/tags/%E7%89%88%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>记一次SQL优化</title>
    <link href="https://blog.weechang.xyz/2018/09/27/%E8%AE%B0%E4%B8%80%E6%AC%A1SQL%E4%BC%98%E5%8C%96/"/>
    <id>https://blog.weechang.xyz/2018/09/27/记一次SQL优化/</id>
    <published>2018-09-27T06:31:52.000Z</published>
    <updated>2018-09-29T07:47:11.418Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近收到项目的慢查询报警，刚好手上空下来了，就准备做一些优化。特开此贴记录一下此次的优化详情。</p></blockquote><a id="more"></a><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>由于项目保密原因，因此很多字段采取保密写法，望各位看官见谅。</p><p>其实呢，整个表的数据量其实也不大，也就170W+。字段大概在65个左右，除了几个单号，几个内容这种稍大一点的字段外，其他的基本都是状态和关联id的字段。所以行大小也不大。</p><p>但是，上个月的时候，产品提出一个需要根据单号模糊查询的功能，就是这个功能，导致了慢查询。优化前，根据现有逻辑以及模糊查询的需求，大概的sql是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">id,</span><br><span class="line">work_order_num AS workOrderNum,</span><br><span class="line">content,</span><br><span class="line">OTHERS_COLUMNS...</span><br><span class="line">FROM</span><br><span class="line">work_order</span><br><span class="line">WHERE</span><br><span class="line">work_order_num LIKE &apos;%201808221644820%&apos;</span><br><span class="line">AND sender_id = 11768</span><br><span class="line">AND status IN (2, 1, 0)</span><br><span class="line">AND record_status IN (4, 2)</span><br><span class="line">AND (locked = 0 OR locked = 2)</span><br><span class="line">AND yn = 1</span><br><span class="line">ORDER BY</span><br><span class="line">create_time DESC</span><br><span class="line">LIMIT 0, 10</span><br></pre></td></tr></table></figure><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>其中，上述Sql中，条件中的字段 work_order_num、sender_id 都是建了索引的，以下是慢查询统计情况</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>total_count</td><td>19</td></tr><tr><td>total_time</td><td>133.23</td></tr><tr><td>avg_time</td><td>7.01</td></tr><tr><td>max_time</td><td>7.6426</td></tr><tr><td>avg_return_rows</td><td>0.79</td></tr><tr><td>max_return_rows</td><td>1</td></tr><tr><td>avg_examined_rows</td><td>1695975.47</td></tr><tr><td>max_examined_rows</td><td>1734740</td></tr></tbody></table><p>可以看见的是，慢查询基本都是全表扫描。为什么会这样呢，我具体执行了一下Sql发现，以上条件根本就查不出数据啊。然后修改条件发现，是工单号有问题。该工单号不存在，，，不存在啊。所以导致了全表扫描。</p><h1 id="调优进行时"><a href="#调优进行时" class="headerlink" title="调优进行时"></a>调优进行时</h1><p>首先想的是去掉like 特别是like的左匹配，试了一下，去掉左匹配，速度能减少到50%。虽然有效，但是业务不允许这样做。</p><p>然后考虑的是用instr函数代替like，测试了一下，能够减少1S的时间，但是对于7S的查询来说，这TM有什么效果。还是不行。</p><p>最后想到了一次案例分享中的，先用子查询查询出符合条件的id，再用id作为筛选条件，去获取所有的列。最后修改后的sql如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">id,</span><br><span class="line">work_order_num AS workOrderNum,</span><br><span class="line">content,</span><br><span class="line">OTHERS_COLUMNS...</span><br><span class="line">FROM</span><br><span class="line">work_order</span><br><span class="line">WHERE</span><br><span class="line">id IN (</span><br><span class="line">SELECT</span><br><span class="line">id</span><br><span class="line">FROM</span><br><span class="line">ws_work_order</span><br><span class="line">WHERE</span><br><span class="line">work_order_num LIKE &apos;%201808221644820%&apos;</span><br><span class="line">AND sender_id = 11768</span><br><span class="line">AND STATUS IN (2, 1, 0)</span><br><span class="line">AND record_status IN (4, 2)</span><br><span class="line">AND (locked = 0 OR locked = 2)</span><br><span class="line">AND yn = 1</span><br><span class="line">)</span><br><span class="line">ORDER BY</span><br><span class="line">create_time DESC</span><br><span class="line">LIMIT 0, 10</span><br></pre></td></tr></table></figure><p>运行一下试试，，，果然，时间减少到了 0.03xxS。看着就有点小激动啊。</p><h1 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h1><p>原理呢，暂时忘了，先挖一个坑，等我想起了，再回来填坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近收到项目的慢查询报警，刚好手上空下来了，就准备做一些优化。特开此贴记录一下此次的优化详情。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="MySql" scheme="https://blog.weechang.xyz/tags/MySql/"/>
    
      <category term="Sql" scheme="https://blog.weechang.xyz/tags/Sql/"/>
    
  </entry>
  
  <entry>
    <title>论如何优雅地使用爬虫摸鱼</title>
    <link href="https://blog.weechang.xyz/2018/09/21/%E8%AE%BA%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%88%AC%E8%99%AB%E6%91%B8%E9%B1%BC/"/>
    <id>https://blog.weechang.xyz/2018/09/21/论如何优雅地使用爬虫摸鱼/</id>
    <published>2018-09-21T08:05:11.000Z</published>
    <updated>2018-09-29T07:47:10.876Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近手上项目空了下来，没什么事做。博客博客不想写，文章文章不想看。于是干脆看点小说吧，但是上班时间，大家都在认认真真敲代码，自己拿出手机看小说又不是很好（其实主要是数据线坏了，在公司没发充电），电脑上浏览器看，更是不行。于是想了想，干脆就自己爬着看吧，把内容打印在IDE的控制台，想一想这波操作就很骚，于是说动就动。</p></blockquote><a id="more"></a><h1 id="爬虫选择"><a href="#爬虫选择" class="headerlink" title="爬虫选择"></a>爬虫选择</h1><p>由于本人是一枚正经的Javaer，所以爬虫当然也要用Java咯。Java下也有几款比较好的爬虫软件，如nutch、crawler4j 等。但是我只是爬个网页，看个小说而已啊。于是就选了个Jsoup，直接解析Html信息，从中提取小说内容。</p><p>其实选择Jsoup还有个原因就是我好歹写过一阵子jQuery，对jQuery语法比较熟悉。因为Jsoup语法与jQuery语法非常一致。</p><h1 id="开始动工"><a href="#开始动工" class="headerlink" title="开始动工"></a>开始动工</h1><p>添加maven依赖<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;lt;dependency&gt;</span><br><span class="line">    &amp;lt;groupId&gt; org.jsoup &amp;lt;/groupId&gt;</span><br><span class="line">    &amp;lt;artifactId&gt; jsoup &amp;lt;/artifactId&gt;</span><br><span class="line">    &amp;lt;version&gt; 1.9.2 &amp;lt;/version&gt;</span><br><span class="line">&amp;lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p></p><h1 id="爬取页面信息"><a href="#爬取页面信息" class="headerlink" title="爬取页面信息"></a>爬取页面信息</h1><p>Jsoup的爬取方式十分简单，是通过获取html文档到本地，然后再用jQuery的解析方式做的DOM解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class BiQuGeCrawler extends AbstractCrawler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getPage(String url) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            page = Jsoup.connect(url).get();</span><br><span class="line"></span><br><span class="line">            this.getNext();</span><br><span class="line">            this.getLast();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return this.getContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String getContent()&#123;</span><br><span class="line">        Element cntEl = page.getElementById(&quot;content&quot;);</span><br><span class="line">        // 八个空格，（制表符号）</span><br><span class="line">        return cntEl.text().replaceAll(&quot;        &quot;, &quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void getNext() &#123;</span><br><span class="line">        Element ul = page.getElementsByClass(&quot;page_chapter&quot;).get(0).child(0);</span><br><span class="line">        Element nextHref = ul.child(2).child(0);</span><br><span class="line">        nextUrl = nextHref.attr(&quot;abs:href&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void getLast() &#123;</span><br><span class="line">        Element ul = page.getElementsByClass(&quot;page_chapter&quot;).get(0).child(0);</span><br><span class="line">        Element lastHref = ul.child(0).child(0);</span><br><span class="line">        lastUrl = lastHref.attr(&quot;abs:href&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取小说正文内容及前一页、后一页链接等关键信息。</p><h1 id="设置翻页及退出"><a href="#设置翻页及退出" class="headerlink" title="设置翻页及退出"></a>设置翻页及退出</h1><p>每次抓取完页面后，监听控制台输入值，进行翻页、退出操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Function &#123;</span><br><span class="line"></span><br><span class="line">    // app配置</span><br><span class="line">    private AppConfig config;</span><br><span class="line">    // 爬虫类</span><br><span class="line">    private AbstractCrawler crawler;</span><br><span class="line"></span><br><span class="line">    public Function(String firstUrl)&#123;</span><br><span class="line">        config = new AppConfig();</span><br><span class="line">        crawler =  CrawlerFactory.build(config.sourceType);</span><br><span class="line">        startView(firstUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 页面浏览</span><br><span class="line">    private void startView(String pageUrl)&#123;</span><br><span class="line">        String content = crawler.getPage(pageUrl);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        this.inputListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 开始浏览</span><br><span class="line">    private void inputListener()&#123;</span><br><span class="line">        System.out.println(&quot;*************&quot;);</span><br><span class="line">        System.out.println(&quot;* L 上一页   *&quot;);</span><br><span class="line">        System.out.println(&quot;* Q 退出     *&quot;);</span><br><span class="line">        System.out.println(&quot;* 其他 下一页 *&quot;);</span><br><span class="line">        System.out.println(&quot;*************&quot;);</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String input = sc.nextLine();</span><br><span class="line">        if (&quot;l&quot;.equalsIgnoreCase(input))&#123;</span><br><span class="line">            // 上一页</span><br><span class="line">            startView(crawler.lastUrl);</span><br><span class="line">        &#125; else if (&quot;q&quot;.equalsIgnoreCase(input))&#123;</span><br><span class="line">            // 退出</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 下一页</span><br><span class="line">            startView(crawler.nextUrl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，整个摸鱼神器的关键代码就已经完成了，具体的完整代码，可以查看<a href="https://github.com/weechang/ReadingCrawler" rel="external nofollow noopener noreferrer" target="_blank">我的github项目</a></p><h1 id="Run一下"><a href="#Run一下" class="headerlink" title="Run一下"></a>Run一下</h1><p>首先配置需要看的小说网页信息及个人操作习惯设置。然后通过运行main方法。即可运行。</p><img src="/2018/09/21/论如何优雅地使用爬虫摸鱼/Run.png" title="效果预览"><h1 id="后续支持"><a href="#后续支持" class="headerlink" title="后续支持"></a>后续支持</h1><p>OK，到此爬虫已经能够正常爬取小说内容了。并且已经实现翻页、退出等基本功能。后续将支持更多小说来源如 <strong>纵横综合网</strong> 等网站。以及更多的功能如 <strong>日志混淆</strong>、 <strong>日志格式化</strong> 、<strong>断点续看</strong> 等功能。</p><p><strong>本文章涉及的代码已托管到github，欢迎各位客官使用<a href="https://github.com/weechang/ReadingCrawler" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/weechang/ReadingCrawler</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近手上项目空了下来，没什么事做。博客博客不想写，文章文章不想看。于是干脆看点小说吧，但是上班时间，大家都在认认真真敲代码，自己拿出手机看小说又不是很好（其实主要是数据线坏了，在公司没发充电），电脑上浏览器看，更是不行。于是想了想，干脆就自己爬着看吧，把内容打印在IDE的控制台，想一想这波操作就很骚，于是说动就动。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="爬虫" scheme="https://blog.weechang.xyz/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Jsoup" scheme="https://blog.weechang.xyz/tags/Jsoup/"/>
    
  </entry>
  
  <entry>
    <title>IDEA、WebStorm最新永久激活方式</title>
    <link href="https://blog.weechang.xyz/2018/09/21/IDEA%E3%80%81WebStorm%E6%9C%80%E6%96%B0%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB%E6%96%B9%E5%BC%8F/"/>
    <id>https://blog.weechang.xyz/2018/09/21/IDEA、WebStorm最新永久激活方式/</id>
    <published>2018-09-21T05:22:40.000Z</published>
    <updated>2018-09-29T08:37:32.625Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天早上一大早打开IDEA发现激活已过期，遂开始寻找激活码。但是一直不成功，后来终于找到一种比较靠谱的激活方式。在此记录下来，以备不时之需。</p></blockquote><a id="more"></a><p>目前网上现有的激活方式大概有这么三种</p><h1 id="激活码"><a href="#激活码" class="headerlink" title="激活码"></a>激活码</h1><p>这种方式一般是给出一段激活码，然后有些还需要改host。目前这种方式，很多激活码都不能使用了，就算能使用可能到了某一天你会发现他用不了了。所以不太推荐这种方式。</p><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>这种方式一般是填写一个服务器地址就行了，但是现在很多服务器都被官方封了。没被封的也在被封的路上。</p><h1 id="自建服务器"><a href="#自建服务器" class="headerlink" title="自建服务器"></a>自建服务器</h1><p>这种方式比较靠谱，自己搭建一个认证服务器。但是对于没有服务器的穷人来说，也是一个巨大的挑战。所以不是特别推荐。</p><p>接下来就推荐一种比较靠谱的方式。</p><h1 id="插件激活"><a href="#插件激活" class="headerlink" title="插件激活"></a>插件激活</h1><p>这种方式呢目前而言比较靠谱，由于插件在本地，不存在官方封域名及IP的说法，但是不排除被后期修复的问题。至少目前而言是没问题的，亲自验证过IDEA2017.3.5与2018.2是没有任何问题的。</p><p>下面将具体介绍这种方式的操作方法。</p><h2 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h2><p>首先下载插件jar包 <a href="http://idea.lanyus.com/jar/JetbrainsCrack-3.1-release-enc.jar" rel="external nofollow noopener noreferrer" target="_blank">http://idea.lanyus.com/jar/JetbrainsCrack-3.1-release-enc.jar</a></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>然后将插件移动到 IDEA 安装目录的bin下。如我的目录 D:\idea\IntelliJ IDEA 2018.2.4\bin</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>修改 IDEA 安装bin目录下的 idea64.exe.vmoptions 或者 idea.exe.vmoptions 具体修改哪一个看自己操作系统是64 位还是32位。64位修改 idea64.exe.vmoptions ， 32位修改 idea.exe.vmoptions。</p><img src="/2018/09/21/IDEA、WebStorm最新永久激活方式/配置文件.png" title="配置文件"><p>然后在文件末尾添加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:D:\idea\IntelliJ IDEA 2018.2.4\bin\JetbrainsCrack-3.1-release-enc.jar</span><br></pre></td></tr></table></figure><p>其中 D:\idea\IntelliJ IDEA 2018.2.4\bin\JetbrainsCrack-3.1-release-enc.jar 为插件的安装路径和文件名。注意，目录和文件名一定要一直，不然IDEA不能启动</p><img src="/2018/09/21/IDEA、WebStorm最新永久激活方式/修改配置.png" title="修改配置"><h2 id="重启IDEA、填写CODE"><a href="#重启IDEA、填写CODE" class="headerlink" title="重启IDEA、填写CODE"></a>重启IDEA、填写CODE</h2><p>重启IDEA，选择Activation Code填写激活码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ThisCrackLicenseId-&#123;</span><br><span class="line">&quot;licenseId&quot;:&quot;ThisCrackLicenseId&quot;,</span><br><span class="line">&quot;licenseeName&quot;:&quot;你想填的用户名&quot;,</span><br><span class="line">&quot;assigneeName&quot;:&quot;&quot;,</span><br><span class="line">&quot;assigneeEmail&quot;:&quot;你想填的邮箱&quot;,</span><br><span class="line">&quot;licenseRestriction&quot;:&quot;For This Crack, Only Test! Please support genuine!!!&quot;,</span><br><span class="line">&quot;checkConcurrentUse&quot;:false,</span><br><span class="line">&quot;products&quot;:[</span><br><span class="line">&#123;&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;</span><br><span class="line">],</span><br><span class="line">&quot;hash&quot;:&quot;2911276/0&quot;,</span><br><span class="line">&quot;gracePeriodDays&quot;:7,</span><br><span class="line">&quot;autoProlongated&quot;:false&#125;</span><br></pre></td></tr></table></figure><img src="/2018/09/21/IDEA、WebStorm最新永久激活方式/激活码.png" title="激活码"><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><p>OK，至此为止，你的IDEA 就激活成功，又可以继续浪了。</p><p><strong>Web Storm 激活步骤与此相同</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;今天早上一大早打开IDEA发现激活已过期，遂开始寻找激活码。但是一直不成功，后来终于找到一种比较靠谱的激活方式。在此记录下来，以备不时之需。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://blog.weechang.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="IDEA永久激活" scheme="https://blog.weechang.xyz/tags/IDEA%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/"/>
    
      <category term="WebStorm永久激活" scheme="https://blog.weechang.xyz/tags/WebStorm%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>六元一个的私有博客系统，了解一下？</title>
    <link href="https://blog.weechang.xyz/2018/09/19/%E5%85%AD%E5%85%83%E4%B8%80%E4%B8%AA%E7%9A%84%E7%A7%81%E6%9C%89%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F/"/>
    <id>https://blog.weechang.xyz/2018/09/19/六元一个的私有博客系统，了解一下？/</id>
    <published>2018-09-19T06:33:09.000Z</published>
    <updated>2018-09-29T07:47:10.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神说要有光，于是便有了光"><a href="#神说要有光，于是便有了光" class="headerlink" title="神说要有光，于是便有了光"></a>神说要有光，于是便有了光</h1><p>写代码的，偶尔都想装点逼，想要自己写点博客。刚开始还能在各大社区写，比如说CSDN，开源中国，博客园什么的。但是越写就会越觉得，那些博客平台都不是自己想要的，虽然大平台，能够提高在搜索引擎的收录，但是我看着别人的博客，我也想要有一个自建的博客系统。于是开始了自建博客的入坑之旅，在这儿给大伙分享一下我的自建博客历程。</p><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>因为自己不是很懂，网上找的资料也很分散。所以整个历程大概经历了四天左右才把自己的博客系统搞好。首先需要准备以下资源</p><ol><li>github账号（应该都有吧，没有的自己去注册一个）<a href="https://www.github.com" target="_blank" rel="external nofollow noopener noreferrer">传送门</a></li><li>选择一个你喜欢的hexo主题，这个网上太多了。可以去<a href="http://hexo.io/themes/" target="_blank" rel="external nofollow noopener noreferrer">hexo官网</a>，或者<a href="https://github.com/search?q=hexo" target="_blank" rel="external nofollow noopener noreferrer">github</a>上看看</li><li>准备一个nodeJS环境，具体怎么搞，可以度娘一下 <a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="external nofollow noopener noreferrer">windows传送门</a>，<a herf="https://www.cnblogs.com/BinXu/p/6050850.html" target="_blank">Mac 传送门</a></li><li>一个阿里云账号（如果使用github提供的域名的话，这个可以省了）</li></ol><h1 id="新建github项目"><a href="#新建github项目" class="headerlink" title="新建github项目"></a>新建github项目</h1><p>新建github项目时项目命名规则为{username}.github.io如我的github用户名为weechang。则项目命名为weechang.github.io。<br><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/新建项目.png" title="新建项目"></p><p><strong>注意：命名规则必须按照这个规则来。</strong></p><h1 id="github项目配置"><a href="#github项目配置" class="headerlink" title="github项目配置"></a>github项目配置</h1><p>创建成功后就可以配置github项目了。github会自动根据项目名识别是否为github pages项目。如果是github pages项目，会出现github pages配置项目。在此，可以设置github pages项目所在分支及自定义域名等信息。<br><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/github项目配置.png" title="github项目配置"></p><p><strong>注意：自定义域名通过cname方式解析，由于github服务器在国外，所以可以不用备案。</strong></p><h1 id="查看页面"><a href="#查看页面" class="headerlink" title="查看页面"></a>查看页面</h1><p>在浏览器输入 http://{username}.github.io 即可访问你的个人页面。如: <a href="http://weechang.github.io" rel="external nofollow noopener noreferrer" target="_blank">http://weechang.github.io</a></p><p>如果访问不了页面，请检查以下问题：</p><ul><li>1.项目名是否准确</li><li>2.域名是否解析到了指定cname地址</li><li>3.分支选择是否正确</li></ul><h1 id="安装hexo客户端"><a href="#安装hexo客户端" class="headerlink" title="安装hexo客户端"></a>安装hexo客户端</h1><p>打开cmd命令行，选择一个你喜欢的目录（建议可以用git从github克隆工程到本地的本地目录），输入安装命令，开始安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/安装hexo客户端.png" title="安装hexo客户端"><p>安装完成后，输入命令，检查hexo是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/检查hexo.png" title="检查hexo"><h1 id="初始化项目文件夹"><a href="#初始化项目文件夹" class="headerlink" title="初始化项目文件夹"></a>初始化项目文件夹</h1><p>在项目文件夹下输入初始化命令，进行初始化（此处如果实在克隆项目进行的话，建议新建一个分支，比如我的就是hexo分支，该分支用来管理博客源文件与配置。当然如果想要新建项目管理这些东西的话，当我没说）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>hexo组件初始化完成后。需要安装依赖包,输入命令即可安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h1 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h1><p>OK到了此处,你的博客系统已经可运行了。</p><p><strong>首先</strong>，生成博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate // 或者 hexo g</span><br></pre></td></tr></table></figure><p><strong>本地部署</strong>，本地运行、预览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server // 或者 hexo s</span><br></pre></td></tr></table></figure><p>web服务启动后，在浏览器输入给出的预览地址，即可预览</p><p>如下，是我的本地预览效果图</p><img src="/2018/09/19/六元一个的私有博客系统，了解一下？/预览.png" title="本地预览"><p><strong>推送到github</strong></p><p>通过hexo 配置，即可将生成的页面推送到github</p><p>修改_config.yml文件。配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  branch: master</span><br><span class="line">  repo:</span><br><span class="line">    github: https://github.com/weechang/weechang.github.io.git</span><br><span class="line">  bucket: blog.weechang.xyz</span><br></pre></td></tr></table></figure><p>通过命令推送到github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy // 或者 hexo d</span><br></pre></td></tr></table></figure><p>推送完毕后，即可通过访问 http://{username}.github.io 访问你刚部署的博客系统（由于服务器缓存等原因，可能需要等几分钟才能访问到最新页面）。</p><p>OK，至此为止。最基本的博客系统就构建完成了。如果需要了解更详细的信息，可以继续关注我的相关文章。</p><p>若有疑问可以查看我的项目配置 <a href="https://github.com/weechang/weechang.github.io" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/weechang/weechang.github.io</a></p><p>该项目 master分支是生成的博客文章信息。hexo是博客源码。如有疑惑之处，欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;神说要有光，于是便有了光&quot;&gt;&lt;a href=&quot;#神说要有光，于是便有了光&quot; class=&quot;headerlink&quot; title=&quot;神说要有光，于是便有了光&quot;&gt;&lt;/a&gt;神说要有光，于是便有了光&lt;/h1&gt;&lt;p&gt;写代码的，偶尔都想装点逼，想要自己写点博客。刚开始还能在各大社区写，比如说CSDN，开源中国，博客园什么的。但是越写就会越觉得，那些博客平台都不是自己想要的，虽然大平台，能够提高在搜索引擎的收录，但是我看着别人的博客，我也想要有一个自建的博客系统。于是开始了自建博客的入坑之旅，在这儿给大伙分享一下我的自建博客历程。&lt;/p&gt;
    
    </summary>
    
      <category term="开源之路" scheme="https://blog.weechang.xyz/categories/%E5%BC%80%E6%BA%90%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="手把手教学" scheme="https://blog.weechang.xyz/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6/"/>
    
      <category term="Hexo博客" scheme="https://blog.weechang.xyz/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="GitHub Pages" scheme="https://blog.weechang.xyz/tags/GitHub-Pages/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-事件序列化器调优</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E4%BA%8B%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E8%B0%83%E4%BC%98/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-事件序列化器调优/</id>
    <published>2018-08-31T03:20:34.000Z</published>
    <updated>2018-09-27T06:22:48.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XStream序列化器"><a href="#XStream序列化器" class="headerlink" title="XStream序列化器"></a>XStream序列化器</h2><p>XStream是完全可配置和可扩展的。如果你只使用一个无格式XStreamSerializer，有一些速效方案随时取用。<br><a id="more"></a></p><p>XStream允许你为包名称和事件类名称配置别名。别名通常更短(特别是如果你有长包名)，使事件的序列化形式更小。由于我们讨论的是XML，所以每个字符从XML中移除是两次(一个开始标记，一个结束标记)。</p><p>在XStream中一个更高级的话题创建自定义转换器。默认的基于反射的转换器是简单的，但不会生成最紧凑的XML。总是仔细观察生成的XML，看看是否真正需要重建原始实例的所有信息。</p><p>如果有可能避免upcasters的使用。XStream允许别名用于字段，当他们已经改变了名字。想象版本为0事件,使用一个名为“clientId”字段。业务更喜欢“客户”一词，所以版本1使用被称为“customerId”的字段创建。在XStream中这个使用字段别名完全可以配置。你需要配置两个别名，按照以下顺序：别名“customerId”到“clientId”然后别名“customerId”到“customerId”。这将告诉XStream，如果遇到一个叫做“customerId”字段，它将调用相应的XML元素“customerId”(第二个别名覆盖第一个)。但如果XStream遇到一个XML称为“clientId”的元素，这是一个已知的别名，将解析为字段名称“customerId”。查看XStream文档了解更多信息。</p><p>对于终极性能，没有基于反射机制的alltogether你可能更好。在这种情况下，创建一个自定义的序列化机制，这可能是最明智的。DataInputStream和DataOutputStream允许你容易将事件的内容写入输出流。ByteArrayOutputStream和ByteArrayInputStream允许写入和读取字节数组。</p><h2 id="防止重复序列化"><a href="#防止重复序列化" class="headerlink" title="防止重复序列化"></a>防止重复序列化</h2><p>特别是在分布式系统中，事件消息需要在多个场合进行序列化。Axon的组件检测这个并支持SerializationAware消息。如果检测到SerializationAware消息，其方法用来序列化一个对象,而不是简单地传递载荷到序列化器。这允许对性能进行优化。</p><p>当你序列化你自己消息时，希望受益于SerializationAware优化，使用MessageSerializer类序列化消息的有效负载和元数据。所有优化逻辑是在这个类中实现。更多细节请参考MessageSerializer的JavaDoc。</p><h2 id="自定义标识符生成器"><a href="#自定义标识符生成器" class="headerlink" title="自定义标识符生成器"></a>自定义标识符生成器</h2><p>AxonFramework使用IdentifierFactory生成所有的标识符，不论它们是事件或命令。默认情况下，IdentifierFactory随机生成基于java.util.UUID的标识符。尽管它们使用起来非常安全，但生成它们的过程的性能并出色。</p><p>IdentifierFactory是一个抽象工厂，使用Java的ServiceLoader(从Java 6)机制找到实现来使用。这意味着你可以创建自己的工厂的实现，将实现的名称放在一个叫做“/META-INF/services/org.axonframework.common.IdentifierFactory”文件中。Java的ServiceLoader机制将检测到文件并尝试创建名为inside类的实例。</p><p>IdentifierFactory有几个的需求。必须实现：</p><ul><li>在类路径中让它的完全限定类名作为/META-INF/services/org.axonframework.common.IdentifierFactory文件的内容,</li><li>有一个可访问的无参数构造函数,</li><li>扩展IdentifierFactory,</li><li>通过应用程序的类加载器上下文或类加载器加载IdentifierFactory类来访问，并且必须的</li><li>是线程安全的。</li></ul><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/801dade37318" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/801dade37318</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XStream序列化器&quot;&gt;&lt;a href=&quot;#XStream序列化器&quot; class=&quot;headerlink&quot; title=&quot;XStream序列化器&quot;&gt;&lt;/a&gt;XStream序列化器&lt;/h2&gt;&lt;p&gt;XStream是完全可配置和可扩展的。如果你只使用一个无格式XStreamSerializer，有一些速效方案随时取用。&lt;br&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-高级定制</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E9%AB%98%E7%BA%A7%E5%AE%9A%E5%88%B6/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-高级定制/</id>
    <published>2018-08-31T03:14:03.000Z</published>
    <updated>2018-09-27T06:22:48.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参数解析器"><a href="#参数解析器" class="headerlink" title="参数解析器"></a>参数解析器</h2><p>你可以配置额外的ParameterResolvers，通过扩展ParameterResolverFactory类和创建一个名为/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory的文件，包含实现类的完全限定名称。</p><a id="more"></a><blockquote><p><b>警告</b><br>此时，OSGi支持仅限于在清单文件中被提到的所需的头这一事实。ParameterResolverFactory实例的自动检测在OSGi上工作，但由于类加载器的局限性，它可能需要复制/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory 文件的内容到OSGi包，包含用于解析参数的类（即事件处理程序）。</p></blockquote><h2 id="Meta-Annotations"><a href="#Meta-Annotations" class="headerlink" title="Meta Annotations"></a>Meta Annotations</h2><p>TODO</p><h2 id="Customizing-Message-Handler-behavior"><a href="#Customizing-Message-Handler-behavior" class="headerlink" title="Customizing Message Handler behavior"></a>Customizing Message Handler behavior</h2><p>TODO</p><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p>待办事项:更新Axon3<br>本章包含一个清单和在为生产级性能做准备时需要考虑的一些指导方针。现在，你可能已经使用了测试固件测试你的命令处理逻辑和sagas。然而，生产环境不像测试环境那么宽容。聚合往往存活得更久，更频繁地和并发的使用。对于额外的性能和稳定性，你最好调整配置满足你的具体需求。</p><h2 id="数据库索引和列类型"><a href="#数据库索引和列类型" class="headerlink" title="数据库索引和列类型"></a>数据库索引和列类型</h2><h2 id="SQL-DatabasesSQL数据库"><a href="#SQL-DatabasesSQL数据库" class="headerlink" title="SQL DatabasesSQL数据库"></a>SQL DatabasesSQL数据库</h2><p>如果你使用你的JPA实现自动生成表(例如Hibernate)，你可能没有把所有正确的索引设置在你的表上。为获得最佳性能，事件存储的不同用法需要不同的索引设置。该列表显示，为默认EventStorageEngine实现使用的不同类型的查询添加不同类型的索引：</p><ul><li><p>标准操作使用(存储和加载事件):<br>Table ‘DomainEventEntry’, columns aggregateIdentifier and sequenceNumber (unique index)<br>Table ‘DomainEventEntry’, eventIdentifier (unique index)</p></li><li><p>快照：<br>Table ‘SnapshotEventEntry’, aggregateIdentifier column.<br>Table ‘SnapshotEventEntry’, eventIdentifier (unique index)</p></li><li><p>Sagas<br>Table ‘AssociationValueEntry’, columns associationKey and sagaId,</p></li></ul><p>默认生成的列长度可以工作，例如Hibernate，但不会是最优的。例如，一个UUID总是有相同的长度。而不是可变长度列255个字符，你可以为聚合标识符使用一个固定长度36个字符的列。</p><p>“时间戳”列在DomainEventEntry表只储存ISO 8601时间戳。如果所有时间存储在UTC时区，他们需要一个长度为24个字符的列。如果你使用另一个时区，这可能高达28位。使用可变长度列通常是没有必要的，因为时间戳总是具有相同的长度。</p><blockquote><p><b>警告</b><br>强烈建议所有时间戳以UTC格式存储。在夏令时的国家，用当地时间存储时间戳，在时区转换时可能会导致事件生成的顺序错误。使用UTC时不会发生这种情况。有些服务器配置为始终使用UTC。另外你应该在存储它们之前配置事件存储将时间戳转换成UTC。</p></blockquote><p>在DomainEventEntry中的“type”列存储聚合的标识符类型。一般来说，这些都是聚合的简单的名称。在Spring中事件臭名昭著的“AbstractDependencyInjectionSpringContextTests”只算45个字符。在这里，再一次，一个长度较短(但可变)的字段应该足够了。</p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>默认情况下，MongoEventStore只会为正确的操作生成它需要的索引。这意味着当事件存储被创建时，所需的惟一索引在“聚合标识符”、“聚合类型”和“事件序列号”上也被创建。然而，当为某些操作使用MongoEventStore时，可能是值得添加一些额外索引的。</p><p>注意，在查询优化和更新速度之间的总有一个平衡点。负载测试最终是发现哪些索引提供最佳性能的最好方法。</p><ul><li><p>正常操作使用：<br>在“aggregateIdentifier”上自动创建一个索引，“type”和“sequenceNumber”在领域事件(缺省名称:“domainevents”)集合中。</p></li><li><p>Snapshotting：<br>在事件快照(缺省名称:“snapshotevents”)集合中把(unique)索引放“aggregateIdentifier”,“type”和“sequenceNumber“上。</p></li><li><p>Replaying events:<br>在领域事件(缺省名称:“domainevents”)集合中，把非唯一索引放在“timestamp”和“sequenceNumber”上。</p></li><li>Sagas：<br>在saga（默认名称：“sagas”）集合中把(唯一)索引放到“sagaIdentifier”上。<br>在saga（默认名称：“sagas”）集合中把索引放到”sagaType”、“associations.key”和“associations.value“属性上。</li></ul><h2 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h2><p>一个设计良好的命令处理模块当实现缓存时应该不会构成任何问题。尤其是当使用事件溯源时，从事件存储中加载一个聚合是一项昂贵的操作。用正确配置的缓存，加载一个聚合可以转化为一个纯粹的in-memory过程。</p><p>下面是一些帮助您最大限度地利用缓存解决方案的指导原则：</p><ul><li><p>确保工作单元永远不需要为功能原因执行回滚。<br>回滚意味着一个聚合已经达到了一个无效的状态。Axon会自动将相关的缓存项失效。下一个请求将迫使聚合从事件中重建。如果你使用异常作为一个潜在的(功能的)返回值，你可以在命令总线上配置一个RollbackConfiguration。默认情况下，当运行时异常时这个工作单元将回滚。</p></li><li><p>单个聚合的所有命令必须到达在缓存中具有该聚合的机器上。<br>这意味着命令应该始终被路由到同一台机器，只要这台机器是“健康”的。路由命令总是阻止缓存过期。命中一个过期缓存将导致一个命令被执行，并且事件存储在事件存储中会失败。</p></li><li><p>配置一个合理的生存时间/闲置时间<br>默认情况下，缓存倾向于有一个相对较短的生存时间，即几分钟。对于具有一致的路由的命令处理组件，一个较长的闲置时间和生存时间通常是更好的。这可以防止需要初始化一个基于它的事件的聚合，仅仅因为它的缓存条目过期了。缓存的生存时间应该与你的聚合的预期寿命相匹配。</p></li></ul><h2 id="Snapshotting"><a href="#Snapshotting" class="headerlink" title="Snapshotting"></a>Snapshotting</h2><p>快照删除需要重载和重放大量的事件。单个快照代表在在某一特定时刻整个聚合状态。然而，快照的处理本身也需要处理时间。因此，在构建快照时所花费的时间和阻止许多事件被读取节省的时间应该保持平衡。</p><p>对所有类型的应用程序都没有默认行为。一些将指定一些事件之后将创建一个快照，而其他应用程序需要一个基于时间的快照间隔。无论你选择何种方式为您的应用程序，如果你有long-living聚合，确保快照就位。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/1dc158d81511" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/1dc158d81511</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参数解析器&quot;&gt;&lt;a href=&quot;#参数解析器&quot; class=&quot;headerlink&quot; title=&quot;参数解析器&quot;&gt;&lt;/a&gt;参数解析器&lt;/h2&gt;&lt;p&gt;你可以配置额外的ParameterResolvers，通过扩展ParameterResolverFactory类和创建一个名为/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory的文件，包含实现类的完全限定名称。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-SpringBoot自动配置</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-SpringBoot自动配置/</id>
    <published>2018-08-31T03:10:15.000Z</published>
    <updated>2018-09-29T07:47:11.128Z</updated>
    
    <content type="html"><![CDATA[<p>Axon支持的SpringBoot自动配置是迄今为止开始配置Axon基础设施组件最简单的选择。只需添加axon-spring-boot-starter依赖性，Axon会自动配置基础设施组件(命令总线，事件总线)，以及运行和储存聚合和Saga所需的任何组件。</p><a id="more"></a><p>根据在应用程序上下文中的其他组件，如果他们在应用程序上下文中不是已经明确定义，Axon将定义某些组件。这意味着只需要配置不同于默认值的组件。</p><h2 id="事件总线和事件存储配置"><a href="#事件总线和事件存储配置" class="headerlink" title="事件总线和事件存储配置"></a>事件总线和事件存储配置</h2><p>如果JPA可用，事件存储默认使用JPA事件存储引擎。这允许聚合的存储使用事件溯源而无需任何明确的配置。<br>如果JPA不可用，Axon默认使用SimpleEventBus，这意味着你需要为每个聚合指定一个非事件溯源存储库，或者在你的Spring配置中配置一个EventStorageEngine 。</p><p>配置一个不同的事件存储引擎，即使JPA在class path上，只需定义一个EventStorageEngine类型的bean (使用事件溯源)或EventBus(如果不需要事件溯源)。</p><h2 id="命令总线配置"><a href="#命令总线配置" class="headerlink" title="命令总线配置"></a>命令总线配置</h2><p>如果在应用程序上下文中没有显式定义CommandBus实现，Axon会配置一个SimpleCommandBus。这个CommandBus将使用PlatformTransactionManager管理事务，如果它在上下文中可用。</p><p>如果只有CommandBus bean定义是一个DistributedCommandBus实现，Axon仍将配置一个CommandBus实现作为DistributedCommandBus本地segment。这个bean将获取一个“localSegment”限定符。建议定义DistributedCommandBus为@Primary，以便它优先考虑依赖注入。</p><h2 id="聚合配置"><a href="#聚合配置" class="headerlink" title="聚合配置"></a>聚合配置</h2><p>@Aggregate注解(在org.axonframework.spring.stereotype包中)触发自动配置，配置使用带注解的类型的必要组件作为聚合 。注意，只有聚合根需要注解。</p><p>Axon会用命令总线自动注册所有带@CommandHandler注解的方法，并且如果不存在则建立一个存储库。</p><p>建立一个与默认情况不同的存储库，在应用程序上下文中定义一个。可选地，你可以定义要使用的存储库的名称，在@Aggregate上使用存储库属性。如果没有定义存储库属性，Axon将尝试以聚合的名称使用存储库(第一个字符小写)，后缀为存储库。依此类推，一个MyAggregate类的类型，默认的存储库名字叫myAggregateRepository。如果没有找到那个名称的bean，Axon将定义一个EventSourcingRepository(如果没有EventStore可用其会失败)。</p><h2 id="Saga配置"><a href="#Saga配置" class="headerlink" title="Saga配置"></a>Saga配置</h2><p>基础设施组件的配置操作的Saga是@Saga注解触发的(在org.axonframework.spring.stereotype包中)。Axon会配置一个SagaManagert和SagaRepository。SagaRepository将在上下文中使用一个可用的SagaStore(如果找到JPA默认为JPASagaStore)为实际Saga存储。</p><p>为Saga使用不同的SagaStores，在每个@Saga注解的sagaStore属性中，提供要使用的SagaStore的bean名称。<br>Saga将从应用程序上下文中注入资源。注意，这并不意味着Spring-injecting用于注入这些资源。@Autowired和@javax.inject.Inject注解可用于标定依赖关系，但它们由Axon通过寻找这些被注解的字段和方法来注入。构造函数注入(还)不支持。</p><h2 id="事件处理（Event-Handling）配置"><a href="#事件处理（Event-Handling）配置" class="headerlink" title="事件处理（Event Handling）配置"></a>事件处理（Event Handling）配置</h2><p>默认情况下，所有单例Spring bean组件包含带@EventHandler注解的方法，将订阅一个事件处理器去接收事件消息发布到事件总线。</p><p>EventHandlingConfiguration bean，在应用程序上下文可用，有方法来调整事件处理程序的配置。有关详细信息,请参阅配置API配置事件处理程序和事件处理器。</p><p>更新事件处理（EventHandling）配置，创建一个autowired方法,设置你想要的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">public void configure(EventHandlingConfiguration config) &#123;</span><br><span class="line">    config.usingTrackingProcessors(); // default all processors to tracking mode.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件处理器(（Event Processors）的某些方面也可以在application.properties中配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axon.eventhandling.processors[&quot;name&quot;].mode=tracking</span><br><span class="line">axon.eventhandling.processors[&quot;name&quot;].source=eventBus</span><br></pre></td></tr></table></figure><p>使用application.yml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axon:</span><br><span class="line">    eventhandling:</span><br><span class="line">        processors:</span><br><span class="line">            name:</span><br><span class="line">                mode: tracking</span><br><span class="line">                source: eventBus</span><br></pre></td></tr></table></figure><p>源文件属性指的是bean的名称实现了SubscribableMessageSource或StreamableMessageSource，名称应该被用来做上述处理器的事件源。源文件默认事件总线或事件存储在应用程序上下文中定义。</p><h2 id="启用AMQP"><a href="#启用AMQP" class="headerlink" title="启用AMQP"></a>启用AMQP</h2><p>启用AMQP支持，确保axon-amqp模块在类路径上，并且在应用程序上下文中AMQP ConnectionFactory是可用的(例如通过引用spring-boot-starter-amqp)。<br>在应用程序中转发生成的事件到一个AMQP Channel，一行application.properties配置就够了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axon.amqp.exchange=ExchangeName</span><br></pre></td></tr></table></figure><p>这将以给定的名称自动发送所有已经发布的事件到AMQP Channel。</p><p>默认情况下，发送时没有使用AMQP事务。这可以使用axon.amqp.transaction-mode属性覆盖，并设置它为事务或publisher-ack。</p><p>从队列中接收事件，并在Axon应用程序内处理它们，你需要配置一个SpringAMQPMessageSource：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SpringAMQPMessageSource myQueueMessageSource(AMQPMessageConverter messageConverter) &#123;</span><br><span class="line">    return new SpringAMQPMessageSource(messageConverter) &#123;</span><br><span class="line"></span><br><span class="line">        @RabbitListener(queues = &quot;myQueue&quot;)</span><br><span class="line">        @Override</span><br><span class="line">        public void onMessage(Message message, Channel channel) throws Exception &#123;</span><br><span class="line">            super.onMessage(message, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后配置一个处理器，使用这个bean作为其消息来源:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axon.eventhandling.processors[&quot;name&quot;].source=myQueueMessageSource</span><br></pre></td></tr></table></figure><h2 id="使用JGroups分发命令"><a href="#使用JGroups分发命令" class="headerlink" title="使用JGroups分发命令"></a>使用JGroups分发命令</h2><p>进行中…如果你不能等，添加一个依赖项到axon-spring-boot-starter-jgroups模块。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/d843fe8bd7d1" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/d843fe8bd7d1</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Axon支持的SpringBoot自动配置是迄今为止开始配置Axon基础设施组件最简单的选择。只需添加axon-spring-boot-starter依赖性，Axon会自动配置基础设施组件(命令总线，事件总线)，以及运行和储存聚合和Saga所需的任何组件。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-Snapshotting</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-Snapshotting/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-Snapshotting/</id>
    <published>2018-08-31T03:07:08.000Z</published>
    <updated>2018-09-29T07:47:11.178Z</updated>
    
    <content type="html"><![CDATA[<p>当聚合存活很长一段时间，它们的状态不断变化，它们会生成大量的事件。不得不加载所有这些事件去复原一个聚合的状态，可能会有很大的性能影响。快照事件是一个有着特殊用途的领域事件：它将任意数量的事件归纳为单个事件。通过定期创建和存储快照事件，事件存储不必返回长的事件列表。只返回最后一个快照事件和在快照之后发生的所有事件</p><a id="more"></a><p>例如，库存物品往往会经常变化。每销售一件物品，事件就减少一件库存。每次一批新物品进来，库存就增加一些。如果你每天销售一百件，你每天会产生至少100个事件。几天之后，你的系统将会花太多的时间读取所有这些事件，只是为了弄清楚它是否应该raise一个“ItemOutOfStockEvent”。单个快照事件仅仅通过存储当前的库存数量就可以取代很多这些事件。</p><h2 id="Creating-a-snapshot创建一个快照"><a href="#Creating-a-snapshot创建一个快照" class="headerlink" title="Creating a snapshot创建一个快照"></a>Creating a snapshot创建一个快照</h2><p>快照的创建可由多种因素触发，例如，从上次快照创建以来的事件的数量，初始化一个聚合的时候超过了某个阈值，基于时间的，等等。目前，Axon提供了一种机制，允许你基于事件计数阈值触发快照。</p><p>当要创建快照时的定义，由SnapshotTriggerDefinition接口提供。</p><p>当加载聚合所需的事件数量超过一定的阈值时，EventCountSnapshotTriggerDefinition提供触发快照创建的机制。如果加载一个聚合需要的事件的数量超过某个可配置的阈值，触发器告诉Snapshotter为聚合创建一个快照。</p><p>快照触发器在一个事件溯源存储库上配置，并有很多属性允许你调整触发:</p><ul><li>快照设置实际的快照实例，负责创建和存储实际的快照事件;</li><li>触发器设置触发快照创建的阈值;</li></ul><p>Snapshotter负责快照的实际创建。通常，快照是一个应该尽可能少的扰乱操作进程的进程。因此,建议在不同的线程运行Snapshotter。Snapshotter接口声明了单独的方法：scheduleSnapshot()，以聚合的类型和标识符作为参数。</p><p>Axon提供了AggregateSnapshotter，它创建并存储AggregateSnapshot实例。这是一种特殊类型的快照，因为它包含了在它内部的实际的聚合实例。Axon提供的存储库知道这种类型的快照，并从它提取聚合，而不是实例化一个新的。快照事件之后加载的所有事件传输到取出的聚合实例。</p><blockquote><p><b>注意</b><br>确保你使用的序列化器实例(默认为XStreamSerializer)是能够序列化你的聚合的。XStreamSerializer要求使用Hotspot JVM，或者你的聚合要有一个可访问的默认的构造函数或实现Serializable接口。</p></blockquote><p>AbstractSnapshotter提供了一组基本的属性，允许你调整创建快照的方式：</p><ul><li>EventStore设置事件存储，用于加载过去的事件和存储快照。这个事件存储必须实现SnapshotEventStore接口。</li><li>Executor设计executor，比如ThreadPoolExecutor提供了线程来处理实际快照的创建。默认情况下，快照的创建是在线程中调用scheduleSnapshot()方法，一般不建议用于生产。</li></ul><p>AggregateSnapshotter提供另一个属性:</p><ul><li>AggregateFactories是允许你设置创建聚合实例工厂的属性。配置多个聚合工厂允许你使用一个单独的Snapshotter为各种聚合类型创建快照。EventSourcingRepository实现提供了访问他们使用的AggregateFactory。这可以用于配置相同的聚合工厂像在存储库中使用的Snapshotter一样。</li></ul><blockquote><p><b>注意</b><br>如果你使用一个executor在另一个线程中执行快照创建，如果必要的话，确保你为潜在的事件存储配置正确的事务管理。<br>Spring用户可以使用SpringAggregateSnapshotter，当需要创建一个快照时，它将从应用程序上下文自动查找合适的AggregateFactory。</p></blockquote><h2 id="存储快照事件"><a href="#存储快照事件" class="headerlink" title="存储快照事件"></a>存储快照事件</h2><p>当快照存储在事件存储中时，它会自动使用快照归纳所有之前的事件并将其返回到它们的位置。所有事件存储实现允许并发创建快照。这意味着它们允许快照被存储的同时，另一个进程为同一个聚合添加事件。这允许快照进程作为一个完全独立进程。</p><blockquote><p><b>注意</b><br>通常情况下，一旦它们是快照事件的一部分，你就可以归档所有的事件。快照事件将永远不会在常规操作场景中再次读取事件存储。然而,如果你希望能够重建快照创建前一刻的聚合状态，你必须保持事件为最新。</p></blockquote><p>Axon提供了一种特殊类型的快照事件：AggregateSnapshot,它将整个聚合存储为一个快照。动机很简单:你的聚合应该只包含与业务决策相关的的状态。这正是你想要在一个快照中捕获的信息。所有事件溯源存储库由Axon承认的AggregateSnapshot提供，并将从它提取的聚合。注意，使用这个快照事件要求事件序列化机制需要能够对聚合进行序列化。</p><h2 id="根据快照事件初始化聚合"><a href="#根据快照事件初始化聚合" class="headerlink" title="根据快照事件初始化聚合"></a>根据快照事件初始化聚合</h2><p>快照事件是一个和其他事件一样的事件。这意味着一个快照事件就像任何其他领域事件一样被处理。当使用注解来划分事件处理程序(@EventHandler)时，你可以注解一个方法，基于快照事件初始化全部的聚合状态。下面的代码示例演示了，如何像对待任何其他聚合中的领域事件一样对待快照事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyAggregate extends AbstractAnnotatedAggregateRoot &#123;</span><br><span class="line"></span><br><span class="line">    // ... code omitted for brevity</span><br><span class="line"></span><br><span class="line">    @EventHandler</span><br><span class="line">    protected void handleSomeStateChangeEvent(MyDomainEvent event) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @EventHandler</span><br><span class="line">    protected void applySnapshot(MySnapshotEvent event) &#123;</span><br><span class="line">        // the snapshot event should contain all relevant state</span><br><span class="line">        this.someState = event.someState;</span><br><span class="line">        this.otherState = event.otherState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种类型的快照事件处理方式不同:AggregateSnapshot。这种类型的快照事件包含实际的聚合。聚合工厂识别这种类型的事件并从快照中提取聚合。然后，将所有其他事件重新应用到提取的快照。这意味着聚合从不需要能够处理AggregateSnapshot实例自身。</p><h2 id="先进的冲突检测和解决方案"><a href="#先进的冲突检测和解决方案" class="headerlink" title="先进的冲突检测和解决方案"></a>先进的冲突检测和解决方案</h2><p>明确改变的含义作为一个主要的优势，就是你可以更精确地检测冲突的变化。通常,这些冲突的变化，发生在两个用户同时处理相同的数据(几乎)时。想象一下两个用户都查看一个特定版本的数据。他们都决定对这些数据进行修改。他们都将发送一个命令就像“在这个聚合的X版本上，那样做”，其中X是聚合的预期版本。其中一个会将修改实际应用于预期的版本。另一个用户不会。</p><p>当聚合已经被另一个进程修改时，你可以检查用户的意图与任何看不见的修改是否冲突，而不是简单地拒绝所有传入命令。<br>检测冲突，传递一个ConflictResolver类型的参数到你的聚合的 @CommandHandler方法。这个接口提供了detectConflicts方法，允许你在执行特定类型的命令时，定义被认为是冲突的事件类型。</p><blockquote><p><b>注意</b><br>注意ConflictResolver只会包含任何潜在的冲突事件，如果聚合用一个预期的版本加载。使用@TargetAggregateVersion在一个命令的字段上标示聚合的预期的版本。</p></blockquote><p>如果找到事件匹配的断言（predicate），抛出异常(detectConflicts可选的第二个参数允许你定义抛出的异常)。如果没有找到，处理将继续正常进行。</p><p>如果没有调用detectConflicts，并有潜在冲突的事件,@CommandHandler将失败。这可能是提供一个预期的版本的情况下，在@CommandHandler方法的参数中没有可用的ConflictResolver 。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/0cf9c4c0e037" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0cf9c4c0e037</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当聚合存活很长一段时间，它们的状态不断变化，它们会生成大量的事件。不得不加载所有这些事件去复原一个聚合的状态，可能会有很大的性能影响。快照事件是一个有着特殊用途的领域事件：它将任意数量的事件归纳为单个事件。通过定期创建和存储快照事件，事件存储不必返回长的事件列表。只返回最后一个快照事件和在快照之后发生的所有事件&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-事件向上转换</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E4%BA%8B%E4%BB%B6%E5%90%91%E4%B8%8A%E8%BD%AC%E6%8D%A2/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-事件向上转换/</id>
    <published>2018-08-31T03:03:17.000Z</published>
    <updated>2018-09-29T07:47:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于软件应用程序的不断变化的性质，很可能事件定义也随着时间而变化。由于事件存储被认为是只读和只追加（没有修改和删除）的数据源，所以应用程序必须能够读取所有事件，而不管它们何时添加。这时upcasting 出现了。</p><a id="more"></a><p>最初是面向对象编程的一个概念，“一个子类在需要的时候自动转换成超类”，upcasting 概念也可以应用于事件溯源。upcast一个事件意味着将它从原来的结构转换成新的结构。不像OOP的upcasting，事件的upcasting无法全部自动化完成，因为旧的事件对新事件的结构是不了解的。手工编写的Upcasters，必须提供指定如何将旧的结构upcast成新结构。</p><p>Upcasters类，获取一个x版本的输入事件，并且输出为零或更多版本x+1的新事件。此外，upcasters在一个链中被处理，这意味着一个upcaster的输出发送到下一个upcaster的输入。这允许你以增量的方式更新事件，为每一个新事件版次编写一个Upcaster ，使其小、隔离、并且容易理解。</p><blockquote><p><b>注意</b><br>也许upcasting最大的好处是，它允许你做非破坏性重构，即完整的事件历史仍然保持不变。</p></blockquote><p>在本节中，我们将解释如何编写upcaster，描述随着Axon不同的的Upcaster实现，并解释事件的序列化形式如何影响写upcasters。</p><p>允许upcaster看到什么版本的序列化对象被接收，Event Store存储版本号以及事件的完全限定名称。这个版本号是由RevisionResolver生成,在序列化器中配置。Axon提供了几个RevisionResolver的实现，比如AnnotationRevisionResolver，它检查在事件有效负载上的@Revision注解，SerialVersionUIDRevisionResolver 使用Java Serialization API和FixedValueRevisionResolver所定义的serialVersionUID，它总是返回一个预定义的值。后者在注入当前应用程序版本时是有用的。这将允许你看哪个版本的应用程序生成一个特定的事件。</p><p>Maven用户可以使用MavenArtifactRevisionResolver自动使用项目的版本。它使用项目获取的groupId，artifactId版本初始化。因为这只适用由Maven创建的JAR文件,版本不总能通过IDE来解析。如果无法解析版本，则返回null。</p><h2 id="编写一个upcaster"><a href="#编写一个upcaster" class="headerlink" title="编写一个upcaster"></a>编写一个upcaster</h2><p>事件的老版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Revision(&quot;1.0&quot;)</span><br><span class="line">public class ComplaintEvent &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String companyName;</span><br><span class="line"></span><br><span class="line">    // Constructor, getter, setter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新版本的事件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Revision(&quot;2.0&quot;)</span><br><span class="line">public class ComplaintEvent &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String companyName;</span><br><span class="line">    private String complain; // New field</span><br><span class="line"></span><br><span class="line">    // Constructor, getter, setter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Upcaster:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Upcaster from 1.0 revision to 2.0 revision</span><br><span class="line">public class ComplaintEventUpcaster extends SingleEventUpcaster &#123;</span><br><span class="line">    private static SimpleSerializedType targetType = new SimpleSerializedType(ComplainEvent.class.getTypeName(), &quot;1.0&quot;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean canUpcast(IntermediateEventRepresentation intermediateRepresentation) &#123;</span><br><span class="line">        return intermediateRepresentation.getType().equals(targetType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected IntermediateEventRepresentation doUpcast(IntermediateEventRepresentation intermediateRepresentation) &#123;</span><br><span class="line">        return intermediateRepresentation.upcastPayload(</span><br><span class="line">                new SimpleSerializedType(targetType.getName(), &quot;2.0&quot;),</span><br><span class="line">                org.dom4j.Document.class,</span><br><span class="line">                document -&gt; &#123;</span><br><span class="line">                    document.getRootElement().addElement(&quot;complaint&quot;);</span><br><span class="line">                    document.getRootElement().element(&quot;complaint&quot;).setText(&quot;no complaint description&quot;); // Default value</span><br><span class="line">                    return document;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring boot configuration:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AxonConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SingleEventUpcaster myUpcaster() &#123;</span><br><span class="line">        return new ComplaintEventUpcaster();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public JpaEventStorageEngine eventStorageEngine(Serializer serializer,</span><br><span class="line">                                                    DataSource dataSource,</span><br><span class="line">                                                    SingleEventUpcaster myUpcaster,</span><br><span class="line">                                                    EntityManagerProvider entityManagerProvider,</span><br><span class="line">                                                    TransactionManager transactionManager) throws SQLException &#123;</span><br><span class="line">        return new JpaEventStorageEngine(serializer,</span><br><span class="line">                myUpcaster::upcast,</span><br><span class="line">                dataSource,</span><br><span class="line">                entityManagerProvider,</span><br><span class="line">                transactionManager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO - Describe</p><ul><li>Upcasters工作在中间的表现层</li><li>它们更新流到流</li><li>抽象一对一的upcasting实现</li><li>代码示例</li></ul><h2 id="Content-type-conversion（内容类型转换）"><a href="#Content-type-conversion（内容类型转换）" class="headerlink" title="Content type conversion（内容类型转换）"></a>Content type conversion（内容类型转换）</h2><p>一个upcaster工作在给定内容类型上(如dom4j文档)。upcasters之间提供额外的灵活性，内容类型在链接的upcasters之间可能会有所不同。Axon将尝试使用ContentTypeConverters在内容类型之间自动地转换。它将寻找从类型x到类型y最短的路径，执行转换并交值转换成请求的upcaster。考虑到性能因素 ，如果receiving upcaster上的canUpcast方法产生true，转换才会被执行</p><p>ContentTypeConverters可能依赖于使用的序列化器类型。试图把一个byte[]转换成dom4j文档，这没有任何意义，除非使用序列化器把事件作为XML来写。确保UpcasterChain有权访问serializer-specific ContentTypeConverters,你可以通过UpcasterChain的构造函数引用序列化器。</p><blockquote><p><b>提示</b><br>为了达到最佳性能,确保所有upcasters在同一链上(其中一个的输出是另一个的输入)处理相同的内容类型。</p></blockquote><p>如果你需要不是由Axon提供的内容类型转换，你可以使用ContentTypeConverter接口编写一个自己的。<br>XStreamSerializer支持Dom4J像支持 XOM一样作为XML文档表示。JacksonSerializer 支持Jackson的JsonNode。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/e4e943937993" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/e4e943937993</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于软件应用程序的不断变化的性质，很可能事件定义也随着时间而变化。由于事件存储被认为是只读和只追加（没有修改和删除）的数据源，所以应用程序必须能够读取所有事件，而不管它们何时添加。这时upcasting 出现了。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-EventStore实现</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-EventStore%E5%AE%9E%E7%8E%B0/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-EventStore实现/</id>
    <published>2018-08-31T02:52:45.000Z</published>
    <updated>2018-09-29T07:47:10.937Z</updated>
    
    <content type="html"><![CDATA[<p>事件溯源存储库需要一个事件存储（event store）从聚合中存储和加载事件。事件存储提供了一个事件总线的功能，增加了持久化已发布的事件，并能够基于聚合标识符检索事件。</p><a id="more"></a><p>Axon提供了一个开箱即用的事件存储，EmbeddedEventStore。它委托事件实际的存储和检索到EventStorageEngine。<br>有多个EventStorageEngine的实现：</p><h2 id="JpaEventStorageEngine"><a href="#JpaEventStorageEngine" class="headerlink" title="JpaEventStorageEngine"></a>JpaEventStorageEngine</h2><p>JpaEventStorageEngine存储事件在JPA-compatible数据源中。JPA事件存储存储事件在所谓的条目中。这些条目包含事件的序列化形式，以及存储一些领域元数据以快速查找这些条目。使用JpaEventStorageEngine，你必须在你的类路径中有JPA注解(javax.persistence)。</p><p>默认情况下，事件存储需要你配置你的持久化上下文(如在META-INF/persistence.xml中定义)包含DomainEventEntry和SnapshotEventEntry（两者都在org.axonframework.eventsourcing.eventstore.jpa包中)。<br>下面是一个持久化上下文配置的示例配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot; version=&quot;1.0&quot;&gt;</span><br><span class="line">    &lt;persistence-unit name=&quot;eventStore&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt; (1)</span><br><span class="line">        &lt;class&gt;org...eventstore.jpa.DomainEventEntry&lt;/class&gt; (2)</span><br><span class="line">        &lt;class&gt;org...eventstore.jpa.SnapshotEventEntry&lt;/class&gt;</span><br><span class="line">    &lt;/persistence-unit&gt;</span><br><span class="line">&lt;/persistence&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，事件存储有一个特定的持久化单元。然而，你可能会选择将第三行添加到任何其他持久化单元的配置中。<br>本行注册DomainEventEntry(由JpaEventStore使用的类)到持久化上下文。</p><blockquote><p><b>注意</b><br>Axon使用锁来防止两个线程访问相同的聚合。然而，如果在同一数据库上你有多个jvm，这不会帮助你。在这种情况下，你不得不依靠数据库来检测冲突。并发访问事件存储将导致违反主键约束（Key Constraint Violation），因为表允许聚合只能有一个任何序列号的事件，所以，用已有的序列号为现有聚合插入第二个事件将导致错误。<br>JpaEventStorageEngine可以检测这个错误并把它转换成ConcurrencyException。然而，每个数据库系统以不同的方式报告此违规行为。如果你用JpaEventStore注册你的数据源，它将尝试检测数据库的类型，并找出错误代码是一个违反主键约束（Key Constraint Violation）。或者，你可能会提供一个PersistenceExceptionTranslator实例，如果一个给定的异常代表一个违反主键约束（Key Constraint Violation）它能分辨。<br>如果没有提供数据源或PersistenceExceptionTranslator，从数据库驱动程序按原样抛出异常。</p></blockquote><p>默认情况下，JPA事件存储引擎需要一个EntityManagerProvider实现，返回EventStorageEngine使用的EntityManager实例。这还允许应用程序管理所用的持久化上下文。EntityManagerProvider的责任是提供一个正确的EntityManager实例。</p><p>有几个EntityManagerProvider的实现可用，各有不同的需求。SimpleEntityManagerProvider仅在构建时返回EntityManager实例给它。这使得实现成为容器管理上下文一个简单的选择。ContainerManagedEntityManagerProvider作为一种选择，返回默认的持久化上下文，并且它的使用默认通过JPA事件存储。<br>如果你有一个持久化单元称为“myPersistenceUnit”，你希望在JpaEventStore中使用，这就是EntityManagerProvider实现，可能看起来像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyEntityManagerProvider implements EntityManagerProvider &#123;</span><br><span class="line"></span><br><span class="line">    private EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public EntityManager getEntityManager() &#123;</span><br><span class="line">        return entityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PersistenceContext(unitName = &quot;myPersistenceUnit&quot;)</span><br><span class="line">    public void setEntityManager(EntityManager entityManager) &#123;</span><br><span class="line">        this.entityManager = entityManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，JPA事件存储把条目存储在DomainEventEntry和SnapshotEventEntry实体中。虽然在许多情况下这就足够了，你可能会遇到这些实体提供的元数据不够的情况。或者你可能想将不同的聚合类型的事件存储在不同的表。<br>如果是这样,你可以扩展JpaEventStorageEngine。它包含了一些protected方法，你可以重写来调整其行为。</p><blockquote><p><b>警告</b><br>注意持久化提供者，如Hibernate，在它们的EntityManager实现上使用一级缓存。通常，这意味着在查询中使用或返回的所有隶属于EntityManager的实体。它们只有在周围事务被提交或在事务中执行显式“清除”时才被清除。当查询在事务上下文中执行时尤其如此。<br>要解决这个问题，请确保仅仅查询非实体对象。你可以使用JPA的“SELECT new SomeClass(parameters) FROM …”风格的查询来解决这个问题。或者，获取一批事件后调用EntityManager.flush()和EntityManager.clear()。未能这样做当加截大事件流时可能导致OutOfMemoryExceptions。</p></blockquote><h2 id="JDBC-Event-Storage-Engine"><a href="#JDBC-Event-Storage-Engine" class="headerlink" title="JDBC Event Storage Engine"></a>JDBC Event Storage Engine</h2><p>JDBC事件存储引擎使用JDBC连接将事件存储在JDBC兼容的数据存储。通常，这些都是关系数据库。从理论上讲，任何一个JDBC驱动程序都可以用来支持JDBC事件存储引擎。</p><p>类似于JPA，JDBC事件存储引擎将事件存储在条目中。默认情况下，每个事件存储在一个单独的条目中，对应表中的一行。一个表用于事件，另一个用于快照。</p><p>JdbcEventStorageEngine使用ConnectionProvider来获取连接。通常，这些连接可以直接从数据源中获得。然而，Axon会将这些连接绑定到一个工作单元，以便在一个工作单元使用一个连接。这将确保一个单独的事务用于存储所有事件，即使在同一线程中嵌套多个工作单元。</p><blockquote><p><b>注意</b><br>Spring用户建议使用SpringDataSourceConnectionProvider从数据源附加连接到现有的事务。</p></blockquote><h2 id="MongoDB-Event-Storage-Engine"><a href="#MongoDB-Event-Storage-Engine" class="headerlink" title="MongoDB Event Storage Engine"></a>MongoDB Event Storage Engine</h2><p>MongoDB是一个基于文档的NoSQL存储。其可伸缩特性使它适合用于事件存储。Axon提供了MongoEventStorageEngine,使用MongoDB作为数据库支持。它包含在Axon Mongo模块(Maven artifactId axon-mongo)。</p><p>事件存储在两个独立的集合中：一个用于实际的事件流，一个用于快照。</p><p>默认情况下，MongoEventStorageEngine将存储各自的事件在各自的文档。然而，它是可能改变StorageStrategy使用。</p><p>Axon提供的选择是DocumentPerCommitStorageStrategy，为在一个单独的提交中存储所有事件，创建一个单独的文档(即在同一DomainEventStream)。</p><p>在一个单独的文档中存储整个提交的好处在于提交是原子存储的。此外，它只需要对任意数量的事件进行一次往返。缺点是,它变得更加难以直接在数据库中查询事件。例如，当重构领域模型时，如果他们被包含在“commit document”中，很难从一个聚合“transfer”事件到另一个聚合。</p><p>MongoDB不需要很多配置。它所需要的只是对一个存储事件集合的引用，然后你就可以开始了。在生产环境中，你可能想要对集合中的索引进行双重检查。</p><h2 id="Event-Store-Utilities"><a href="#Event-Store-Utilities" class="headerlink" title="Event Store Utilities"></a>Event Store Utilities</h2><p>Axon提供了一些事件存储引擎，可能在某些情况下是有用的。</p><p>SequenceEventStorageEngine是围绕其它两个事件存储引擎的包装器。当读取时,它从这两个事件存储引擎中返回事件。附加事件只是附加到第二个事件存储引擎。出于性能原因使用事件存储两种不同的实现的情况下，这是有用的，例如。第一个是一个更大的，但较慢事件存储，而第二个是优化的快速读取和写入。</p><p>还有一个常驻内存的存储事件EventStorageEngine实现：InMemoryEventStorageEngine。虽然它可能优于任何其他的事件存储，这并不意味着长期生产使用。然而，它在需要事件存储的short-lived工具或测试中非常有用,。</p><h2 id="Influencing-the-serialization-process（影响序列化过程）"><a href="#Influencing-the-serialization-process（影响序列化过程）" class="headerlink" title="Influencing the serialization process（影响序列化过程）"></a>Influencing the serialization process（影响序列化过程）</h2><p>事件存储需要为存储准备一种序列化事件的方法。默认情况下，Axon使用XStreamSerializer，其使用XStream序列化成XML事件。XStream是相当快的，比Java序列化更灵活。此外，XStream序列化的结果是人类可读的。对日志和调试而言非常有用。</p><p>XStreamSerializer可以配置。你可以定义它应该用于某些包、类甚至字段的别名。除了可以缩短潜在的长名称之外，还可以在事件的类定义更改时使用别名。有关别名的更多信息，访问XStream网站。</p><p>另外，Axon还提供了JacksonSerializer，使用Jackson将事件序列化为JSON。当它生成一个更紧凑的序列化形式，它要求类遵守Jackson所要求的约定(或配置)。</p><blockquote><p><b>注意</b><br>使用Java代码(或其他JVM语言)配置序列化器是很容易的。然而，由于它调用方法的局限性，在Spring XML程序上下文看配置它并不那么简单。其中一个选项是创建一个FactoryBean，创建一个XStreamSerializer实例，并配置它的代码。检查 Spring 参考更多的信息。</p></blockquote><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/7ffff660d9a1" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/7ffff660d9a1</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件溯源存储库需要一个事件存储（event store）从聚合中存储和加载事件。事件存储提供了一个事件总线的功能，增加了持久化已发布的事件，并能够基于聚合标识符检索事件。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-存储库</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%AD%98%E5%82%A8%E5%BA%93/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-存储库/</id>
    <published>2018-08-31T02:50:48.000Z</published>
    <updated>2018-09-27T06:22:48.071Z</updated>
    
    <content type="html"><![CDATA[<p>存储库是提供对聚合访问的机制。存储库充当了用于保存数据的实际存储机制的网关。在CQRS中，存储库只需要能够根据他们的惟一标识符找到聚合。任何其他类型的查询，应该在查询数据库中执行。</p><a id="more"></a><p>在Axon Framework中,所有存储库必须实现Repository接口。这个接口规定了三种方法:load(identifier, version)， load(identifier)和newInstance(factoryMethod)。load方法允许你从存储库加载聚合。version可选参数是用来检测并发修改(见Advanced conflict detection and resolution)。newInstance用于注册新创建的聚合到存储库中。</p><p>基于你潜在的持久性存储和审计需求，有一些基础实现提供大了部分存储库所需的基本功能。Axon Framework对保存聚合当前状态的存储库(见Standard Repositories)和那些存储聚合事件的存储库(见 Event Sourcing Repositories)进行了区分。</p><p>注意，存储库接口没有声明delete(identifier)方法。删除聚合是通过在一个聚合内部调用AggregateLifecycle.markDeleted()方法完成的。删除聚合是一个与其他迁移一样的状态迁移，唯一的区别是它在许多情况下是不可逆的。你应该在聚合上创建自己的有意义的方法，来将聚合的状态设置为“已删除”。这也允许你注册你想要发布的任何事件。</p><h2 id="Standard-repositories（标准存储库）"><a href="#Standard-repositories（标准存储库）" class="headerlink" title="Standard repositories（标准存储库）"></a>Standard repositories（标准存储库）</h2><p>标准存储库存储聚合的实际状态。在每次修改后，新的状态将覆盖旧的。这使得命令组件也可以使用应用程序的查询组件使用的相同信息。标准存储库存储聚合的实际状态。这可能取决于你正在创建的应用程序的类型，这是最简单的解决方案。如果是这样的话，Axon提供了一些帮助你实现这样一个存储库的构件。</p><p>Axon为标准存储库提供了一个开箱即用的实现：GenericJpaRepository。它认为聚合是一个有效的JPA实体。它使用EntityManagerProvider配置，EntityManagerProvider提供EntityManager来管理实际的持久化，并且一个类指定聚合的实际类型存储在存储库中。当聚合调用静态AggregateLifecycle.apply()方法时，你也可以通过EventBus去发布事件。</p><p>你也可以轻松实现自己的存储库。在这种情况下，最好从抽象类LockingRepository扩展。作为聚合的包装器类型，建议使用AnnotatedAggregate。看GenericJpaRepository的源码示例。</p><h2 id="Event-Sourcing-repositories（事件溯源存储库）"><a href="#Event-Sourcing-repositories（事件溯源存储库）" class="headerlink" title="Event Sourcing repositories（事件溯源存储库）"></a>Event Sourcing repositories（事件溯源存储库）</h2><p>聚合根能够根据事件重建它们的状态，也可以配置为通过事件溯源存储库加载。这些存储库不存储聚合本身，但存储聚合生成的一系列事件。基于这些事件，可以随时恢复聚合的状态。</p><p>在AxonFramework中，EventSourcingRepository实现提供了任何事件溯源存储库所需的基本功能。这依赖于EventStore(见Implementing your own Event Store)，它抽象了实际的存储机制。</p><p>根据情况，你可以提供一个聚合工厂。AggregateFactory指定了如何创建一个聚合实例。一旦创建了一个聚合，EventSourcingRepository可以使用从事件存储中加载的事件来初始化。Axon Framework自带了一些你可以使用的AggregateFactory实现。如果他们还不够，可以很容易创建你自己的实现。</p><h2 id="GenericAggregateFactory"><a href="#GenericAggregateFactory" class="headerlink" title="GenericAggregateFactory"></a>GenericAggregateFactory</h2><p>GenericAggregateFactory是一种特别的AggregateFactory实现，可用于任何类型的事件溯源聚合根。GenericAggregateFactory创建存储库管理的聚合类型的一个实例。聚合类必须是非抽象的，声明一个默认的不进行初始化的无参构造函数化。<br>GenericAggregateFactory适用于大多数场景，聚合不需要专门注入non-serializable资源。</p><h2 id="SpringPrototypeAggregateFactory"><a href="#SpringPrototypeAggregateFactory" class="headerlink" title="SpringPrototypeAggregateFactory"></a>SpringPrototypeAggregateFactory</h2><p>根据你的架构选择，使用Spring将依赖项注入到聚合中可能是有用的。例如，你可以将查询库注入到你的聚合，以确保某些值的存在(或不存在)。</p><p>注入依赖项到你的聚合，在定义了SpringPrototypeAggregateFactory的Spring上下文中，你需要配置一个聚合根的属性bean。不是使用构造函数创建的常规的实例，而是使用Spring应用程序上下文实例化你聚合。这也将在你的聚合中注入的任何依赖项。</p><h2 id="实现自己的AggregateFactory"><a href="#实现自己的AggregateFactory" class="headerlink" title="实现自己的AggregateFactory"></a>实现自己的AggregateFactory</h2><p>在某些情况下，GenericAggregateFactory不能提供你所需要的东西。例如，你可以有一个抽象的聚合类型与不同的场景的多个实现(例如，PublicUserAccount和BackOfficeAccount都扩展一个帐户)。而不是为每个聚合创建不同的存储库，你可以使用一个单独的存储库，并配置一个AggregateFactory意识到不同的实现。</p><p>聚合工厂大部分的工作是创建未初始化的聚合实例。它必须使用一个给定的聚合标识符和流中的第一个事件。通常，这个事件是一个创建事件，其中包含关于预期聚合类型的提示。你可以使用这些信息来选择一个实现并调用其构造函数。确保没有事件被应用于构造函数；聚合必须未初始化。</p><p>相对于简单的存储库直接加载聚合的实现，基于事件初始化聚合可能是一项耗时的工作,。CachingEventSourcingRepository提供一个可以从中加载聚合的缓存</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/585e95e31704" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/585e95e31704</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存储库是提供对聚合访问的机制。存储库充当了用于保存数据的实际存储机制的网关。在CQRS中，存储库只需要能够根据他们的惟一标识符找到聚合。任何其他类型的查询，应该在查询数据库中执行。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-分发事件</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%88%86%E5%8F%91%E4%BA%8B%E4%BB%B6/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-分发事件/</id>
    <published>2018-08-31T02:47:38.000Z</published>
    <updated>2018-09-29T07:47:11.333Z</updated>
    
    <content type="html"><![CDATA[<p>在某些情况下，有必要发布事件到外部系统,比如消息broker。</p><a id="more"></a><h2 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h2><p>Axon提供了开箱即用的支持从一个AMQP message broker中转递事件和传递事件到broker中，比如Rabbit MQ。</p><h2 id="将事件转发到AMQP-Echange"><a href="#将事件转发到AMQP-Echange" class="headerlink" title="将事件转发到AMQP Echange"></a>将事件转发到AMQP Echange</h2><p>SpringAMQPPublisher将事件转发给一个AMQP Exchange。它使用SubscribableMessageSource初始化，一般是EventBus或EventStore。从理论上讲，这可能是发布者可以订阅的任何事件源。</p><p>要配置SpringAMQPPublisher，只需一个实例定义为Spring Bean。有一些setter方法允许你指定你预期的行为，如事务支持，publisher 确认(如果由broker支持)，和交换名称。</p><p>默认的exchange名称为’Axon.EventBus’</p><blockquote><p><b>注意</b><br>注意，exchanges不会被自动创建。你还必须声明队列、Exchanges 和你希望使用的Bindings 。检查Spring文档了解更多信息。</p></blockquote><h2 id="从AMQP-队列中读取事件"><a href="#从AMQP-队列中读取事件" class="headerlink" title="从AMQP 队列中读取事件"></a>从AMQP 队列中读取事件</h2><p>Spring已经广泛的支持从一个AMQP队列读取消息。然而,这需要与Axon“架桥”，以便这些消息可以从Axon处理，就像它们是常规事件消息一样。</p><p>SpringAMQPMessageSource允许事件处理器从队列中读取消息，而不是事件存储或事件总线。它作为一个Spring AMQP和SubscribableMessageSource之间的适配器需要这些处理器。</p><p>配置SpringAMQPMessageSource最简单的方法，是通过定义一个bean，重写默认的onMessage方法并使用@RabbitListener注解，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SpringAMQPMessageSource myMessageSource(Serializer serializer) &#123;</span><br><span class="line">    return new SpringAMQPMessageSource(serializer) &#123;</span><br><span class="line">        @RabbitListener(queues = &quot;myQueue&quot;)</span><br><span class="line">        @Override</span><br><span class="line">        public void onMessage(Message message, Channel channel) throws Exception &#123;</span><br><span class="line">            super.onMessage(message, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的@RabbitListener注解告诉Spring，这个方法需要被给定队列上的每个消息调用(myQueue的例子)。此方法简单地调用super.onMessage()方法，执行实际事件的发布到已经订阅它的所有处理器。</p><p>订阅这个MessageSource的处理器，将正确的SpringAMQPMessageSource实例传递给订阅处理器的构造函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// in an @Configuration file:</span><br><span class="line">@Autowired</span><br><span class="line">public void configure(EventHandlingConfiguration ehConfig, SpringAmqpMessageSource myMessageSource) &#123;</span><br><span class="line">    ehConfig.registerSubscribingEventProcessor(&quot;myProcessor&quot;, c -&gt; myMessageSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意跟踪处理器与SpringAMQPMessageSource不兼容。</p><h2 id="异步事件处理"><a href="#异步事件处理" class="headerlink" title="异步事件处理"></a>异步事件处理</h2><p>异步处理事件推荐的方法是使用跟踪事件处理器。这个实现可以保证所有事件的处理，甚至在发生系统故障的情况下(假定事件已经被持久化)。</p><p>然而,也有可能在SubscribingProcessor中异步处理事件。要做到这一点，SubscribingProcessor必须用EventProcessingStrategy配置。这种策略可以用来改变事件监听器的调用应如何管理。</p><p>默认策略(DirectEventProcessingStrategy)在传递事件的线程中调用这些事件处理程序。这允许处理器使用现有的事务。</p><p>其他Axon-provided strategy是AsynchronousEventProcessingStrategy。它使用一个Executor异步调用事件侦听器。</p><p>尽管AsynchronousEventProcessingStrategy异步执行，某些事件按顺序处理仍然是可取的。SequencingPolicy定义事件是否必须按顺序处理，并行或两者的结合。策略返回给定事件的序列标识符。如果两个事件的策略返回一个相等的标识符,这意味着他们必须由事件处理程序按顺序处理。一个空序列标识符意味着事件可能与任何其他事件并行处理。</p><p>Axon提供了一些可以使用的通用策略：</p><ul><li>FullConcurrencyPolicy会告诉Axon，事件处理程序可以处理所有并发事件。这意味着需要按特定顺序处理的事件之间没有关系。</li><li>SequentialPolicy告诉Axon，所有活动必须按照顺序进行处理。处理事件的操作将在处理前一个事件完成时开始。</li><li>SequentialPerAggregatePolicy将迫使领域事件从同一聚合顺序处理。然而，事件来自不同聚合可能并发处理。这通常是一个合适的政策，用于事件侦听器更新数据库中聚合的细节。</li></ul><p>除了这些提供的策略之外，你可以定义自己的策略。所有策略都必须实现SequencingPolicy接口。这个接口定义了一个方法getSequenceIdentifierFor，返回值为一个给定的事件序列标识符。返回相等序列标识符的事件必须按顺序处理。产生不同序列标识符的事件可以同时处理。出于性能原因，如果事件可以并行处理任何其他事件，则策略实现应该返回null。这样更快，因为Axon不必检查对事件处理的任何限制条件。</p><p>当使用AsynchronousEventProcessingStrategy时建议明确定义一个ErrorHandler。默认的ErrorHandler传播异常，但在异步执行中没有什么可以传播的，除了Executor。这可能导致事件没有被处理。相反，建议使用一个ErrorHandler报告错误，并允许继续处理。ErrorHandler被配置在SubscribingEventProcessor的构造函数上，还提供了EventProcessingStrategy。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/c333f2c05239" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c333f2c05239</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在某些情况下，有必要发布事件到外部系统,比如消息broker。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-事件发布和处理</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-事件发布和处理/</id>
    <published>2018-08-31T02:44:40.000Z</published>
    <updated>2018-09-29T07:47:10.910Z</updated>
    
    <content type="html"><![CDATA[<p>由应用程序生成的事件需要被分发到更新查询数据库的组件，搜索引擎或其他需要它们的资源：事件处理程序（Event Handlers）。事件总线（Event Bus）的职责是分发事件消息到所有感兴趣的组件。接收端，事件处理器（Event Processors）负责处理这些事件，其中包括相应的事件处理程序（Event Handlers）的调用。</p><a id="more"></a><h2 id="发布事件（Publishing-Events）"><a href="#发布事件（Publishing-Events）" class="headerlink" title="发布事件（Publishing Events）"></a>发布事件（Publishing Events）</h2><p>在绝大多数情况下，聚合将通过申请（applying）它们发布事件。然而，有时候也有必要发布一个事件(可能来自另一个组件)，直接到事件总线。发布一个事件，在EventMessage中简单封装描述事件的有效负载（payload）。</p><p>GenericEventMessage.asEventMessage(Object)方法允许你将任何对象包装成EventMessage。如果传递的对象已经是EventMessage，它只是返回。</p><h2 id="事件总线（Event-Bus）"><a href="#事件总线（Event-Bus）" class="headerlink" title="事件总线（Event Bus）"></a>事件总线（Event Bus）</h2><p>EventBus是分发事件到已订阅的事件处理器的机制。Axon 提供了两个事件总线的实现：SimpleEventBus和EmbeddedEventStore。两个实现都支持订阅和跟踪处理器(processor)，EmbeddedEventStore持久化事件，它允许你在以后的阶段重放它们。SimpleEventBus有一个易失性存储器，然后一旦事件已经发布到订阅组件上，就会“忘记”它们。</p><p>当使用配置API时，默认情况下使用SimpleEventBus。配置EmbeddedEventStore则相反，需要提供一个StorageEngine的实现，它对事件进行实际存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Configurer configurer = DefaultConfigurer.defaultConfiguration();</span><br><span class="line">configurer.configureEmbeddedEventStore(c -&gt; new InMemoryEventStorageEngine());</span><br></pre></td></tr></table></figure><h2 id="Event-Processors"><a href="#Event-Processors" class="headerlink" title="Event Processors"></a>Event Processors</h2><p>事件处理程序（Event Handlers）定义了接收事件时执行的业务逻辑。事件处理器（Event Processors）负责解决该过程的技术方面的组件。它们启动一个工作单元，也可能一个事务，并且确保相关的数据在事件处理期间，可以正确附加到所有创建的消息上。</p><p>事件处理器大致有两种形式：订阅和跟踪。订阅事件处理器订阅它们自己给事件源，并由发布机制管理的线程调用。另一方面，跟踪事件处理器使用自己管理的线程从源中取出它们的消息。</p><h2 id="将处理程序分配给处理器"><a href="#将处理程序分配给处理器" class="headerlink" title="将处理程序分配给处理器"></a>将处理程序分配给处理器</h2><p>所有处理器都有一个名称，它跨JVM实例标识一个处理器实例。两个名称相同的处理器，可以被认为是同一处理器的两个实例。<br>所有事件处理程序都被附加到一个处理器，它的名字是事件处理程序类的包名。<br>例如, 下面的类：</p><ul><li>org.axonframework.example.eventhandling.MyHandler,</li><li>org.axonframework.example.eventhandling.MyOtherHandler</li><li>org.axonframework.example.eventhandling.module.MyHandler</li></ul><p>将触发两个处理器的创建：</p><ul><li>org.axonframework.example.eventhandling with 2 handlers, and</li><li>org.axonframework.example.eventhandling.module with a single handler</li></ul><p>配置API允许你为分配的类配置其他策略给处理器，甚至将特定实例分配给特定的处理器。</p><h2 id="配置处理器"><a href="#配置处理器" class="headerlink" title="配置处理器"></a>配置处理器</h2><p>默认情况下，Axon将使用订阅事件处理器。这是有可能改变处理程序是如何分配和如何使用配置API的EventHandlingConfiguration类配置处理器的。</p><p>EventHandlingConfiguration类定义了一些的方法，可用于定义处理器需要如何配置。</p><ul><li>registerEventProcessorFactory允许你定义一个默认的工厂方法，创建没有明确定义工厂的事件处理器。</li><li>registerEventProcessor(String name, EventProcessorBuilder builder)定义了用于创建一个带有给定名称的处理器的工厂方法。注意，此种处理器只有当名称被选择作为任何可用的事件处理程序bean的处理器时才会创建。</li><li>registerTrackingProcessor(String name)定义了一个带有给定名称的处理器，使用默认设置，应该被配置成一个跟踪事件处理器。它使用TransactionManager和TokenStore配置。</li><li>usingTrackingProcessors()设置默认跟踪处理器，而不是订阅处理器。</li></ul><p>跟踪处理器不像订阅处理器，需要一个令牌存储来存储它们的进程。跟踪处理器通过其事件流接收的每个消息都伴随着一个令牌。这个令牌允许处理器在任何以后的点重新打开流，并在最后一个事件中提取它。</p><p>配置API负责令牌存储，以及大多数其他组件处理器需要从全局配置实例。如果没有明确定义TokenStore ，在生产中不推荐使用InMemoryTokenStore。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/217ac0d8822d" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/217ac0d8822d</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由应用程序生成的事件需要被分发到更新查询数据库的组件，搜索引擎或其他需要它们的资源：事件处理程序（Event Handlers）。事件总线（Event Bus）的职责是分发事件消息到所有感兴趣的组件。接收端，事件处理器（Event Processors）负责处理这些事件，其中包括相应的事件处理程序（Event Handlers）的调用。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-分布式命令总线连接器</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%88%86%E5%B8%83%E5%BC%8F%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF%E8%BF%9E%E6%8E%A5%E5%99%A8/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-分布式命令总线连接器/</id>
    <published>2018-08-31T02:40:27.000Z</published>
    <updated>2018-09-29T07:47:11.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JGroupsConnector"><a href="#JGroupsConnector" class="headerlink" title="JGroupsConnector"></a>JGroupsConnector</h2><p>JGroupsConnector使用(正如它的名字已经说明)JGroups作为底层发现和调度机制。描述JGroups的特性有太多的参考指南,请参阅JGroups用户指南以了解更多的细节。</p><a id="more"></a><p>因为JGroups既处理节点的发现又处理它们之间的通信，所以JGroupsConnector既充当CommandBusConnector也充当CommandRouter。</p><blockquote><p><b>注意</b><br>你可以在axon-distributed-commandbus-jgroups模块中，为DistributedCommandBus找到JGroups特定组件。</p></blockquote><p>JGroupsConnector有四个强制性配置元素：</p><ul><li>第一种是JChannel，它定义了JGroups协议栈。一般来说，用JGroups配置文件的引用构造JChannel。JGroups附带的默认配置,可以用作自己配置的依据。请记住，IP多路广播一般不工作在云服务中，像亚马逊。中这种类型的环境中， TCP Gossip通常是一个好的开端。</li><li>集群名称定义了每个segment应登记到的集群的名称。具有相同的集群名称的Segment最终会探测到彼此，并在彼此间分发命令。</li><li>“本地segment”是命令总线实现，分发命令去往本地的JVM。这些命令可能已通过其他JVM或从本地的一个实例分发。</li><li>最后，序列化器是用来序列化之前通过线路发送的命令消息。</li></ul><blockquote><p><b>注意</b><br>当使用缓存时，当ConsistentHash更改以避免潜在的数据损坏时，它应该被清空（例如，当命令没有指定一个@TargetAggregateVersion和新成员快速加入和离开JGroup，修改聚合然而它还要缓存到其他地方）。</p></blockquote><p>最终，JGroupsConnector需要实际连接，按顺序分发消息到其他segment。这样做，调用connect()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JChannel channel = new JChannel(&quot;path/to/channel/config.xml&quot;);</span><br><span class="line">CommandBus localSegment = new SimpleCommandBus();</span><br><span class="line">Serializer serializer = new XStreamSerializer();</span><br><span class="line"></span><br><span class="line">JGroupsConnector connector = new JGroupsConnector(channel, &quot;myCommandBus&quot;, localSegment, serializer);</span><br><span class="line">DistributedCommandBus commandBus = new DistributedCommandBus(connector, connector);</span><br><span class="line"></span><br><span class="line">// on one node:</span><br><span class="line">commandBus.subscribe(CommandType.class.getName(), handler);</span><br><span class="line">connector.connect();</span><br><span class="line"></span><br><span class="line">// on another node, with more CPU:</span><br><span class="line">commandBus.subscribe(CommandType.class.getName(), handler);</span><br><span class="line">commandBus.subscribe(AnotherCommandType.class.getName(), handler2);</span><br><span class="line">commandBus.updateLoadFactor(150); // defaults to 100</span><br><span class="line">connector.connect();</span><br><span class="line"></span><br><span class="line">// from now on, just deal with commandBus as if it is local...</span><br></pre></td></tr></table></figure><blockquote><p><b>注意</b><br>注意，并非所有的segment都必需具有相同类型的命令的命令处理器。你完全可以为不同的命令类型使用不同的segment。分布式命令总线总是选择一个节点分发命令到那个支持特定类型的命令。</p></blockquote><p>如果你使用Spring，你可能需要考虑使用JGroupsConnectorFactoryBean。它自动连接连接器当ApplicationContext启动后，并且在ApplicationContext关闭时完全的断开。此外,它为测试环境使用合理的默认值(但不应被视为生产准备)和自动装配配置。</p><h2 id="Spring-Cloud-Connector"><a href="#Spring-Cloud-Connector" class="headerlink" title="Spring Cloud Connector"></a>Spring Cloud Connector</h2><p>Spring Cloud连接器装置，用Spring Cloud来描述使用服务注册和发现机制来分配命令总线。因此，你可以自由选择使用哪一个Spring Cloud实现用来分发你的命令。实现的一个例子是 Eureka Discovery/Eureka 服务器组合。</p><blockquote><p><b>注意</b><br>当前版本(Axon 3.0.4)SpringCloudCommandRouter使用ServiceInstance。Metadata 字段来通知所有系统中的节点，通过CommandNameFilter它可以处理命令。这是很重要的,Spring Cloud实现选择支持ServiceInstance.Metadata字段的使用。例如Spring Cloud Consul目前不支持该字段，因此SpringCloudCommandRouter并不是一个可行的解决方案。我们正在研究一个额外的解决方案，从中检索CommandNameFilter 。</p></blockquote><p>提供每个SpringCloud实现的描述将推动本参考指南。因此，我们参考他们各自的文件以获得进一步的信息。</p><p>Spring Cloud连接器装置是一个SpringCloudCommandRouter和SpringHttpCommandBusConnector的组合，分别填充CommandRouter的地点和 DistributedCommandBus的CommandBusConnector。</p><blockquote><p><b>注意</b><br>Spring Cloud连接器特定的组件DistributedCommandBus可以在axon-distributed-commandbus-springcloud模块中找到 。</p></blockquote><p>SpringCloudCommandRouter必须由以下提供的来创建：</p><ul><li>一个DiscoveryClient类型“discovery client”。这可以通过用@EnableDiscoveryClient注解你的Spring Boot应用程序来提供,将在你的类路径中寻找Spring Cloud 的实现。</li><li>一个RoutingStrategy类型的”routing strategy”。目前axon-core模块提供了一些实现，但是一函数调用也可以满足要求。例如，如果你想路由命令基于“聚合标识符”，你可以使用AnnotationRoutingStrategy和注解有效载荷的字段，用@TargetAggregateIdentifier识别聚合。</li></ul><p>SpringHttpCommandBusConnector需要创建三个参数:</p><ul><li>一个CommandBus类型的“local command bus”。这是命令总线实现，它将分发命令到本地的JVM。这些命令可能是由其他JVM上的或本地的实例分发。</li><li>RestOperations对象来执行一个命令消息的发布到另一个实例。</li><li>最后一个Serializer类型的“序列serializer”。序列化器用于在命令发送到网络之前序列化命令消息。</li></ul><p>SpringCloudCommandRouter和SpringHttpCommandBusConnector应该都被用于创建DistributedCommandsBus。在Spring Java 配置中，看起来如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// Simple Spring Boot App providing the `DiscoveryClient` bean</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class MyApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Example function providing a Spring Cloud Connector</span><br><span class="line">    @Bean</span><br><span class="line">    public CommandRouter springCloudCommandRouter(DiscoveryClient discoveryClient) &#123;</span><br><span class="line">        return new SpringCloudCommandRouter(discoveryClient, new AnnotationRoutingStrategy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CommandBusConnector springHttpCommandBusConnector(@Qualifier(&quot;localSegment&quot;) CommandBus localSegment,</span><br><span class="line">                                                             RestOperations restOperations,</span><br><span class="line">                                                             Serializer serializer) &#123;</span><br><span class="line">        return new SpringHttpCommandBusConnector(localSegment, restOperations, serializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Primary // to make sure this CommandBus implementation is used for autowiring</span><br><span class="line">    @Bean</span><br><span class="line">    public DistributedCommandBus springCloudDistributedCommandBus(CommandRouter commandRouter, </span><br><span class="line">                                                                  CommandBusConnector commandBusConnector) &#123;</span><br><span class="line">        return new DistributedCommandBus(commandRouter, commandBusConnector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// if you don&apos;t use Spring Boot Autoconfiguration, you will need to explicitly define the local segment:</span><br><span class="line">@Bean</span><br><span class="line">@Qualifier(&quot;localSegment&quot;)</span><br><span class="line">public CommandBus localSegment() &#123;</span><br><span class="line">    return new SimpleCommandBus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><b>注意</b><br>注意，并非所有的segment都必需具有相同类型的命令的命令处理器。你完全可以为不同的命令类型使用不同的segment。分布式命令总线总是选择一个节点分发命令到那个支持特定类型的命令。</p></blockquote><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/ccef9924f8d7" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/ccef9924f8d7</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JGroupsConnector&quot;&gt;&lt;a href=&quot;#JGroupsConnector&quot; class=&quot;headerlink&quot; title=&quot;JGroupsConnector&quot;&gt;&lt;/a&gt;JGroupsConnector&lt;/h2&gt;&lt;p&gt;JGroupsConnector使用(正如它的名字已经说明)JGroups作为底层发现和调度机制。描述JGroups的特性有太多的参考指南,请参阅JGroups用户指南以了解更多的细节。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework命令拦截器</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%91%BD%E4%BB%A4%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-命令拦截器/</id>
    <published>2018-08-31T02:29:32.000Z</published>
    <updated>2018-09-27T06:22:48.055Z</updated>
    
    <content type="html"><![CDATA[<p>使用命令总线的优点之一，是能够基于所有传入的命令采取相应的行动。例子是，不论哪种命令类型，你都希望去做日志记录或身份验证。这是使用拦截器来完成的。</p><a id="more"></a><p>有不同类型的拦截器：Dispatch拦截器和Handler拦截器。前者在命令被分发到命令处理程序之前被调用。在那时，它甚至不能确定该命令有任何处理器的存在。后者在命令处理程序被调用之前调用。</p><h2 id="Message-Dispatch-Interceptors（消息分发拦截器）"><a href="#Message-Dispatch-Interceptors（消息分发拦截器）" class="headerlink" title="Message Dispatch Interceptors（消息分发拦截器）"></a>Message Dispatch Interceptors（消息分发拦截器）</h2><p>当命令在命令总线上被分发时调用消息分发拦截器。例如，它们可以通过添加元数据来更改命令消息，或通过抛出异常来阻塞命令。这些拦截器总是在分发命令的线程上被调用。</p><p>##Structural validation（结构性验证）</p><p>如果它没有包含正确格式的所有必需的信息，那么处理命令是没有意义的,。事实上，一个命令缺乏信息应该尽可能早地被阻塞，甚至最好是任何事务开始之前。因此，拦截器应该检查所有传入命令的信息的可用性。这就是所谓的结构性验证。</p><p>Axon Framework支持基于JSR 303 Bean Validation的验证。这允许你用像@NotEmpty和@Pattern这样的注解，去注解命令上的字段。你需要在你的类路径中include一个JSR 303实现(比如Hibernate-Validator)。然后，在命令总线上配置一个BeanValidationInterceptor，它会自动找到并配置你的验证器实现。虽然它使用合理的默认值，但你可以根据具体需要调整它。</p><blockquote><p><b>提示</b><br>你想在一个无效的命令上使用尽可能少的资源。因此，该拦截器通常是位于拦截器链的最前端。在某些情况下，一个日志或审计拦截器可能需要放在前面，紧跟着它的是验证拦截器。</p></blockquote><p>BeanValidationInterceptor还实现了MessageHandlerInterceptor，也允许你把它配置为一个处理程序（Handler）拦截器。</p><h2 id="Message-Handler-Interceptors（消息处理程序拦截器）"><a href="#Message-Handler-Interceptors（消息处理程序拦截器）" class="headerlink" title="Message Handler Interceptors（消息处理程序拦截器）"></a>Message Handler Interceptors（消息处理程序拦截器）</h2><p>消息处理程序拦截器可以在命令处理之前和之后执行操作。拦截器甚至可以完全阻止命令处理，例如出于安全原因。</p><p>拦截器必须实现MessageHandlerInterceptor接口。该接口声明了一个方法handle，它需要三个参数：命令消息，当前的UnitOfWork和InterceptorChain。InterceptorChain用于继续分发处理。</p><p>与分发拦截器不同，处理程序拦截器在命令处理程序上下文中被调用。这意味着它们可以根据正在处理消息的工作单元附上相关数据。然后这个相关数据将被附加到在工作单元的上下文中被创建的消息。</p><p>处理程序拦截器也通常用于管理围绕命令处理的事务。这么做，注册一个TransactionManagingInterceptor，使用TransactionManager依次配置启动和提交(或回滚)实际事务。</p><h2 id="Distributing-the-Command-Bus-分布式命令总线"><a href="#Distributing-the-Command-Bus-分布式命令总线" class="headerlink" title="Distributing the Command Bus(分布式命令总线)"></a>Distributing the Command Bus(分布式命令总线)</h2><p>CommandBus的实现在早期声称只允许命令消息在单个JVM上分发。有时候，你想把不同JVM中的命令总线的多个实例作为一个。当返回任何结果时，在一个JVM命令总线上发出的命令应该无缝地传到到另一个JVM中的命令处理程序。</p><p>这就是DistributedCommandBus（分布式命令总线）的由来。不像其他CommandBus的实现，DistributedCommandBus不调用任何处理器。它的作用是在不同的JVM的命令总线实现之间形成一座“桥”。每个JVM上的DistributedCommandBus实例称为“Segment”。</p><blockquote><p><b>注意</b><br>虽然分布式命令总线本身是Axon Framework核心模块的一部分，但它需要的组件，你可以在其中一个以axon-distributed-commandbus -开头的模块中找到。如果你使用Maven，确保你有适当的依赖集。groupId和version与核心模块相同。</p></blockquote><p>DistributedCommandBus依赖于两个组件：一个是CommandBusConnector，实现JVM的之间的通信协议；一个是CommandRouter，为每个传入的命令选择目的地。这个路由器定义分布式总线命令的segment应该given一个命令，根据路由键计算得到路由策略。两个具有相同路由键的命令将始终路由到相同的segment，只要segment数量和配置没有改变。一般来说，用目标聚合的标识符作为路由键。</p><p>提供两个RoutingStrategy的实现：MetaDataRoutingStrategy，它使用元数据属性在命令消息中查找路由键，而AnnotationRoutingStrategy，它使用注解在命令消息有效负载上的@TargetAggregateIdentifier来提取路由键。显然，你也可以提供自己的实现。</p><p>默认情况下，当命令消息没有键能被解析时，RoutingStrategy实现将抛出一个异常时。这种行为可以改变，通过在MetaDataRoutingStrategy或AnnotationRoutingStrategy的构造函数中提供一个UnresolvedRoutingKeyPolicy。有三个可能的策略:</p><ul><li>ERROR:这是默认值，当路由键不可用时，会抛出一个异常。</li><li>RANDOM_KEY：将返回一个随机值，当一个路由键不能从命令消息解析。这实际上意味着这些命令将被路由到命令总线的随机segment。</li><li>STATIC_KEY:将返回一个静态键(现有的“未被解析的”)为未被解析的路由键。这实际上意味着所有这些命令将被路由到相同的segment，只要segment的配置不改变。</li></ul><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/d603a00bc5cc" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/d603a00bc5cc</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用命令总线的优点之一，是能够基于所有传入的命令采取相应的行动。例子是，不论哪种命令类型，你都希望去做日志记录或身份验证。这是使用拦截器来完成的。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework命令总线</title>
    <link href="https://blog.weechang.xyz/2018/08/31/AxonFramework-%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF/"/>
    <id>https://blog.weechang.xyz/2018/08/31/AxonFramework-命令总线/</id>
    <published>2018-08-31T02:25:51.000Z</published>
    <updated>2018-09-27T06:22:48.008Z</updated>
    
    <content type="html"><![CDATA[<p>命令总线是将命令分发给各自的命令Handler的机制。每个命令总是被精确发送到一个命令Handler。如果没有可用的命令Handler为已分发的命令，将会抛出NoHandlerForCommandException异常。对同一命令类型订阅多个命令Handler将导致订阅互相取代。在这种情况下，最后一个订阅获胜。</p><a id="more"></a><h2 id="分发命令"><a href="#分发命令" class="headerlink" title="分发命令"></a>分发命令</h2><p>CommandBus提供了两个方法去分发命令到它们各自的Handler：dispatch(commandMessage,callback)和dispatch(commandMessage)。第一个参数是一个包含要发送的实际命令的消息。第二个可选的参数接收一个回调，允许在命令处理完成时通知分发组件。这个回调有两个方法:onSuccess()和onFailure()，分别会在命令处理返回后被调用，或者当它抛出一个异常时调用。</p><p>调用组件可能不采取在分发命令的同一线程中调用回调。如果调用线程在继续之前依赖于结果，你可以使用FutureCallback。这是一个Future(在java.concurrent包中定义)和Axon的CommandCallback的组合。或者，考虑使用命令网关。</p><p>如果一个应用程序不直接对命令的结果感兴趣，可以使用dispatch(commandMessage) 方法。</p><h2 id="SimpleCommandBus"><a href="#SimpleCommandBus" class="headerlink" title="SimpleCommandBus"></a>SimpleCommandBus</h2><p>SimpleCommandBus，顾名思义，最简单的实现。它在分发它们的线程中简单的处理命令。命令处理后，修改后的聚合在同一线程被保存和发布生成的事件。在大多数情况下，如web应用程序，该实现将符合你的需求。配置API中SimpleCommandBus是默认使用的实现。</p><p>像大多数CommandBus实现一样，SimpleCommandBus允许拦截器进行配置。在命令总线上分发一个命令后调用CommandDispatchInterceptors。在实际的命令handler 方法之前调用CommandHandlerInterceptors，允许你修改或阻塞命令。有关更多信息，请参考命令处理器拦截器。</p><p>因为所有命令处理都在同一线程中完成，这个实现仅限于JVM的边界。这个实现的性能是很好的，但不超凡。跨JVM边界，或使你的CPU cycles发挥最大的功效，看看其他CommandBus实现。</p><h2 id="AsynchronousCommandBus"><a href="#AsynchronousCommandBus" class="headerlink" title="AsynchronousCommandBus"></a>AsynchronousCommandBus</h2><p>顾名思义，AsynchronousCommandBus实现从分发它们的线程异步执行命令。它使用一个Executor在不同的线程来执行实际的处理逻辑。</p><p>默认情况下，AsynchronousCommandBus使用一个unbounded缓存的线程池。这意味着分发一个命令时会创建线程。完成处理命令的线程将被重新用于新命令。如果60秒线程没有处理命令，则会停止线程。</p><p>或者，Executor实例可以提供不同的线程策略配置。</p><p>注意，应用程序停止时应该关闭AsynchronousCommandBus，以确保任何等待线程正确关闭。关闭，调用shutdown()方法。这也将关闭任何Executor实例，如果它实现ExecutorService接口的话。</p><h2 id="DisruptorCommandBus"><a href="#DisruptorCommandBus" class="headerlink" title="DisruptorCommandBus"></a>DisruptorCommandBus</h2><p>SimpleCommandBus具有合理的性能特性，特别是当你经历了性能调优技巧。事实上，SimpleCommandBus需要锁来防止多个线程并发访问同一聚合，导致处理开销和锁争用。</p><p>DisruptorCommandBus采用不同的方法进行多线程处理。不是多个线程每个都执行同样的处理，而是有多个线程，每个负责一件处理。DisruptorCommandBus使用Disruptor，一个小的并发编程框架，通过不同的方法对多线程进行处理来实现更好的性能。任务不是在调用线程中进行处理，而是将任务移交给两组线程进行处理，每组线程负责一部分处理。第一组的线程将执行命令handler，更改一个聚合的状态。第二组将存储并将事件发布到事件存储。</p><p>虽然DisruptorCommandBus轻易优于SimpleCommandBus 4倍(!)，但有一些限制:</p><ul><li>DisruptorCommandBus仅支持事件溯源聚合。这个命令总线充当由Disruptor处理聚合的存储库。获取一个存储库的引用，使用createRepository(AggregateFactory)。</li><li>一个命令只能导致一个聚合实例状态变化。</li><li>当使用缓存时，它只允许给定的标识符为单个聚合。这意味着它是不可能有两个具有相同的标识符的不同类型的聚合。</li><li>命令一般不会引发需要回滚工作单元的故障。当发生回滚时，DisruptorCommandBus不能保证命令按照它们被分发的顺序进行处理。此外，它需要重试其他命令，从而造成不必要的计算。</li><li><p>在创建一个新的聚合实例时，命令更新所创建实例可能并不完全按照所提供的顺序进行。一旦创建了聚合，所有命令将按照它们被分发顺序执行。为了确保顺序，在创建命令上使用回调去等待正在创建的聚合。它不应该耗时超过几毫秒。<br>构建一个DisruptorCommandBus实例，你需要一个EventStore。该组件在Repositories and Event Stores中有解释。<br>或者，你可以提供一个DisruptorConfiguration实例，它允许你调整配置优化你的特定环境下的性能：</p></li><li><p>Buffer size:在ringBuffer上注册传入命令的槽数。更高的值可能会增加吞吐量,但也导致更高的延迟。必须是2的次方数，默认为4096。</p></li><li>ProducerType: 表示条目是由单线程或多线程生成的。默认为多线程。</li><li>WaitStrategy：当处理器线程（三个线程负责的实际处理）需要等待对方时使用的策略。最好的WaitStrategy取决于机器上可用的处理器数量，和正在运行的其他进程的数量。如果低延迟是至关重要的，DisruptorCommandBus可以自己认领内核，你可以使用BusySpinWaitStrategy。为了使命令总线索取更少的CPU并且允许其他线程处理，使用YieldingWaitStrategy。最后，你可以使用SleepingWaitStrategy和BlockingWaitStrategy允许其他进程共享CPU。如果命令总线不需要进行专职处理，则后者是合适的。默认为BlockingWaitStrategy。</li><li>Executor：设置Executor为DisruptorCommandBus提供线程。这个Executor必须能够提供至少4个线程。其中的3个线程，由DisruptorCommandBus的处理组件认领。额外的线程用于调用回调函数，并计划重试以防检测到错误的聚合状态。默认是CachedThreadPool提供线程从一个称为“DisruptorCommandBus”的线程组中。</li><li>TransactionManager：定义了事务管理器，应该确保存储和事件发布以事务的方式执行。</li><li>InvokerInterceptors:定义了在调用处理中使用的CommandHandlerInterceptors。这个处理调用实际的命令处理器方法。</li><li>PublisherInterceptors:定义了在发布处理中使用的CommandHandlerInterceptors。这个发布处理存储和发布生成的事件。</li><li>RollbackConfiguration:定义工作单元应该回滚的异常。默认配置为回滚未经检查的异常。</li><li>RescheduleCommandsOnCorruptState:指示已经执行过命令但损坏的聚合(如:因为一个工作单元是回滚)是否应该重新计划。如果为假，回调的onFailure()方法将被调用。如果为的(默认),命令将被重新计划。</li><li>CoolingDownPeriod:设置等待的秒数，以确保所有命令被处理。在冷却期间，不接受新命令，但是现有的命令仍然处理，并在必要时重新计划。冷却期间确保线程可供重新安排命令和调用回调之用。默认为1000(1秒)。</li><li>缓存:设置缓存存储从Event Store中恢复的聚合实例。缓存用disruptor存储不活跃的聚合实例。</li><li>InvokerThreadCount:给命令处理器的调用分配线程的数量。一个好的起始点是机器内核数量的一半。</li><li>PublisherThreadCount:用于发布事件的线程数量。一个好的起始点是一半的内核数量，如果IO上花费大量的时间，可以增加。</li><li>SerializerThreadCount:使用pre-serialize事件的线程数量。默认为1，但如果没有配置序列化器将被忽略。</li><li>Serializer:用于执行pre-serialization的序列化器。当配置序列化器时，DisruptorCommandBus将包装所有生成的事件在一个SerializationAware消息上。附加有效负载和元数据的序列化形式，在发布到事件存储之前。</li></ul><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/6aee33abd7f0" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/6aee33abd7f0</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;命令总线是将命令分发给各自的命令Handler的机制。每个命令总是被精确发送到一个命令Handler。如果没有可用的命令Handler为已分发的命令，将会抛出NoHandlerForCommandException异常。对同一命令类型订阅多个命令Handler将导致订阅互相取代。在这种情况下，最后一个订阅获胜。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework-测试带注解的Saga</title>
    <link href="https://blog.weechang.xyz/2018/08/29/AxonFramework-%E6%B5%8B%E8%AF%95%E5%B8%A6%E6%B3%A8%E8%A7%A3%E7%9A%84Saga/"/>
    <id>https://blog.weechang.xyz/2018/08/29/AxonFramework-测试带注解的Saga/</id>
    <published>2018-08-29T03:30:56.000Z</published>
    <updated>2018-09-29T07:47:11.202Z</updated>
    
    <content type="html"><![CDATA[<p>与命令处理组件类似，saga有一个明确定义的接口：它们只对事件作出响应。另一方面，saga通常具有时间概念，并且可以作为事件处理过程的一部分与其他组件交互。Axon Framework的测试支持模块包含帮助你编写saga测试的固件。</p><a id="more"></a><p>每个测试固件包含三个阶段，类似于前面部分描述的命令处理组件固件。</p><ul><li>given 某些事件(从某些聚合),</li><li>when事件到达或时间流逝，</li><li>expect某些行为或状态。</li></ul><p>“given ”和“when”阶段都接受事件作为它们交互的一部分。在“given”阶段，可能会忽略所有副作用，如生成的命令。在“when”阶段，另一方面，从被记录和被验证的saga生成事件和命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FixtureConfiguration fixture = new SagaTestFixture(InvoicingSaga.class);</span><br><span class="line">fixture.givenAggregate(invoiceId).published(new InvoiceCreatedEvent()) </span><br><span class="line">       .whenTimeElapses(Duration.ofDays(31)) </span><br><span class="line">       .expectDispatchedCommandsMatching(Matchers.listWithAllOf(aMarkAsOverdueCommand())); </span><br><span class="line">       // or, to match against the payload of a Command Message only </span><br><span class="line">       .expectDispatchedCommandsMatching(Matchers.payloadsMatching(Matchers.listWithAllOf(aMarkAsOverdueCommand())));</span><br></pre></td></tr></table></figure><p>saga可以分发命令使用一个回调函数通知命令处理的结果。由于在测试中没有实际的命令处理完成，该行为使用CallbackBehavior对象定义。这个对象使用setCallbackBehavior()在固件上注册，并定义当一个命令被分发后，是否和如何必须调用回调函数。</p><p>不是直接使用CommandBus，而是你还可以使用命令网关。见下文如何规定他们的行为。</p><p>通常，saga将与资源交互。这些资源不是saga状态的一部分，但在saga加载和创建后被注入。测试固件允许你注册需要被注入到saga中的资源。要注册一个资源，只需用资源作为参数调用fixture.registerResource(Object)方法。固件将在saga上检测合适的setter方法或字段(带有@Inject注解)并用一个可用的资源调用它。</p><blockquote><p><b>提示</b><br>注入模拟对象(例如Mockito或Easymock)到你的saga，可能是非常有益的。它允许你验证saga与外部资源的正确交互。</p></blockquote><p>命令网关为saga提供了一个更简单的方式来调度命令。使用自定义命令网关还可以更容易地创建模拟或桩来定义其在测试中的行为。然而，当提供一个模拟或桩时，实际的命令可能不不会被分发，因此无法验证测试固件中发送的命令。</p><p>因此，固件提供了两个方法，让你注册命令网关和一个可选的模拟定义其行为:registerCommandGateway(Class)和registerCommandGateway(Class, Object)。这两种方法都返回一个given类的实例，表示要使用的网关。这个实例也注册为资源，使它具有资源注入的资格。</p><p>当registerCommandGateway(Class)用来注册一个网关时，它分发命令到由固件管理的CommandBus。网关的行为主要是通过CallbackBehavior定义于固件。如果没有提供明确的CallbackBehavior，回调不调用，从而无法为网关提供任何返回值。</p><p>当registerCommandGateway(Class, Object)是用来注册一个网关，第二个参数是用于定义网关的行为。</p><p>测试固件试图尽可能消除系统时间迁延。这意味着它将会在测试执行时显得没有时间迁延。除非你显式地声明使用whenTimeElapses()。所有事件都将拥有测试固件创建那一刻的时间戳。</p><p>在测试期间暂停时间，可以更容易地预测在什么时间计划发布事件。如果你的测试用例验证一个事件在30秒后计划发布，它将保持30秒，而不管实际调度和测试执行之间的时间。</p><blockquote><p><b>注意</b><br>固件使用StubScheduler作为基于时间的活动，如调度事件和推进时间。固件将发送到saga实例的任何事件的时间戳设置为这个scheduler的时间。这意味着一旦固件开始，时间就“stopped”，并可能提前确定使用whenTimeAdvanceTo和whenTimeElapses方法。</p></blockquote><p>你还可以使用与测试固件无关的StubEventScheduler，如果你需要测试事件的调度。这个EventScheduler实现允许你验证哪个事件被安排在哪个时间，并且给你选择操纵时间的进展。你可以将时间提前到一个特定的时间，将时钟移动到一个特定的日期和时间，或者将时间提前到下一个计划的事件。所有这些操作将返回进度间隔内计划的事件。</p><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/49429788e7da" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/49429788e7da</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与命令处理组件类似，saga有一个明确定义的接口：它们只对事件作出响应。另一方面，saga通常具有时间概念，并且可以作为事件处理过程的一部分与其他组件交互。Axon Framework的测试支持模块包含帮助你编写saga测试的固件。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
  <entry>
    <title>AxonFramework测试</title>
    <link href="https://blog.weechang.xyz/2018/08/29/AxonFramework-%E6%B5%8B%E8%AF%95/"/>
    <id>https://blog.weechang.xyz/2018/08/29/AxonFramework-测试/</id>
    <published>2018-08-29T02:30:35.000Z</published>
    <updated>2018-09-29T07:47:11.052Z</updated>
    
    <content type="html"><![CDATA[<p>CQRS最大的好处之一，尤其是事件溯源就事件和命令而言，单纯地表达测试是可能的。这两个功能组件，事件和命令对领域专家或业务所有者都有明确的含义。这不仅意味着测试表达就事件和命令而言有明确的功能含义，这也意味着他们不依靠任何实现选择。</p><a id="more"></a><p>本章描述的特性需要axon-test模块,可通过配置maven依赖(使用<artifactid>axon-test</artifactid>和<scope>test&lt;/scope)或通过完整包下载。</scope></p><p>本章中描述的固件可用于任何测试框架，如JUnit和TestNG。</p><h2 id="命令组件测试"><a href="#命令组件测试" class="headerlink" title="命令组件测试"></a>命令组件测试</h2><p>在任何CQRS基础架构中命令处理组件通常是最复杂的。比其他组件更复杂，这也意味着该组件有额外的与测试相关的需求。</p><p>虽然更复杂，但是命令的API处理组件相当容易。它有一个命令进来，然后事件出去。在某些情况下，可能有一个查询作为命令执行的一部分。除此之外，命令和事件是API的唯一部分。这意味着可以在事件和命令的基础上完整地定义测试场景。典型地，以：</p><ul><li>given过去的某些事件，</li><li>when 执行这个命令，</li><li>expect 这些事件将被发布和/或存储</li></ul><p>Axon Framework提供了一个测试固件，使你能够做到这一点。AggregateTestFixture允许你配置某些基础设施，包括必要的命令处理器和存储库，并以given-when-then形式的事件和命令来表达你的场景。</p><p>下面的示例展示了用JUnit 4对given-when-then测试固件的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MyCommandComponentTest &#123;</span><br><span class="line"> private FixtureConfiguration fixture;</span><br><span class="line"> @Before</span><br><span class="line"> public void setUp() &#123;</span><br><span class="line">     fixture = new AggregateTestFixture(MyAggregate.class);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Test</span><br><span class="line"> public void testFirstFixture() &#123;</span><br><span class="line">     fixture.given(new MyEvent(1))</span><br><span class="line">            .when(new TestCommand())</span><br><span class="line">            .expectSuccessfulHandlerExecution()</span><br><span class="line">            .expectEvents(new MyEvent(2));</span><br><span class="line">     /*</span><br><span class="line">     These four lines define the actual scenario and its expected</span><br><span class="line">     result. The first line defines the events that happened in the</span><br><span class="line">     past. These events define the state of the aggregate under test.</span><br><span class="line">     In practical terms, these are the events that the event store</span><br><span class="line">     returns when an aggregate is loaded. The second line defines the</span><br><span class="line">     command that we wish to execute against our system. Finally, we</span><br><span class="line">     have two more methods that define expected behavior. In the</span><br><span class="line">     example, we use the recommended void return type. The last method</span><br><span class="line">     defines that we expect a single event as result of the command</span><br><span class="line">     execution.</span><br><span class="line">     /*</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>given-when-then测试固件定义了三个阶段：配置、执行和验证。每个阶段由不同的接口表示：分别是，FixtureConfiguration, TestExecutor 和 ResultValidator。固件类的静态newGivenWhenThenFixture()方法提供了对第一个的引用，进而可能提供验证，等等。</p><blockquote><p><b>注意</b><br>为了最好地利用这些阶段之间的迁移，最好使用这些方法提供的流式接口，如上面的示例所示。</p></blockquote><p>在配置阶段（即在提供第一个“given”之前），你提供了执行测试所需的构件。作为固件的一部分提供事件总线、命令总线和事件存储的专用版本。有accessor方法来获得对它们的引用。任何命令处理器不直接在聚合上注册，需要显式地使用registerAnnotatedCommandHandler 方法配置。除了带注解的命令处理器外，你还可以配置各种组件和设置，定义应该如何设置测试周围的基础设施。</p><p>一旦固件配置好，你就可以定义“given”事件。测试固件将用DomainEventMessage包装这些事件。如果“given”事件实现消息，消息的有效负载和元数据将被纳入DomainEventMessage，否则given事件作为有效负载。DomainEventMessage 的序列号顺序，从0开始。</p><p>或者，你也可以为“given”场景提供命令。在这种情况下，在执行实际的测试命令时，这些命令生成的事件将被用于事件源聚合。使用“givenCommands(…)”方法提供命令对象。</p><p>执行阶段允许你提供一个针对命令处理组件执行的命令。对调用处理程序的行为(无论是在聚合或外部处理程序)进行监控，并与在验证阶段注册的预期进行比较。</p><blockquote><p><b>注意</b><br>在执行测试过程中，Axon试图检测测试中的所有在聚合上的非法状态的更改。它通过将聚合的状态与命令执行后的聚合状态进行比较，如果它从所有“given”和存储的事件溯源。如果状态不相同，这意味着状态变化发生在聚合事件处理器方法之外。比较时将忽略静态和瞬态字段，因为它们通常包含对资源的引用。<br>可以使用setReportIllegalStateChange方法在固件的配置中切换检测。</p></blockquote><p>最后一个阶段是验证阶段，允许你检查命令处理组件的活动。这完全是根据返回值和事件来完成的。</p><p>测试固件允许你验证命令处理程序的返回值。你可以显式地定义预期的返回值，或者简单地要求成功返回该方法。你也可以表达任何你期望的CommandHandler抛出的异常。</p><p>另一个组件是对已发布事件的验证。有两种匹配预期事件的方法。</p><p>第一是通过事件实例，它需要与实际的事件是行逐字的比较。将预期事件的所有属性与实际事件中的对应对象进行比较（使用equals()）。如果其中一个属性不相等，则测试失败，并生成一个广泛的错误报告。</p><p>表达期望的另一种方式是使用的匹配器(Hamcrest库提供的)。匹配器接口规定了两个方法matches(Object)和describeTo(Description)。第一个返回一个布尔值，指示是否匹配或不匹配。第二个让你表达你的期望。例如，一个“GreaterThanTwoMatcher”可以添加“任何值大于2的事件“的描述。描述允许创建关于测试用例失败的错误消息。</p><p>创建事件列表的匹配器可能是繁琐和容易出错的工作。为了简化问题，Axon提供了一组匹配器允许你提供一组特定于事件的匹配器，并告诉Axon应该如何匹配列表。</p><p>下面是可用的事件列表匹配器和他们的目的的概述：</p><ul><li><p>List with all of: Matchers.listWithAllOf(event matchers…)<br>如果所有的事件匹配器与真实事件列表中至少一个事件匹配，该匹配器将成功。不管是否有多个匹配器匹配相同的事件，或如果列表中一个事件不匹配任何匹配器。</p></li><li><p>List with any of: Matchers.listWithAnyOf(event matchers…)<br>如果一个或多个事件匹配器与实际的事件列表中一个或多个事件匹配，该匹配器将成功。一些匹配器甚至一个也不匹配，而另一个匹配多个。</p></li><li><p>Sequence of Events: Matchers.sequenceOf(event matchers…)<br>使用此匹配器来验证实际事件匹配器和提供的事件匹配器有相同的顺序。如果匹配器与后一个事件相匹配，与前一个匹配器匹配的事件相匹配，该匹配器将成功。这意味着可能出现不匹配事件的“gaps”。<br>如果评估事件之后，更多的匹配器是可用的，他们都是匹配“null”。它是由事件的匹配器来决定是否接受。</p></li><li><p>Exact sequence of Events: Matchers.exactSequenceOf(event matchers…)<br>“事件的序列”匹配器的变化不允许不匹配事件的空隙。这意味着每个匹配器必须与事件后面的事件相匹配，与前一个匹配器匹配的事件相匹配。每个匹配器都应该与它前一个匹配器相对应的事件的后续一个事件相匹配</p></li></ul><p>为了方便起见,提供了一些普遍需要的事件匹配器。他们与单个事件实例相匹配:</p><ul><li><p>Equal Event: Matchers.equalTo(instance…)<br>验证given对象在语义上等于given事件，这个匹配器将比较实际和预期的对象的所有字段的值使用一个null-safe相等方法。这意味着可以比较事件，即使它们不实现equals方法。存储在given参数字段上的对象用equals进行比较，要求他们正确实现。</p></li><li><p>No More Events: Matchers.andNoMore() or Matchers.nothing()<br>仅与空值匹配，这个匹配器可以作为最后一个匹配器添加到事件的准确顺序匹配器,以确保没有不匹配的事件依然存在。</p></li></ul><p>由于匹配器传递一个事件消息列表，有时你只是想验证消息的有效负载。有匹配器来帮助你:</p><ul><li><p>Payload Matching: Matchers.messageWithPayload(payload matcher)<br>验证消息的有效负载匹配给定的有效载荷匹配器。</p></li><li><p>Payloads Matching: Matchers.payloadsMatching(list matcher)<br>验证消息的有效负载匹配给定的有效载荷匹配器。给定的匹配器必须匹配列表包含的每个消息的有效负载。有效负载匹配匹配器通常用作外匹配器,以防止重复有效负载匹配器。</p></li></ul><p>下面是一个简单的代码示例，以显示这些匹配器的使用。在这个例子中,我们预期共有两个事件发布。第一个事件必须是一个“ThirdEvent”，第二个是“aFourthEventWithSomeSpecialThings”。可能没有第三个事件，因为那样”andNoMore”匹配器会失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fixture.given(new FirstEvent(), new SecondEvent())</span><br><span class="line">       .when(new DoSomethingCommand(&quot;aggregateId&quot;))</span><br><span class="line">       .expectEventsMatching(exactSequenceOf(</span><br><span class="line">           // we can match against the payload only:</span><br><span class="line">           messageWithPayload(equalTo(new ThirdEvent())),</span><br><span class="line">           // this will match against a Message</span><br><span class="line">           aFourthEventWithSomeSpecialThings(),</span><br><span class="line">           // this will ensure that there are no more events</span><br><span class="line">           andNoMore()</span><br><span class="line">       ));</span><br><span class="line"></span><br><span class="line">// or if we prefer to match on payloads only:</span><br><span class="line">       .expectEventsMatching(payloadsMatching(</span><br><span class="line">               exactSequenceOf(</span><br><span class="line">                   // we only have payloads, so we can equalTo directly</span><br><span class="line">                   equalTo(new ThirdEvent()),</span><br><span class="line">                   // now, this matcher matches against the payload too</span><br><span class="line">                   aFourthEventWithSomeSpecialThings(),</span><br><span class="line">                   // this still requires that there is no more events</span><br><span class="line">                   andNoMore()</span><br><span class="line">               )</span><br><span class="line">       ));</span><br></pre></td></tr></table></figure><p>作者：勇赴<br>链接：<a href="https://www.jianshu.com/p/2e893c9d48bf" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/2e893c9d48bf</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CQRS最大的好处之一，尤其是事件溯源就事件和命令而言，单纯地表达测试是可能的。这两个功能组件，事件和命令对领域专家或业务所有者都有明确的含义。这不仅意味着测试表达就事件和命令而言有明确的功能含义，这也意味着他们不依靠任何实现选择。&lt;/p&gt;
    
    </summary>
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/categories/AxonFramework/"/>
    
    
      <category term="AxonFramework" scheme="https://blog.weechang.xyz/tags/AxonFramework/"/>
    
  </entry>
  
</feed>
