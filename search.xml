<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>手把手教学，教你把你的个人项目推送到maven中央仓库</title>
      <link href="/2018/07/20/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6%EF%BC%8C%E6%95%99%E4%BD%A0%E6%8A%8A%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/"/>
      <url>/2018/07/20/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6%EF%BC%8C%E6%95%99%E4%BD%A0%E6%8A%8A%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;最近闲下来了，想要自己造点小轮子用，方便自己在不同项目使用，同时想偷懒，不想每次都在项目里面copy代码。于是想到了重要仓库这个东西，把自己的代码托管到github（虽然现在的github已经不再单纯），然后发布jar包到maven中央仓库，以后每个项目都只用引入maven依赖就可以了。同时还能方便好基友们使用，万一哪一天好基友高兴就献身了呢，想想就有点小激动呢。好了废话不多说，下面正式开始手把手教学活动。</p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="https://github.com/weechang/JUtil" target="_blank" rel="noopener">附上小轮子传送门</a>给感兴趣的小伙伴</b></p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;将项目发布到maven仓库需要以下几步:</p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.在sonatype中创建issue </p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.使用gpg生成秘钥 </p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.配置Maven进行deploy和release </p><h1 id="1-在sonatype中创建issue"><a href="#1-在sonatype中创建issue" class="headerlink" title="1 在sonatype中创建issue"></a>1 在sonatype中创建issue</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;首先我们需要在<a href="https://issues.sonatype.org/secure/Dashboard.jspa" targe="_blank" target="_blank" rel="noopener">https://issues.sonatype.org/secure/Dashboard.jspa</a>中新建一个issues。如果没有sonatype账号的话，分分钟注册一个</p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/创建项目.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"></p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;创建完成后就是如下图示</p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/创建完成.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"></p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;这个时候只需要耐心等待工作人员审核就行了，因为我的domain问题，经历了二次审核，但是都很快，一般提交后两个小时内就会有结果。当issues状态变为Resolved就可以继续下一步操作了。</p><h1 id="2-使用gpg生成秘钥"><a href="#2-使用gpg生成秘钥" class="headerlink" title="2 使用gpg生成秘钥"></a>2 使用gpg生成秘钥</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;选择对应的OS版本进行下载安装即可，下载地址传送门：<a href="https://www.gnupg.org/download/index.html" targe="_blank" target="_blank" rel="noopener">https://www.gnupg.org/download/index.html</a></p><h2 id="2-2-生成key"><a href="#2-2-生成key" class="headerlink" title="2.2 生成key"></a>2.2 生成key</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;首先查看安装成功没有 <pre>gpg –version</pre> （MAC 和 Linux系统需要 gpg2 –version）</p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;通过 <pre>gpg –gen-key</pre> 生成key，也可以通过UI界面生成和管理key</p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/生成key.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"></p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;运行后gpg要求你选择加密算法，过期时间等等，这些直接选择默认值即可。通过对比发现，gpg 2.0以上的版本运行gpg –gen-key命令 会跳过这些步骤。</p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;之后gpg要求你输入姓名，邮箱以及关键的Passphrase，依次输入即可。然后gpg为你生成了一对秘钥。</p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;通过<pre>gpg –list-keys</pre>查看生成的key列表</p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/秘钥列表.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"></p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;这里可以看到我的公钥是：34754DFE562C10E1A09907B7F4797C9A95E36DB6，记住这个key，下面我们需要用到。</p><h2 id="2-3-上传公钥"><a href="#2-3-上传公钥" class="headerlink" title="2.3 上传公钥"></a>2.3 上传公钥</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;生成秘钥后，我们需要把公钥上传到服务器上。运行以下命令：<pre>gpg2 –keyserver hkp://pool.sks-keyservers.net –send-keys 34754DFE562C10E1A09907B7F4797C9A95E36DB6（刚才生成的公钥）</pre></p><h1 id="3-配置Maven"><a href="#3-配置Maven" class="headerlink" title="3 配置Maven"></a>3 配置Maven</h1><h2 id="3-1-配置maven-setting-xml"><a href="#3-1-配置maven-setting-xml" class="headerlink" title="3.1 配置maven setting.xml"></a>3.1 配置maven setting.xml</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;需要在本地的maven配置server 和 profile 两个地方，啰嗦的话就不多少了，直接上配置：</p><br><pre><br>    &lt;server&gt;<br>        &lt;id&gt;ossrh&lt;/id&gt;<br>        &lt;username&gt;第一步注册的用户名&lt;/username&gt;<br>        &lt;password&gt;第一步注册的密码&lt;/password&gt;<br>    &lt;/server&gt;<br></pre><br><pre><br>     &lt;profile&gt;<br>         &lt;id&gt;ossrh&lt;/id&gt;<br>         &lt;activation&gt;<br>             &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;<br>         &lt;/activation&gt;<br>         &lt;properties&gt;<br>             &lt;gpg.executable&gt;gpg(MAC 和 Linux用户使用gpg2)&lt;/gpg.executable&gt;<br>             &lt;gpg.passphrash&gt;生成密钥时输入的密码&lt;/gpg.passphrash&gt;<br>         &lt;/properties&gt;<br>    <br></pre><br><br>## 3.2 配置项目的pom.xml<br><p>&nbsp;&nbsp;&nbsp;&nbsp;具体的配置可以查看小轮子里面的pom设置 <a href="https://github.com/weechang/JUtil/blob/master/pom.xml" target="_blank">https://github.com/weechang/JUtil/blob/master/pom.xml</a></p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;首先需要添加指向sonatype仓库的&lt;distributionManagement&gt;</p><br><pre><br>    &lt;distributionManagement&gt;<br>        &lt;snapshotRepository&gt;<br>            &lt;id&gt;ossrh&lt;/id&gt;<br>            &lt;url&gt;<a href="https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;" target="_blank" rel="noopener">https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;</a><br>        &lt;/snapshotRepository&gt;<br>        &lt;repository&gt;<br>            &lt;id&gt;ossrh&lt;/id&gt;<br>            &lt;name&gt;Maven Central Staging Repository&lt;/name&gt;<br>            &lt;url&gt;<a href="https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;" target="_blank" rel="noopener">https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;</a><br>        &lt;/repository&gt;<br>    &lt;/distributionManagement&gt;<br></pre><br><p>&nbsp;&nbsp;&nbsp;&nbsp;继续配置pfofiles,添加各种推送、DOC、加密的插件</p><br><pre><br>    &lt;profiles&gt;<br>        &lt;profile&gt;<br>            &lt;id&gt;release<br>            &lt;build&gt;<br>                &lt;plugins&gt;<br>                    &lt;plugin&gt;<br>                        &lt;groupId&gt;org.sonatype.plugins&lt;/groupId&gt;<br>                        &lt;artifactId&gt;nexus-staging-maven-plugin&lt;/artifactId&gt;<br>                        &lt;version&gt;1.6.8&lt;/version&gt;<br>                        &lt;extensions&gt;true&lt;/extensions&gt;<br>                        &lt;configuration&gt;<br>                            &lt;serverId&gt;ossrh&lt;/serverId&gt;<br>                            &lt;nexusUrl&gt;<a href="https://oss.sonatype.org/&lt;/nexusUrl&gt;" target="_blank" rel="noopener">https://oss.sonatype.org/&lt;/nexusUrl&gt;</a><br>                            &lt;autoReleaseAfterClose&gt;true&lt;/autoReleaseAfterClose&gt;<br>                        &lt;/configuration&gt;<br>                    &lt;/plugin&gt;<br>                    &lt;plugin&gt;<br>                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                        &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;<br>                        &lt;version&gt;3.0.1&lt;/version&gt;<br>                        &lt;executions&gt;<br>                            &lt;execution&gt;<br>                                &lt;id&gt;attach-javadocs&lt;/id&gt;<br>                                &lt;goals&gt;<br>                                    &lt;goal&gt;jar&lt;/goal&gt;<br>                                &lt;/goals&gt;<br>                            &lt;/execution&gt;<br>                        &lt;/executions&gt;<br>                    &lt;/plugin&gt;<br>                    &lt;plugin&gt;<br>                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                        &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;<br>                        &lt;executions&gt;<br>                            &lt;execution&gt;<br>                                &lt;id&gt;attach-sources&lt;/id&gt;<br>                                &lt;goals&gt;<br>                                    &lt;goal&gt;jar-no-fork<br>                                &lt;/goals&gt;<br>                            &lt;/execution&gt;<br>                        &lt;/executions&gt;<br>                    &lt;/plugin&gt;<br>                    &lt;plugin&gt;<br>                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                        &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;<br>                        &lt;version&gt;1.6&lt;/version&gt;<br>                        &lt;executions&gt;<br>                            &lt;execution&gt;<br>                                &lt;id&gt;sign-artifacts&lt;/id&gt;<br>                                &lt;phase&gt;verify&lt;/phase&gt;<br>                                &lt;goals&gt;<br>                                    &lt;goal&gt;sign&lt;/goal&gt;<br>                                &lt;/goals&gt;<br>                            &lt;/execution&gt;<br>                        &lt;/executions&gt;<br>                    &lt;/plugin&gt;<br>                &lt;/plugins&gt;<br>            &lt;/build&gt;<br>        &lt;/profile&gt;<br>    &lt;/profiles&gt;<br></pre><br><p>&nbsp;&nbsp;&nbsp;&nbsp;然后还可以添加一些开发者信息和license信息，具体的就不多说了。具体可以参考小轮子的配置</p><h2 id="3-3-部署到中央仓库"><a href="#3-3-部署到中央仓库" class="headerlink" title="3.3 部署到中央仓库"></a>3.3 部署到中央仓库</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;运行以下代码进行deploy</p><br><pre>mvn clean deploy -P release</pre><br><p>&nbsp;&nbsp;&nbsp;&nbsp;如下图表示成功部署到中央仓库</p><br><img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/部署成功.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"><br><p>&nbsp;&nbsp;&nbsp;&nbsp;因为我们在pom中添加了自动发布插件，所以可以不用管理，直接到中央仓库去查看就能看到你发布的项目了</p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;<b>PS:在部署过成功可能会遇到401的问题，具体请参考传送门 <a href="https://stackoverflow.com/questions/24830610/why-am-i-getting-a-401-unauthorized-error-in-maven" target="_blank">https://stackoverflow.com/questions/24830610/why-am-i-getting-a-401-unauthorized-error-in-maven</a></b></p>]]></content>
      
      <categories>
          
          <category> 开源之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手把手教学 </tag>
            
            <tag> maven中央仓库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础.0——Object类</title>
      <link href="/2018/06/07/java%E5%9F%BA%E7%A1%80-0%E2%80%94%E2%80%94Object%E7%B1%BB/"/>
      <url>/2018/06/07/java%E5%9F%BA%E7%A1%80-0%E2%80%94%E2%80%94Object%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>从这篇文章起就正式开始Java学习之旅了。java中，万物皆对象，所以第一篇先学习Java的Object类，循序渐进。</p><h1 id="一、getClass"><a href="#一、getClass" class="headerlink" title="一、getClass()"></a>一、getClass()</h1><pre>public final native Class<?> getClass();</pre><p>返回此Object的运行时类类型。如： class io.github.weechang.java.base.JavaObject。<br>不可重写，要调用的话，一般和getName()联合使用，如getClass().getName(); // io.github.weechang.java.base.JavaObject</p><h1 id="二、hashCode"><a href="#二、hashCode" class="headerlink" title="二、hashCode()"></a>二、hashCode()</h1><pre>public native int hashCode();</pre><p>返回该对象的哈希值。如：123961122<br>该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。如HashSet、HashMap。<br>如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。</p><h1 id="三、equals"><a href="#三、equals" class="headerlink" title="三、equals()"></a>三、equals()</h1><pre>public boolean equals(Object obj) {    return (this == obj);}</pre><p>Object中的equals方法是直接判断this和obj是否是同一对象，所谓同一对象就是指内存中同一块存储单元，如果this和obj指向的是同一块内存对象，则返回true,如果this和obj指向的不是同一块内存，则返回false。</p><pre>注意：即便是内容完全相等的两块不同的内存对象，也返回false。     如果是同一块内存，则object中的equals方法返回true,如果是不同的内存，则返回false     如果希望不同内存但相同内容的两个对象equals时返回true,则我们需要重写父类的equal方法     Java中一部分类已经重写了object中的equals方法（这样就是比较内容是否相等了），如基本的包装类型 Integer、Long、Boolean等，还有String。</pre><h1 id="四、clone"><a href="#四、clone" class="headerlink" title="四、clone()"></a>四、clone()</h1><pre>protected native Object clone() throws CloneNotSupportedException;</pre><p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。<br>Java里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法（实现深复制）。</p><h2 id="4-1-clone与copy的区别"><a href="#4-1-clone与copy的区别" class="headerlink" title="4.1 clone与copy的区别"></a>4.1 clone与copy的区别</h2><p>在通常操作中，我们常采用的赋值方式为 User u1 = new User(); User u2 = u1;此时，User u2 = u1这种赋值方式就称为copy。此时的赋值只是简单地将u1所指向的内存地址赋值给了u2,所以此时u1、u2引用的是同一块内存空间。所以对u1或者u2任意对象的操作如u1.setId(2);都会带来另一对象的值的改变，此时可以发现u2.getId() 返回值也为2。若我们不希望带来这样的改变，就需要用到clone.User u2 = u1.clone();等价于User u2 = new User(); u2.setId(u1.getId());</p><p><b>copy：只是简单地将内存地址进行引用，实则两者是同一对象,任一对象值的改变，会带来另一对象值的改变。</b><br><b>clone: 两者是不同内存地址的对象，两者值只有在初始clone时一致，一个对象值的改变，不会带来另一对象值的改变。</b></p><h2 id="4-2-Shallow-Clone与Deep-Clone"><a href="#4-2-Shallow-Clone与Deep-Clone" class="headerlink" title="4.2 Shallow Clone与Deep Clone"></a>4.2 Shallow Clone与Deep Clone</h2><p>Object在对某个对象实施仅仅是简单地执行域对域的copy，这就是Shallow Clone。若User中存在一属性为 Date birthDay，此时u1与U2的引诱关系图如下：<br><img src="/2018/06/07/java基础-0——Object类/clone.png" title="Shallow Clone"><br>此时，除了基本数据类型是值的clone外，非基本数据类型都只是引用的clone。所以此时clone对象与原对象存在一部分相同的引用。此时任一对象的非基本类型的值改变，会导致另一对象的值的改变。若要解决此问题就需要Deep Clone。<br>针对User 对象可以对clone方法进行改造，如下：</p><pre>@Overrideprotected Object clone() throws CloneNotSupportedException {    User cloned = (User) super.clone();    cloned.birthDay = (Date) birthDay.clone();    return cloned;}</pre><h1 id="五、toString"><a href="#五、toString" class="headerlink" title="五、toString()"></a>五、toString()</h1><pre>public String toString() {    return getClass().getName() + "@" + Integer.toHexString(hashCode());}</pre><p>返回值为 字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。如 ：io.github.weechang.java.base.obj.User@762efe5d</p><h1 id="六、notify"><a href="#六、notify" class="headerlink" title="六、notify()"></a>六、notify()</h1><pre>public final native void notify();</pre><p>该方法唤醒在该对象上等待的某个线程</p><h1 id="七、notifyAll"><a href="#七、notifyAll" class="headerlink" title="七、notifyAll()"></a>七、notifyAll()</h1><pre>public final native void notifyAll();</pre><p>该方法唤醒在该对象上等待的所有线程。</p><h1 id="八、wait"><a href="#八、wait" class="headerlink" title="八、wait()"></a>八、wait()</h1><pre>public final void wait() throws InterruptedException {    wait(0);}</pre><pre>public final native void wait(long timeout) throws InterruptedException;</pre><pre>/***@param timeout  等待该线程终止的时间最长为timeout毫秒。 *@param nanos 等待时间为 timeout毫秒+nanos纳秒*/public final void wait(long timeout, int nanos) throws InterruptedException {      if (timeout < 0) {          throw new IllegalArgumentException("timeout value is negative");      }      if (nanos < 0 || nanos > 999999) {          throw new IllegalArgumentException("nanosecond timeout value out of range");      }     if (nanos > 0) {         timeout++;     }     wait(timeout); }</pre><p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，</p><p>如果在规定时间内没有获得锁就返回。</p><h1 id="九、finalize"><a href="#九、finalize" class="headerlink" title="九、finalize()"></a>九、finalize()</h1><pre> protected void finalize() throws Throwable { }</pre>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。Java允许在类中定义一个名为finalize()的方法。它的工作原理是：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法。并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。<pre>关于垃圾回收，有三点需要记住：　　1、对象可能不被垃圾回收。只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。　　2、垃圾回收并不等于“析构”。　　3、垃圾回收只与内存有关。使用垃圾回收的唯一原因是为了回收程序不再使用的内存。</pre><pre>finalize()的用途：　　无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。　　不过这种情况一般发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式。</pre>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java学习 </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>读书</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>我是耒耒耒耒耒（张未）。欢迎来到我的个人技术博客。目前主要做Java后端开发，同时兼顾一些Vue页面的开发，对领域驱动较为感兴趣。</p>]]></content>
    </entry>
    
  
</search>
