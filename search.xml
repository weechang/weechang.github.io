<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java基础-3——HashTable类</title>
      <link href="/2018/07/31/java%E5%9F%BA%E7%A1%80-3%E2%80%94%E2%80%94HashTable%E7%B1%BB/"/>
      <url>/2018/07/31/java%E5%9F%BA%E7%A1%80-3%E2%80%94%E2%80%94HashTable%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>和HashMap一样，HashTable 也是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashTable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。<br>HashTable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，HashTable中的映射不是有序的。<br><a id="more"></a></p><h2 id="1-1-成员变量"><a href="#1-1-成员变量" class="headerlink" title="1.1 成员变量"></a>1.1 成员变量</h2><pre>    // 是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的"key-value键值对"都是存储在Entry数组中的。     private transient Entry<?,?>[] table;    // 是Hashtable的大小，它是Hashtable保存的键值对的数量。     private transient int count;    // 是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值="容量*加载因子"。    private int threshold;    // 就是加载因子。     private float loadFactor;    // 是用来实现fail-fast机制的    private transient int modCount = 0;</pre><h2 id="1-2-构造函数"><a href="#1-2-构造函数" class="headerlink" title="1.2 构造函数"></a>1.2 构造函数</h2><pre>    // 默认构造函数。    public Hashtable()     // 指定“容量大小”的构造函数    public Hashtable(int initialCapacity)     // 指定“容量大小”和“加载因子”的构造函数    public Hashtable(int initialCapacity, float loadFactor)     // 包含“子Map”的构造函数    public Hashtable(Map<? extends K, ? extends V> t)</pre><h2 id="1-3-常用API"><a href="#1-3-常用API" class="headerlink" title="1.3 常用API"></a>1.3 常用API</h2><pre>    // 将此哈希表清空，使其不包含任何键。     synchronized void                clear()    synchronized Object              clone()    // 测试此映射表中是否存在与指定值关联的键。                  boolean             contains(Object value)    // 测试指定对象是否为此哈希表中的键。     synchronized boolean             containsKey(Object key)    // 如果此 Hashtable 将一个或多个键映射到此值，则返回 true。     synchronized boolean             containsValue(Object value)    synchronized Enumeration<v>      elements()    synchronized Set<entry<k, v="">>    entrySet()    synchronized boolean             equals(Object object)    synchronized V                   get(Object key)    synchronized int                 hashCode()    synchronized boolean             isEmpty()    synchronized Set<k>              keySet()    synchronized Enumeration<k>      keys()    synchronized V                   put(K key, V value)    synchronized void                putAll(Map<? extends K, ? extends V> map)    synchronized V                   remove(Object key)    synchronized int                 size()    synchronized String              toString()    synchronized Collection<v>       values()    // 增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素。     protected  void rehash() </v></k></k></entry<k,></v></pre><h1 id="二、HashTable遍历方式"><a href="#二、HashTable遍历方式" class="headerlink" title="二、HashTable遍历方式"></a>二、HashTable遍历方式</h1><h2 id="2-1-遍历HashTable的键值对"><a href="#2-1-遍历HashTable的键值对" class="headerlink" title="2.1 遍历HashTable的键值对"></a>2.1 遍历HashTable的键值对</h2><p><b>第一步：根据entrySet()获取HashTable的“键值对”的Set集合。</b><br><b>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</b></p><pre>    // 假设table是Hashtable对象    // table中的key是String类型，value是Integer类型    Integer integ = null;    Iterator iter = table.entrySet().iterator();    while(iter.hasNext()) {        Map.Entry entry = (Map.Entry)iter.next();        // 获取key        key = (String)entry.getKey();        // 获取value        integ = (Integer)entry.getValue();    }</pre><h2 id="2-2-通过Iterator遍历HashTable的键"><a href="#2-2-通过Iterator遍历HashTable的键" class="headerlink" title="2.2 通过Iterator遍历HashTable的键"></a>2.2 通过Iterator遍历HashTable的键</h2><p><b>第一步：根据keySet()获取HashTable的“键”的Set集合。</b><br><b>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</b></p><pre>    // 假设table是Hashtable对象    // table中的key是String类型，value是Integer类型    String key = null;    Integer integ = null;    Iterator iter = table.keySet().iterator();    while (iter.hasNext()) {            // 获取key        key = (String)iter.next();            // 根据key，获取value        integ = (Integer)table.get(key);    }</pre><h2 id="2-3-通过Iterator遍历HashTable的值"><a href="#2-3-通过Iterator遍历HashTable的值" class="headerlink" title="2.3 通过Iterator遍历HashTable的值"></a>2.3 通过Iterator遍历HashTable的值</h2><p><b>第一步：根据value()获取HashTable的“值”的集合。</b><br><b>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</b></p><pre>    // 假设table是HashTable对象    // table中的key是String类型，value是Integer类型    Integer value = null;    Collection c = table.values();    Iterator iter= c.iterator();    while (iter.hasNext()) {        value = (Integer)iter.next();    }</pre><h2 id="2-4-通过Enumeration遍历HashTable的键"><a href="#2-4-通过Enumeration遍历HashTable的键" class="headerlink" title="2.4 通过Enumeration遍历HashTable的键"></a>2.4 通过Enumeration遍历HashTable的键</h2><p><b>第一步：根据keys()获取HashTable的集合。</b><br><b>第二步：通过Enumeration遍历“第一步”得到的集合。</b></p><pre>    Enumeration enu = table.keys();    while(enu.hasMoreElements()) {        System.out.println(enu.nextElement());    } </pre>  <h2 id="2-5-通过Enumeration遍历HashTable的值"><a href="#2-5-通过Enumeration遍历HashTable的值" class="headerlink" title="2.5 通过Enumeration遍历HashTable的值"></a>2.5 通过Enumeration遍历HashTable的值</h2><p><b>第一步：根据elements()获取HashTable的集合。</b><br><b>第二步：通过Enumeration遍历“第一步”得到的集合。</b></p><pre>    Enumeration enu = table.elements();    while(enu.hasMoreElements()) {        System.out.println(enu.nextElement());    }</pre><p><b>PS:本文章相关代码均已上传至 GitHub <a href="https://github.com/weechang/java-zero" target="_blank">查看详情</a></b></p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java学习 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> HashTable </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础-2——HashMap类</title>
      <link href="/2018/07/30/java%E5%9F%BA%E7%A1%80-2%E2%80%94%E2%80%94HashMap%E7%B1%BB/"/>
      <url>/2018/07/30/java%E5%9F%BA%E7%A1%80-2%E2%80%94%E2%80%94HashMap%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h1 id="一、原理实现"><a href="#一、原理实现" class="headerlink" title="一、原理实现"></a>一、原理实现</h1><p>hashMap的本质是一个数组，数组中每一个元素称为一个Node，Node中存放的是hash值与链表（或红黑树）的键值对。<br>hashMap的存储过程如下:<br>根据 key 计算出它的哈希值 h。<br>假设Node的个数为 n，那么这个键值对应该放在第 (h % n) 个Node中。<br><a id="more"></a><br>如果该Node中已经有了键值对，就使用<a href="http://www.cnblogs.com/lizhanwu/p/4303410.html" target="_blank">拉链法</a>解决冲突。<br>hashMap还有一个重要的属性: 负载因子(load factor)，它用来衡量hashMap的 空/满 程度，一定程度上也可以体现查询的效率，计算公式为:</p><p>负载因子 = 总键值对数 / Node个数</p><p>负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，hashMap将自动扩容。<br>hashMap在自动扩容时，一般会创建两倍于原来个数的Node，因此即使 key 的hashMap不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。<br>hashMap的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个Node中的链表长度并不发生改变，因此也就不能提高hashMap的查询性能。</p><p>基于以上总结，细心的读者可能会发现hashMap的两个问题:</p><p>如果hashMap中本来Node就比较多，扩容时需要重新哈希并移动数据，性能影响较大。<br>如果哈希函数设计不合理，hashMap在极端情况下会变成线性表，性能极低。<br>于是针对这种问题，java8中采用了红黑树与链表相互转换的方式来解决。当Node中的键值对大于8的时候，链表结构将变为树形结构。该方式能够在一定程度上解决链表的查询效率问题，但是最好的解决方案还是在hash函数的设计上，尽量减少hash冲突。</p><p>根据概率论分析，理想状态下，hashMap中的Node满足泊松分布<br>当负载因子为 0.75 时，上述公式中 λ 约等于 0.5，因此箱子中元素个数和概率的关系如下:</p><table><thead><tr><th>数量</th><th>概率</th></tr></thead><tbody><tr><td>0</td><td>0.60653066</td></tr><tr><td>1</td><td>0.30326533</td></tr><tr><td>2</td><td>0.07581633</td></tr><tr><td>3</td><td>0.01263606</td></tr><tr><td>4</td><td>0.00157952</td></tr><tr><td>5</td><td>0.00015795</td></tr><tr><td>6</td><td>0.00001316</td></tr><tr><td>7</td><td>0.00000094</td></tr><tr><td>8</td><td>0.00000006</td></tr></tbody></table><h1 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h1><h2 id="2-1-成员变量"><a href="#2-1-成员变量" class="headerlink" title="2.1 成员变量"></a>2.1 成员变量</h2><pre>    /**     * 默认初始容量 - 必须是2的幂。     * 个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。     */    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16    /**     *     * 最大容量。     */    static final int MAXIMUM_CAPACITY = 1 << 30;    /**     * 默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。     */    static final float DEFAULT_LOAD_FACTOR = 0.75f;    /**     * 使用树而不是链表的计数阈值。     *如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。     * 这个值表示当某个链表长度大于 8 时，有可能会转化成树。     * 备注：从JDK1.8开始，HashMap容量在大于一定值后，底层将会由链表结构转为树形结构     */    static final int TREEIFY_THRESHOLD = 8;    /**     * 当容量小于该值时，将由树状结构转为链表结构     */    static final int UNTREEIFY_THRESHOLD = 6;    /**     * 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。     * 这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。     */    static final int MIN_TREEIFY_CAPACITY = 64;    // 数组，该数组用于存储不同的hash值与链表的对应关系    transient Node<k,v>[] table;    // 单向链表，该链表用于处理哈希冲突    Set<map.entry<k,v>> entrySet;    // hashMap长度    int size;    // 用来实现fail-fast机制的。     int modCount;     // HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值="容量*加载因子"，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。     int threshold;     // 加载因子     final float loadFactor;</map.entry<k,v></k,v></pre><h1 id="三、常用方法"><a href="#三、常用方法" class="headerlink" title="三、常用方法"></a>三、常用方法</h1><h2 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h2><pre>    /**    * @param initialCapacity 初始大小    * @param loadFactor 扩容因子    */    public HashMap(int initialCapacity, float loadFactor)    /**    *@param initialCapacity 初始大小    */    public HashMap(int initialCapacity)    public HashMap()    /**    *@param m Map子类    */    public HashMap(Map<? extends K, ? extends V> m)</pre><h2 id="3-2-对外方法"><a href="#3-2-对外方法" class="headerlink" title="3.2 对外方法"></a>3.2 对外方法</h2><pre>    /**    * 清空hashMap    * 通过将所有Node置空实现    */    public void clear()    /**    * 是否存在键为key的键值对    */    public boolean containsKey(Object key)    /**    * 是否存在值为value的键值对    */    public boolean containsValue(Object value)    /**    * 获取所有的键值对    */    public Set<map.entry<k,v>> entrySet()    /**    * 获取所有键值对 值的集合    */    public Collection<v> values()    /**    * 获取所有键值对 键的集合    */    public Set<k> keySet()    /**    * 根据键值对的键获取值    */    public V get(Object key)    /**    * put 一个键值对    */    public V put(K key, V value)    /**    *将"m"的全部元素都添加到HashMap中    */    public void putAll(Map<? extends K, ? extends V> m)    /**    *移除键为key的元素    */    public V remove(Object key)</k></v></map.entry<k,v></pre><h1 id="四、HashMap的遍历"><a href="#四、HashMap的遍历" class="headerlink" title="四、HashMap的遍历"></a>四、HashMap的遍历</h1><h2 id="4-1-遍历HashMap的键值对"><a href="#4-1-遍历HashMap的键值对" class="headerlink" title="4.1 遍历HashMap的键值对"></a>4.1 遍历HashMap的键值对</h2><p>第一步：根据entrySet()获取HashMap的“键值对”的Set集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p><pre>    // 假设map是HashMap对象    // map中的key是String类型，value是Integer类型    Integer integ = null;    Iterator iter = map.entrySet().iterator();    while(iter.hasNext()) {        Map.Entry entry = (Map.Entry)iter.next();        // 获取key        key = (String)entry.getKey();        // 获取value        integ = (Integer)entry.getValue();    }</pre><h2 id="4-2-遍历HashMap的键"><a href="#4-2-遍历HashMap的键" class="headerlink" title="4.2 遍历HashMap的键"></a>4.2 遍历HashMap的键</h2><p>第一步：根据keySet()获取HashMap的“键”的Set集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p><pre>    // 假设map是HashMap对象    // map中的key是String类型，value是Integer类型    String key = null;    Integer integ = null;    Iterator iter = map.keySet().iterator();    while (iter.hasNext()) {            // 获取key        key = (String)iter.next();            // 根据key，获取value        integ = (Integer)map.get(key);    }</pre><h2 id="4-3-遍历HashMap的值"><a href="#4-3-遍历HashMap的值" class="headerlink" title="4.3 遍历HashMap的值"></a>4.3 遍历HashMap的值</h2><p>第一步：根据value()获取HashMap的“值”的集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p><pre>    // 假设map是HashMap对象    // map中的key是String类型，value是Integer类型    Integer value = null;    Collection c = map.values();    Iterator iter= c.iterator();    while (iter.hasNext()) {        value = (Integer)iter.next();    }</pre><p><b>PS:本文章相关代码均已上传至 GitHub <a href="https://github.com/weechang/java-zero" target="_blank">查看详情</a></b></p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java学习 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教学，教你把你的个人项目推送到maven中央仓库</title>
      <link href="/2018/07/20/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6%EF%BC%8C%E6%95%99%E4%BD%A0%E6%8A%8A%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/"/>
      <url>/2018/07/20/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6%EF%BC%8C%E6%95%99%E4%BD%A0%E6%8A%8A%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近闲下来了，想要自己造点小轮子用，方便自己在不同项目使用，同时想偷懒，不想每次都在项目里面copy代码。于是想到了重要仓库这个东西，把自己的代码托管到github（虽然现在的github已经不再单纯），然后发布jar包到maven中央仓库，以后每个项目都只用引入maven依赖就可以了。同时还能方便好基友们使用，万一哪一天好基友高兴就献身了呢，想想就有点小激动呢。好了废话不多说，下面正式开始手把手教学活动。<br><a id="more"></a><br><b><a href="https://github.com/weechang/JUtil" target="_blank" rel="noopener">附上小轮子传送门</a>给感兴趣的小伙伴</b><br>将项目发布到maven仓库需要以下几步:<br>1.在sonatype中创建issue<br>2.使用gpg生成秘钥<br>3.配置Maven进行deploy和release</p><h1 id="1-在sonatype中创建issue"><a href="#1-在sonatype中创建issue" class="headerlink" title="1 在sonatype中创建issue"></a>1 在sonatype中创建issue</h1><p>首先我们需要在<a href="https://issues.sonatype.org/secure/Dashboard.jspa" targe="_blank" target="_blank" rel="noopener">https://issues.sonatype.org/secure/Dashboard.jspa</a>中新建一个issues。如果没有sonatype账号的话，分分钟注册一个<br><img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/创建项目.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"><br>创建完成后就是如下图示<br><img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/创建完成.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"><br>这个时候只需要耐心等待工作人员审核就行了，因为我的domain问题，经历了二次审核，但是都很快，一般提交后两个小时内就会有结果。当issues状态变为Resolved就可以继续下一步操作了。</p><h1 id="2-使用gpg生成秘钥"><a href="#2-使用gpg生成秘钥" class="headerlink" title="2 使用gpg生成秘钥"></a>2 使用gpg生成秘钥</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>选择对应的OS版本进行下载安装即可，下载地址传送门：<a href="https://www.gnupg.org/download/index.html" targe="_blank" target="_blank" rel="noopener">https://www.gnupg.org/download/index.html</a></p><h2 id="2-2-生成key"><a href="#2-2-生成key" class="headerlink" title="2.2 生成key"></a>2.2 生成key</h2><p>首先查看安装成功没有 <pre>gpg –version</pre> （MAC 和 Linux系统需要 gpg2 –version）<br>通过 <pre>gpg –gen-key</pre> 生成key，也可以通过UI界面生成和管理key<br><img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/生成key.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"><br>运行后gpg要求你选择加密算法，过期时间等等，这些直接选择默认值即可。通过对比发现，gpg 2.0以上的版本运行gpg –gen-key命令 会跳过这些步骤。<br>之后gpg要求你输入姓名，邮箱以及关键的Passphrase，依次输入即可。然后gpg为你生成了一对秘钥。<br>通过<pre>gpg –list-keys</pre>查看生成的key列表<br><img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/秘钥列表.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"><br>这里可以看到我的公钥是：34754DFE562C10E1A09907B7F4797C9A95E36DB6，记住这个key，下面我们需要用到。</p><h2 id="2-3-上传公钥"><a href="#2-3-上传公钥" class="headerlink" title="2.3 上传公钥"></a>2.3 上传公钥</h2><p>生成秘钥后，我们需要把公钥上传到服务器上。运行以下命令：<pre>gpg2 –keyserver hkp://pool.sks-keyservers.net –send-keys 34754DFE562C10E1A09907B7F4797C9A95E36DB6（刚才生成的公钥）</pre></p><h1 id="3-配置Maven"><a href="#3-配置Maven" class="headerlink" title="3 配置Maven"></a>3 配置Maven</h1><h2 id="3-1-配置maven-setting-xml"><a href="#3-1-配置maven-setting-xml" class="headerlink" title="3.1 配置maven setting.xml"></a>3.1 配置maven setting.xml</h2><p>需要在本地的maven配置server 和 profile 两个地方，啰嗦的话就不多少了，直接上配置：</p><pre>    &lt;server>        &lt;id>ossrh&lt;/id>        &lt;username>第一步注册的用户名&lt;/username>        &lt;password>第一步注册的密码&lt;/password>    &lt;/server></pre><pre>     &lt;profile>         &lt;id>ossrh&lt;/id>         &lt;activation>             &lt;activeByDefault>true&lt;/activeByDefault>         &lt;/activation>         &lt;properties>             &lt;gpg.executable>gpg(MAC 和 Linux用户使用gpg2)&lt;/gpg.executable>             &lt;gpg.passphrash>生成密钥时输入的密码&lt;/gpg.passphrash>         &lt;/properties>    </pre><h2 id="3-2-配置项目的pom-xml"><a href="#3-2-配置项目的pom-xml" class="headerlink" title="3.2 配置项目的pom.xml"></a>3.2 配置项目的pom.xml</h2><p>具体的配置可以查看小轮子里面的pom设置 <a href="https://github.com/weechang/JUtil/blob/master/pom.xml" target="_blank">https://github.com/weechang/JUtil/blob/master/pom.xml</a><br>首先需要添加指向sonatype仓库的&lt;distributionManagement&gt;</p><p><pre><br>    &lt;distributionManagement&gt;<br>        &lt;snapshotRepository&gt;<br>            &lt;id&gt;ossrh&lt;/id&gt;<br>            &lt;url&gt;<a href="https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;" target="_blank" rel="noopener">https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;</a><br>        &lt;/snapshotRepository&gt;<br>        &lt;repository&gt;<br>            &lt;id&gt;ossrh&lt;/id&gt;<br>            &lt;name&gt;Maven Central Staging Repository&lt;/name&gt;<br>            &lt;url&gt;<a href="https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;" target="_blank" rel="noopener">https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;</a><br>        &lt;/repository&gt;<br>    &lt;/distributionManagement&gt;<br></pre><br>继续配置pfofiles,添加各种推送、DOC、加密的插件</p><p><pre><br>    &lt;profiles&gt;<br>        &lt;profile&gt;<br>            &lt;id&gt;release<br>            &lt;build&gt;<br>                &lt;plugins&gt;<br>                    &lt;plugin&gt;<br>                        &lt;groupId&gt;org.sonatype.plugins&lt;/groupId&gt;<br>                        &lt;artifactId&gt;nexus-staging-maven-plugin&lt;/artifactId&gt;<br>                        &lt;version&gt;1.6.8&lt;/version&gt;<br>                        &lt;extensions&gt;true&lt;/extensions&gt;<br>                        &lt;configuration&gt;<br>                            &lt;serverId&gt;ossrh&lt;/serverId&gt;<br>                            &lt;nexusUrl&gt;<a href="https://oss.sonatype.org/&lt;/nexusUrl&gt;" target="_blank" rel="noopener">https://oss.sonatype.org/&lt;/nexusUrl&gt;</a><br>                            &lt;autoReleaseAfterClose&gt;true&lt;/autoReleaseAfterClose&gt;<br>                        &lt;/configuration&gt;<br>                    &lt;/plugin&gt;<br>                    &lt;plugin&gt;<br>                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                        &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;<br>                        &lt;version&gt;3.0.1&lt;/version&gt;<br>                        &lt;executions&gt;<br>                            &lt;execution&gt;<br>                                &lt;id&gt;attach-javadocs&lt;/id&gt;<br>                                &lt;goals&gt;<br>                                    &lt;goal&gt;jar&lt;/goal&gt;<br>                                &lt;/goals&gt;<br>                            &lt;/execution&gt;<br>                        &lt;/executions&gt;<br>                    &lt;/plugin&gt;<br>                    &lt;plugin&gt;<br>                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                        &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;<br>                        &lt;executions&gt;<br>                            &lt;execution&gt;<br>                                &lt;id&gt;attach-sources&lt;/id&gt;<br>                                &lt;goals&gt;<br>                                    &lt;goal&gt;jar-no-fork<br>                                &lt;/goals&gt;<br>                            &lt;/execution&gt;<br>                        &lt;/executions&gt;<br>                    &lt;/plugin&gt;<br>                    &lt;plugin&gt;<br>                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                        &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;<br>                        &lt;version&gt;1.6&lt;/version&gt;<br>                        &lt;executions&gt;<br>                            &lt;execution&gt;<br>                                &lt;id&gt;sign-artifacts&lt;/id&gt;<br>                                &lt;phase&gt;verify&lt;/phase&gt;<br>                                &lt;goals&gt;<br>                                    &lt;goal&gt;sign&lt;/goal&gt;<br>                                &lt;/goals&gt;<br>                            &lt;/execution&gt;<br>                        &lt;/executions&gt;<br>                    &lt;/plugin&gt;<br>                &lt;/plugins&gt;<br>            &lt;/build&gt;<br>        &lt;/profile&gt;<br>    &lt;/profiles&gt;<br></pre><br>然后还可以添加一些开发者信息和license信息，具体的就不多说了。具体可以参考小轮子的配置</p><h2 id="3-3-部署到中央仓库"><a href="#3-3-部署到中央仓库" class="headerlink" title="3.3 部署到中央仓库"></a>3.3 部署到中央仓库</h2><p>运行以下代码进行deploy</p><p><pre>mvn clean deploy -P release</pre><br>如下图表示成功部署到中央仓库<br><img src="/2018/07/20/手把手教学，教你把你的个人项目推送到maven中央仓库/部署成功.png" title="手把手教学，教你把你的个人项目推送到maven中央仓库"><br>因为我们在pom中添加了自动发布插件，所以可以不用管理，直接到中央仓库去查看就能看到你发布的项目了<br><b>PS:在部署过成功可能会遇到401的问题，具体请参考传送门 <a href="https://stackoverflow.com/questions/24830610/why-am-i-getting-a-401-unauthorized-error-in-maven" target="_blank">https://stackoverflow.com/questions/24830610/why-am-i-getting-a-401-unauthorized-error-in-maven</a></b></p>]]></content>
      
      <categories>
          
          <category> 开源之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手把手教学 </tag>
            
            <tag> maven中央仓库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础-1——String类</title>
      <link href="/2018/06/08/java%E5%9F%BA%E7%A1%80-1%E2%80%94%E2%80%94String%E7%B1%BB/"/>
      <url>/2018/06/08/java%E5%9F%BA%E7%A1%80-1%E2%80%94%E2%80%94String%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-1-成员变量"><a href="#1-1-成员变量" class="headerlink" title="1.1 成员变量"></a>1.1 成员变量</h2><pre>    public final class String implements java.io.Serializable, Comparable<string>, CharSequence {        private final char value[];        private int hash; // Default to 0        private static final long serialVersionUID = -6849794470754667710L;        private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];    }</string></pre><p>从源码可以看出，<b>String底层是通过一个不可变的字符串常量来进行维护的。所以只要一个字符改变就会生成一个新的String类型对象。</b><br><a id="more"></a></p><h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><pre>    String()    String(String original)    String(char value[])    String(char value[], int offset, int count)    String(int[] codePoints, int offset, int count)    String(byte bytes[], int offset, int length, String charsetName)    String(byte bytes[], int offset, int length, Charset charset)    String(byte bytes[], String charsetName)    String(byte bytes[], Charset charset)    String(byte bytes[], int offset, int length)    String(byte bytes[])    String(StringBuffer buffer)    String(StringBuilder builder)    String(char[] value, boolean share)</pre><h1 id="二、创建方式的区别"><a href="#二、创建方式的区别" class="headerlink" title="二、创建方式的区别"></a>二、创建方式的区别</h1><h2 id="2-1-直接赋值方式"><a href="#2-1-直接赋值方式" class="headerlink" title="2.1 直接赋值方式"></a>2.1 直接赋值方式</h2><p>String str = “str”; //<b>直接赋值方式创建对象是在方法区的常量池</b></p><h2 id="2-2-构造方法创建"><a href="#2-2-构造方法创建" class="headerlink" title="2.2 构造方法创建"></a>2.2 构造方法创建</h2><p>String str = “str”;//<b>通过构造方法创建字符串对象是在堆内存</b></p><pre>    public class JavaString {        /**         * 创建方式的比较         */        public void createMethod() {            String str1 = "str";            String str2 = new String("str");            String str3 = str1;            String str4 = str2;            System.out.println(str1 == str2); // false            System.out.println(str1 == str3); // true            System.out.println(str2 == str4); // true            System.out.println(str1 == str4); // false        }        public static void main(String[] args) {            JavaString javaString = new JavaString();            javaString.createMethod();        }    }</pre><h2 id="2-3-内存分析"><a href="#2-3-内存分析" class="headerlink" title="2.3 内存分析"></a>2.3 内存分析</h2><img src="/2018/06/08/java基础-1——String类/memory.png" title="内存示意"><p><b>在字符串中，如果采用直接赋值的方式（String str=”str”）进行对象的实例化，则会将匿名对象“str”放入字符串常量池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象。</b><br>这样，所有直接赋值的String对象，如果利用相同的“str”，则String对象==返回true；<br>PS：字符串还可以采用手工入池的方式</p><pre>    /**     * 字符串手工入池     */    public void intern(){        String str1 = new String("str").intern();        String str2 = "str";        System.out.println(str1 == str2); // true    }</pre><h2 id="2-4-区别"><a href="#2-4-区别" class="headerlink" title="2.4 区别"></a>2.4 区别</h2><p>1）直接赋值（String str = “str”）：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。<br>2）构造方法（String str=  new String(“str”);）:会开辟两块堆内存空间（具体原因阐述见此处），其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public  String intern();方法进行手工入池。<br><b>PS:String类对象一旦声明则不可以改变；而改变的只是地址，原来的字符串还是存在的，并且产生垃圾。</b></p><h1 id="三、字符串常量池"><a href="#三、字符串常量池" class="headerlink" title="三、字符串常量池"></a>三、字符串常量池</h1><h2 id="3-1-字符串常量池概述"><a href="#3-1-字符串常量池概述" class="headerlink" title="3.1 字符串常量池概述"></a>3.1 字符串常量池概述</h2><p>1）常量池表（Constant_Pool table）</p><p>Class文件中存储所有常量（包括字符串）的table。<br>这是Class文件中的内容，还不是运行时的内容，不要理解它是个池子，其实就是Class文件中的字节码指令。</p><p>2）运行时常量池（Runtime Constant Pool）　</p><p>JVM内存中方法区的一部分，这是运行时的内容<br>这部分内容（绝大部分）是随着JVM运行时候，从常量池转化而来，每个Class对应一个运行时常量池<br>上一句中说绝大部分是因为：除了 Class中常量池内容，还可能包括动态生成并加入这里的内容</p><p>3）字符串常量池（String Pool）</p><p>这部分也在方法区中，但与Runtime Constant Pool不是一个概念，String Pool是JVM实例全局共享的，全局只有一个<br>JVM规范要求进入这里的String实例叫“被驻留的interned string”，各个JVM可以有不同的实现，HotSpot是设置了一个哈希表StringTable来引用堆中的字符串实例，被引用就是被驻留。</p><h2 id="3-2-亨元模式"><a href="#3-2-亨元模式" class="headerlink" title="3.2 亨元模式"></a>3.2 亨元模式</h2><p>其实字符串常量池这个问题涉及到一个设计模式，叫“享元模式”，顾名思义 - - - &gt; 共享元素模式<br>也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素<br>Java中String部分就是根据享元模式设计的，而那个存储元素的地方就叫做“字符串常量池 - String Pool”</p><h2 id="3-3-详细分析"><a href="#3-3-详细分析" class="headerlink" title="3.3 详细分析"></a>3.3 详细分析</h2><p>举例：</p><pre>    int x  = 10;    String y = "hello";</pre><p>1)首先，10和”hello”会在经过javac（或者其他编译器）编译过后变为Class文件中constant_pool table的内容<br>2)当我们的程序运行时，也就是说JVM运行时，每个Classconstant_pool table中的内容会被加载到JVM内存中的方法区中各自Class的Runtime Constant Pool。<br>3)一个没有被String Pool包含的Runtime Constant Pool中的字符串（这里是”hello”）会被加入到String Pool中（HosSpot使用hashtable引用方式），步骤如下：　　　<br>    一是：在Java Heap中根据”hello”字面量create一个字符串对象<br>    二是：将字面量”hello”与字符串对象的引用在hashtable中关联起来，键 - 值 形式是：”hello” = 对象的引用地址。<br>另外来说，当一个新的字符串出现在Runtime Constant Pool中时怎么判断需不需要在Java Heap中创建新对象呢？<br>策略是这样：会先去根据equals来比较Runtime Constant Pool中的这个字符串是否和String Pool中某一个是相等的（也就是找是否已经存在），如果有那么就不创建，直接使用其引用；反之，如上3。如此，就实现了享元模式，提高的内存利用效率。<br>举例：<br>使用String s = new String(“hello”); 会创建2个对象。<br>首先，出现了字面量”hello”，那么去String Pool中查找是否有相同字符串存在，因为程序就这一行代码所以肯定没有，那么就在Java Heap中用字面量”hello”首先创建1个String对象。<br>接着，new String(“hello”)，关键字new又在Java Heap中创建了1个对象，然后调用接收String参数的构造器进行了初始化。最终s的引用是这个String对象。</p><h1 id="四、常用方法"><a href="#四、常用方法" class="headerlink" title="四、常用方法"></a>四、常用方法</h1><h2 id="4-1-基本操作"><a href="#4-1-基本操作" class="headerlink" title="4.1 基本操作"></a>4.1 基本操作</h2><pre>    // 获取字符串的长度    int length()    // 返回指定字符在该字符串中第一次出现的位置，若无则返回-1    int indexOf(int ch)    // 返回指定字符在该字符串中最后一次出现的位置，若无则返回-1    int lastIndexOf(int ch)    // 返回指定位置的字符，其中index取值范围为（0~字符长度-1）    char charAt(int index)</pre><h2 id="4-2-转换操作"><a href="#4-2-转换操作" class="headerlink" title="4.2 转换操作"></a>4.2 转换操作</h2><pre>    // 转换为字符数组    char[] toCharArray()    // 将传入值转换为String （常见入参为Integer、Long、Double等）    String valueOf(xxx)    // 转换为小写    String toLowerCase()    // 转换为大写    String toUpperCase()</pre><h2 id="4-3-替换操作"><a href="#4-3-替换操作" class="headerlink" title="4.3 替换操作"></a>4.3 替换操作</h2><pre>    // 使用 replacement替换原字符串中所有的target    String replace(CharSequence target, CharSequence replacement)    // 替换字符串中的所有空格    String trim()</pre><h2 id="4-4-截取操作"><a href="#4-4-截取操作" class="headerlink" title="4.4 截取操作"></a>4.4 截取操作</h2><pre>    // 根据 regex 将原字符串拆分为 数组    String[] split(String regex)    // 截取 beginIndex 到 endIndex之间的字符串    String substring(int beginIndex, int endIndex)</pre><h2 id="4-5判断操作"><a href="#4-5判断操作" class="headerlink" title="4.5判断操作"></a>4.5判断操作</h2><pre>    // 判断值是否相等    boolean equals(Object anObject)    // 忽略大小写的判断    boolean equalsIgnoreCase(String anotherString)    // 是否以prefix 开头    startsWith(String prefix)    // 是否以prefix 结尾    endsWith(String prefix)    // 是否包含 s    boolean contains(CharSequence s)    // 是否是空字符串    boolean isEmpty()</pre><p>#五、String、StringBuffer、StringBuilder</p><h2 id="5-1-异同点"><a href="#5-1-异同点" class="headerlink" title="5.1 异同点"></a>5.1 异同点</h2><p>同：三者底层都是通过字符数组来进行维护的。</p><p>异：</p><table><thead><tr><th></th><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>是否可变</td><td>×</td><td>√</td><td>√</td></tr><tr><td>线程安全</td><td>√</td><td>√</td><td>×</td></tr></tbody></table><h2 id="5-2-效率比较"><a href="#5-2-效率比较" class="headerlink" title="5.2 效率比较"></a>5.2 效率比较</h2><p><b>通常情况下：StringBuilder &gt; StringBuffer &gt; String</b></p><p><b>PS:本文章相关代码均已上传至 GitHub <a href="https://github.com/weechang/java-zero" target="_blank">查看详情</a></b></p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java学习 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础-0——Object类</title>
      <link href="/2018/06/07/java%E5%9F%BA%E7%A1%80-0%E2%80%94%E2%80%94Object%E7%B1%BB/"/>
      <url>/2018/06/07/java%E5%9F%BA%E7%A1%80-0%E2%80%94%E2%80%94Object%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>从这篇文章起就正式开始Java学习之旅了。java中，万物皆对象，所以第一篇先学习Java的Object类，循序渐进。<br><a id="more"></a></p><h1 id="一、getClass"><a href="#一、getClass" class="headerlink" title="一、getClass()"></a>一、getClass()</h1><pre>public final native Class<?> getClass();</pre><p>返回此Object的运行时类类型。如： class io.github.weechang.java.base.JavaObject。<br>不可重写，要调用的话，一般和getName()联合使用，如getClass().getName(); // io.github.weechang.java.base.JavaObject</p><h1 id="二、hashCode"><a href="#二、hashCode" class="headerlink" title="二、hashCode()"></a>二、hashCode()</h1><pre>public native int hashCode();</pre><p>返回该对象的哈希值。如：123961122<br>该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。如HashSet、HashMap。<br>如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。</p><h1 id="三、equals"><a href="#三、equals" class="headerlink" title="三、equals()"></a>三、equals()</h1><pre>public boolean equals(Object obj) {    return (this == obj);}</pre><p>Object中的equals方法是直接判断this和obj是否是同一对象，所谓同一对象就是指内存中同一块存储单元，如果this和obj指向的是同一块内存对象，则返回true,如果this和obj指向的不是同一块内存，则返回false。</p><pre>注意：即便是内容完全相等的两块不同的内存对象，也返回false。     如果是同一块内存，则object中的equals方法返回true,如果是不同的内存，则返回false     如果希望不同内存但相同内容的两个对象equals时返回true,则我们需要重写父类的equal方法     Java中一部分类已经重写了object中的equals方法（这样就是比较内容是否相等了），如基本的包装类型 Integer、Long、Boolean等，还有String。</pre><h1 id="四、clone"><a href="#四、clone" class="headerlink" title="四、clone()"></a>四、clone()</h1><pre>protected native Object clone() throws CloneNotSupportedException;</pre><p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。<br>Java里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法（实现深复制）。</p><h2 id="4-1-clone与copy的区别"><a href="#4-1-clone与copy的区别" class="headerlink" title="4.1 clone与copy的区别"></a>4.1 clone与copy的区别</h2><p>在通常操作中，我们常采用的赋值方式为 User u1 = new User(); User u2 = u1;此时，User u2 = u1这种赋值方式就称为copy。此时的赋值只是简单地将u1所指向的内存地址赋值给了u2,所以此时u1、u2引用的是同一块内存空间。所以对u1或者u2任意对象的操作如u1.setId(2);都会带来另一对象的值的改变，此时可以发现u2.getId() 返回值也为2。若我们不希望带来这样的改变，就需要用到clone.User u2 = u1.clone();等价于User u2 = new User(); u2.setId(u1.getId());</p><p><b>copy：只是简单地将内存地址进行引用，实则两者是同一对象,任一对象值的改变，会带来另一对象值的改变。</b><br><b>clone: 两者是不同内存地址的对象，两者值只有在初始clone时一致，一个对象值的改变，不会带来另一对象值的改变。</b></p><h2 id="4-2-Shallow-Clone与Deep-Clone"><a href="#4-2-Shallow-Clone与Deep-Clone" class="headerlink" title="4.2 Shallow Clone与Deep Clone"></a>4.2 Shallow Clone与Deep Clone</h2><p>Object在对某个对象实施仅仅是简单地执行域对域的copy，这就是Shallow Clone。若User中存在一属性为 Date birthDay，此时u1与U2的引诱关系图如下：<br><img src="/2018/06/07/java基础-0——Object类/clone.png" title="Shallow Clone"><br>此时，除了基本数据类型是值的clone外，非基本数据类型都只是引用的clone。所以此时clone对象与原对象存在一部分相同的引用。此时任一对象的非基本类型的值改变，会导致另一对象的值的改变。若要解决此问题就需要Deep Clone。<br>针对User 对象可以对clone方法进行改造，如下：</p><pre>@Overrideprotected Object clone() throws CloneNotSupportedException {    User cloned = (User) super.clone();    cloned.birthDay = (Date) birthDay.clone();    return cloned;}</pre><h1 id="五、toString"><a href="#五、toString" class="headerlink" title="五、toString()"></a>五、toString()</h1><pre>public String toString() {    return getClass().getName() + "@" + Integer.toHexString(hashCode());}</pre><p>返回值为 字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。如 ：io.github.weechang.java.base.obj.User@762efe5d</p><h1 id="六、notify"><a href="#六、notify" class="headerlink" title="六、notify()"></a>六、notify()</h1><pre>public final native void notify();</pre><p>该方法唤醒在该对象上等待的某个线程</p><h1 id="七、notifyAll"><a href="#七、notifyAll" class="headerlink" title="七、notifyAll()"></a>七、notifyAll()</h1><pre>public final native void notifyAll();</pre><p>该方法唤醒在该对象上等待的所有线程。</p><h1 id="八、wait"><a href="#八、wait" class="headerlink" title="八、wait()"></a>八、wait()</h1><pre>public final void wait() throws InterruptedException {    wait(0);}</pre><pre>public final native void wait(long timeout) throws InterruptedException;</pre><pre>/***@param timeout  等待该线程终止的时间最长为timeout毫秒。 *@param nanos 等待时间为 timeout毫秒+nanos纳秒*/public final void wait(long timeout, int nanos) throws InterruptedException {      if (timeout < 0) {          throw new IllegalArgumentException("timeout value is negative");      }      if (nanos < 0 || nanos > 999999) {          throw new IllegalArgumentException("nanosecond timeout value out of range");      }     if (nanos > 0) {         timeout++;     }     wait(timeout); }</pre><p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，</p><p>如果在规定时间内没有获得锁就返回。</p><h1 id="九、finalize"><a href="#九、finalize" class="headerlink" title="九、finalize()"></a>九、finalize()</h1><pre> protected void finalize() throws Throwable { }</pre>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。Java允许在类中定义一个名为finalize()的方法。它的工作原理是：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法。并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。<pre>关于垃圾回收，有三点需要记住：　　1、对象可能不被垃圾回收。只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。　　2、垃圾回收并不等于“析构”。　　3、垃圾回收只与内存有关。使用垃圾回收的唯一原因是为了回收程序不再使用的内存。</pre><pre>finalize()的用途：　　无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。　　不过这种情况一般发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式。</pre><p><b>PS:本文章相关代码均已上传至 GitHub <a href="https://github.com/weechang/java-zero" target="_blank">查看详情</a></b></p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java学习 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>我是耒耒耒耒耒（张未）。欢迎来到我的个人技术博客。目前主要做Java后端开发，同时兼顾一些Vue页面的开发，对领域驱动较为感兴趣。</p>]]></content>
    </entry>
    
    <entry>
      <title>读书</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
