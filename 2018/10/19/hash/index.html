<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><title>哈希算法究竟是个什么鬼 | 耒耒耒耒耒</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="一直以来写博客都是抱着给别人看的心态写的，其实，别人看了又怎样，重要的是自己写的过程。这几天终于想明白了这个道理，但是博客该有的套路还是得一个不少的加上。最近感觉写Java方面的知识有些厌倦了，于是干脆写点自己想写的。"><meta name="keywords" content="哈希算法,算法"><meta property="og:type" content="article"><meta property="og:title" content="哈希算法究竟是个什么鬼"><meta property="og:url" content="https://blog.weechang.xyz/2018/10/19/hash/index.html"><meta property="og:site_name" content="耒耒耒耒耒"><meta property="og:description" content="一直以来写博客都是抱着给别人看的心态写的，其实，别人看了又怎样，重要的是自己写的过程。这几天终于想明白了这个道理，但是博客该有的套路还是得一个不少的加上。最近感觉写Java方面的知识有些厌倦了，于是干脆写点自己想写的。"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2018-10-19T10:10:07.452Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="哈希算法究竟是个什么鬼"><meta name="twitter:description" content="一直以来写博客都是抱着给别人看的心态写的，其实，别人看了又怎样，重要的是自己写的过程。这几天终于想明白了这个道理，但是博客该有的套路还是得一个不少的加上。最近感觉写Java方面的知识有些厌倦了，于是干脆写点自己想写的。"><link rel="alternate" href="/atom.xml" title="耒耒耒耒耒" type="application/atom+xml"><link rel="stylesheet" href="/libs/font-awesome5/css/fontawesome.min.css"><link rel="stylesheet" href="/libs/font-awesome5/css/fa-brands.min.css"><link rel="stylesheet" href="/libs/font-awesome5/css/fa-solid.min.css"><link rel="stylesheet" href="/libs/open-sans/styles.css"><link rel="stylesheet" href="/libs/source-code-pro/styles.css"><link rel="stylesheet" href="/libs/google-code-prettify/prettify-tomorrow-night-eighties.css"><link rel="stylesheet" href="/css/style.css"><script src="/libs/jquery/2.1.3/jquery.min.js"></script><link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css"><link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css"><script>var _mtac={};!function(){var t=document.createElement("script");t.src="https://pingjs.qq.com/h5/stats.js?v2.0.4",t.setAttribute("name","MTAH5"),t.setAttribute("sid","500628840");var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></head></html><body><div id="container"><header id="header"><div id="header-main" class="header-inner"><div class="outer"><a href="/" id="logo"><i class="logo"></i> <span class="site-title">耒耒耒耒耒</span></a><nav id="main-nav"><a class="main-nav-link" href="/.">主页</a> <a class="main-nav-link" href="/archives">归档</a> <a class="main-nav-link" href="/tools">工具库</a> <a class="main-nav-link" href="/about">关于</a></nav><nav id="sub-nav"><div class="profile" id="profile-nav"><a id="profile-anchor" href="javascript:;"><img class="avatar" alt="avatar" src="/css/images/avatar.png"> <i class="fas fa-caret-down"></i></a></div></nav><div id="search-form-wrap"><div class="search-form"><input id="bdcsMain" name="wd" type="text" class="search-form-input" placeholder="搜索" onkeyup="searchKey()"> <button type="submit" class="search-form-submit" onclick="search()"></button></div><script>function search(){var e="http://zhannei.baidu.com/cse/search?s=2965823544571484326&entry=1&q="+$("#bdcsMain").val();window.open(e)}function searchKey(){13==event.keyCode&&search()}</script><script type="text/javascript">!function(){document.write(unescape('%3Cdiv id="bdcs"%3E%3C/div%3E'));var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//znsv.baidu.com/customer_search/api/js?sid=2965823544571484326&plate_url="+encodeURIComponent(window.location.href)+"&t="+Math.ceil(new Date/36e5);var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></div></div></div><div id="main-nav-mobile" class="header-sub header-inner"><table class="menu outer"><tr><td><a class="main-nav-link" href="/.">主页</a></td><td><a class="main-nav-link" href="/archives">归档</a></td><td><a class="main-nav-link" href="/tools">工具库</a></td><td><a class="main-nav-link" href="/about">关于</a></td><td><div class="search-form"><input id="bdcsMain" name="wd" type="text" class="search-form-input" placeholder="搜索" onkeyup="searchKey()"> <button type="submit" class="search-form-submit" onclick="search()"></button></div><script>function search(){var e="http://zhannei.baidu.com/cse/search?s=2965823544571484326&entry=1&q="+$("#bdcsMain").val();window.open(e)}function searchKey(){13==event.keyCode&&search()}</script><script type="text/javascript">!function(){document.write(unescape('%3Cdiv id="bdcs"%3E%3C/div%3E'));var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//znsv.baidu.com/customer_search/api/js?sid=2965823544571484326&plate_url="+encodeURIComponent(window.location.href)+"&t="+Math.ceil(new Date/36e5);var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></td></tr></table></div></header><div class="outer"><aside id="profile" class="profile-fixed"><div class="inner profile-inner"><div class="base-info profile-block"><img id="avatar" alt="avatar" src="/css/images/avatar.png"><h2 id="name">张未</h2><h3 id="title">大道五十,天衍四九,人遁其一</h3><span id="location"><i class="fas fa-map-marker-alt" style="padding-right:5px"></i>成都,中国</span> <a id="follow" target="_blank" href="https://github.com/weechang/" rel="external nofollow noopener noreferrer">关注我</a></div><div class="article-info profile-block"><div class="article-info-block">47 <span>文章</span></div><div class="article-info-block">31 <span>标签</span></div></div><div class="profile-block social-links"><table><tr><td><a href="https://github.com/weechang/" target="_blank" title="github" class="tooltip" rel="external nofollow noopener noreferrer"><i class="fab fa-github"></i></a></td><td><a href="mailto:zhangwei_sc@foxmail.com" target="_blank" title="envelope" class="tooltip" rel="external nofollow noopener noreferrer"><i class="fa fa-envelope"></i></a></td><td><a href="/css/images/avatar.png" target="_blank" title="weixin" class="tooltip"><i class="fab fa-weixin"></i></a></td><td><a href="/atom.xml" target="_blank" title="rss" class="tooltip"><i class="fa fa-rss"></i></a></td></tr></table></div></div></aside><section id="main"><article id="post-hash" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">哈希算法究竟是个什么鬼</h1><div class="article-meta"><div class="article-date"><i class="fas fa-calendar-alt"></i> <a href="/2018/10/19/hash/"><time datetime="2018-10-19T05:28:01.000Z" itemprop="datePublished">2018-10-19</time></a></div><div class="article-user"><i class="fas fa-user-alt"></i> <span>张未</span></div><div class="article-category"><i class="fas fa-folder"></i> <a class="article-category-link" href="/categories/算法与数据结构/">算法与数据结构</a></div></div><div class="article-meta"><div class="article-word-count"><span><i class="fas fa-file-word"></i> 共3,552字， </span><span><i class="fas fa-clock"></i> 大约需要14分钟</span></div><span id="busuanzi_container_page_pv"><i class="fas fa-eye"></i> 已被阅读<span id="busuanzi_value_page_pv"></span>次</span></div></header><div class="article-entry" itemprop="articleBody"><blockquote><p>一直以来写博客都是抱着给别人看的心态写的，其实，别人看了又怎样，重要的是自己写的过程。这几天终于想明白了这个道理，但是博客该有的套路还是得一个不少的加上。最近感觉写Java方面的知识有些厌倦了，于是干脆写点自己想写的。</p></blockquote><a id="more"></a><p>曾经面试被问到过哈希算法，而曾经的我什么都不懂，就在那儿乱扯一通，现在看来那个时候的自己真的好笑。于是准备补上这个坑，搜集汇总哈希算法的相关只是于此。</p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>我们如何比较两个文件是否一致呢？</p><p>将文件读成二进制流，然后比较两个文件的二进制流？如果二进制流一开始就不一样还好说，或者是文件小都好说。但是如果是大文件呢？如果文件最后几位二进制不一样，这怎么办？耗时太久。</p><p>这个时候我们就需要一个高效而可靠办法，给每个文件一个唯一的ID，然后直接比较两个ID，这貌似是一个不错的方法。嗯，想一想很不错。但是如何确定两个文件的ID不同呢？这时候就可以用到HASH方法了。</p><h1 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h1><p><strong>散列算法（Hash Algorithm）</strong>，又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。</p><h1 id="三、应用"><a href="#三、应用" class="headerlink" title="三、应用"></a>三、应用</h1><p>哈希算法，目前在信息安全领域主要用到以下几个方面：</p><ul><li>文件校验</li></ul><p>我们常见的很多文件下载的时候，除了能够下载具体的文件外，还有很多会给出文件的MD5码。这就是用于文件校验使用的。因为在传统的加密渠道中，我们只能对文件传输过程中的信道进行容错处理，但是不能对抗恶意的文件篡改问题。所以如果有了MD5码，我们就能够通过MD5码，校验我们收到的问题件是否是未经篡改的文件。</p><ul><li>数字签名</li></ul><p>Hash 算法也是现代password体系中的一个重要组成部分。因为非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。 对 Hash 值，又称”数字摘要”进行数字签名，在统计上能够觉得与对文件本身进行数字签名是等效的。</p><ul><li>鉴权协议</li></ul><p>当数据在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。</p><h1 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h1><p>Hash算法最主要的目的就是为了将一个大范围映射到一个小范围。将大范围映射到小范围是为了节省空间。另外，还要使Hash值足够唯一，这样ID才具有唯一性。除此之外，Hash算法还得具有单向性。</p><p>具体说来，Hash算法应该具有以下几个限制点：</p><ul><li>Hash的主要原理就是把大范围映射到小范围；所以，你输入的实际值的个数必须和小范围相当或者比它更小。不然冲突就会非常多。</li><li>Hash逼近单向函数；所以，你能够用它来对数据进行加密。</li><li>不同的应用对Hash函数有着不同的要求；比方，用于加密的Hash函数主要考虑它和单项函数的差距，而用于查找的Hash函数主要考虑它映射到小范围的冲突率。</li></ul><p>明白了这几点，我们就能够对Hash函数的实现做一些了解了。总的说来，目前主流的Hash算法有以下几种实现方法：</p><h2 id="1-加法Hash"><a href="#1-加法Hash" class="headerlink" title="1. 加法Hash"></a>1. 加法Hash</h2><p>所谓的加法Hash就是把输入元素一个一个的加起来构成最后的结果。标准的加法Hash的构造例如以下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int additiveHash(String key, int prime)&#123;</span><br><span class="line">    int hash, i;</span><br><span class="line">    for (hash = key.length(), i = 0; i &lt; key.length(); i++)</span><br><span class="line">    hash += key.charAt(i);</span><br><span class="line">    return (hash % prime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的prime是随意的质数，看得出，结果的值域为[0,prime-1]。</p><h2 id="2-位运算Hash"><a href="#2-位运算Hash" class="headerlink" title="2. 位运算Hash"></a>2. 位运算Hash</h2><p>这类型Hash函数通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素。比方，标准的旋转Hash的构造例如以下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int rotatingHash(String key, int prime) &#123;</span><br><span class="line">    int hash, i;</span><br><span class="line">    for (hash=key.length(), i=0; i&lt;key.length(); ++i)</span><br><span class="line">        hash = (hash&lt;&lt;4)^(hash&gt;&gt;28)^key.charAt(i);</span><br><span class="line">    return (hash % prime);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>先移位，然后再进行各种位运算是这样的类型Hash函数的主要特点。比方，以上的那段计算hash的代码还能够有例如以下几种变形：</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = (hash&lt;&lt;5)^(hash&gt;&gt;27)^key.charAt(i);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash += key.charAt(i);</span><br><span class="line">hash += (hash &lt;&lt; 10);</span><br><span class="line">hash ^= (hash &gt;&gt; 6);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if((i&amp;1) == 0)&#123;</span><br><span class="line">    hash ^= (hash&lt;&lt;7) ^ key.charAt(i) ^ (hash&gt;&gt;3);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    hash ^= ~((hash&lt;&lt;11) ^ key.charAt(i) ^ (hash &gt;&gt;5));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash += (hash&lt;&lt;5) + key.charAt(i);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = key.charAt(i) + (hash&lt;&lt;6) + (hash&gt;&gt;16) – hash;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash ^= ((hash&lt;&lt;5) + key.charAt(i) + (hash&gt;&gt;2));</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-乘法Hash"><a href="#3-乘法Hash" class="headerlink" title="3. 乘法Hash"></a>3. 乘法Hash</h2><p>这种类型的Hash函数利用了乘法的不相关性（乘法的这种性质，最有名的莫过于平方取头尾的随机数生成算法，虽然这种算法效果并不好）。比如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int bernstein(String key) &#123;</span><br><span class="line">    int hash = 0;</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0; i&lt;key.length(); ++i) </span><br><span class="line">        hash = 33*hash + key.charAt(i);</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk5.0里面的String类的hashCode()方法也使用乘法Hash。不过，它使用的乘数是31。推荐的乘数还有：131, 1313, 13131, 131313等等。</p><p>使用这种方式的著名Hash函数还有：</p><ul><li>32位FNV算法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int M_SHIFT = 0;</span><br><span class="line">public int FNVHash(byte[] data) &#123;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(byte b : data)</span><br><span class="line">        hash = (hash * 16777619) ^ b;</span><br><span class="line">    if (M_SHIFT == 0)</span><br><span class="line">        return hash;</span><br><span class="line">    return (hash ^ (hash &gt;&gt; M_SHIFT)) &amp; M_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以及改进的FNV算法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static int FNVHash1(String data) &#123;</span><br><span class="line">    final int p = 16777619;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(int i=0;i&lt;data.length();i++)</span><br><span class="line">        hash = (hash ^ data.charAt(i)) * p;</span><br><span class="line">    hash += hash &lt;&lt; 13;</span><br><span class="line">    hash ^= hash &gt;&gt; 7;</span><br><span class="line">    hash += hash &lt;&lt; 3;</span><br><span class="line">    hash ^= hash &gt;&gt; 17;</span><br><span class="line">    hash += hash &lt;&lt; 5;</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了乘以一个固定的数，常见的还有乘以一个不断改变的数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static int RSHash(String str)&#123;</span><br><span class="line">    int b = 378551;</span><br><span class="line">    int a = 63689;</span><br><span class="line">    int hash = 0;</span><br><span class="line">    for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">        hash = hash * a + str.charAt(i);</span><br><span class="line">        a = a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然Adler32算法的应用没有CRC32广泛，不过，它可能是乘法Hash里面最有名的一个了。关于它的介绍，大家可以去看RFC 1950规范。</p><h2 id="4-除法Hash"><a href="#4-除法Hash" class="headerlink" title="4. 除法Hash"></a>4. 除法Hash</h2><p>除法和乘法一样，同样具有表面上看起来的不相关性。不过，因为除法太慢，这种方式几乎找不到真正的应用。需要注意的是，我们在前面看到的hash的 结果除以一个prime的目的只是为了保证结果的范围。如果你不需要它限制一个范围的话，可以使用如下的代码替代”hash%prime”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = hash ^ (hash&gt;&gt;10) ^ (hash&gt;&gt;20)</span><br></pre></td></tr></table></figure><h2 id="5-查表Hash"><a href="#5-查表Hash" class="headerlink" title="5. 查表Hash"></a>5. 查表Hash</h2><p>查表Hash最有名的样例莫过于CRC系列算法。尽管CRC系列算法本身并非查表，可是，查表是它的一种最快的实现方式。以下是CRC32的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static int crctab[256] = &#123;</span><br><span class="line">0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, </span><br><span class="line">0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, </span><br><span class="line">0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, </span><br><span class="line">0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, </span><br><span class="line">0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, </span><br><span class="line">0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, </span><br><span class="line">0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, </span><br><span class="line">0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, </span><br><span class="line">0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, </span><br><span class="line">0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, </span><br><span class="line">0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, </span><br><span class="line">0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, </span><br><span class="line">0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, </span><br><span class="line">0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, </span><br><span class="line">0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, </span><br><span class="line">0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, </span><br><span class="line">0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, </span><br><span class="line">0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, </span><br><span class="line">0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, </span><br><span class="line">0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, </span><br><span class="line">0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, </span><br><span class="line">0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, </span><br><span class="line">0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, </span><br><span class="line">0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, </span><br><span class="line">0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, </span><br><span class="line">0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, </span><br><span class="line">0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, </span><br><span class="line">0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, </span><br><span class="line">0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, </span><br><span class="line">0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, </span><br><span class="line">0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, </span><br><span class="line">0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d</span><br><span class="line">&#125;;</span><br><span class="line">int crc32(String key, int hash) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (hash=key.length(), i=0; i&lt;key.length(); ++i)</span><br><span class="line">        hash = (hash &gt;&gt; 8) ^ crctab[(hash &amp; 0xff) ^ k.charAt(i)];</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查表Hash中有名的样例有：Universal Hashing和Zobrist Hashing。他们的表格都是随机生成的。</p><h2 id="6-混合Hash"><a href="#6-混合Hash" class="headerlink" title="6. 混合Hash"></a>6. 混合Hash</h2><p>混合Hash算法利用了以上各种方式。各种常见的Hash算法，比如MD5、Tiger都属于这个范围。它们一般很少在面向查找的Hash函数里面使用。</p><h2 id="7-数组Hash"><a href="#7-数组Hash" class="headerlink" title="7. 数组Hash"></a>7. 数组Hash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline int hashcode(const int *v) &#123;</span><br><span class="line">    int s = 0;</span><br><span class="line">    for(int i=0; i&lt;k; i++)</span><br><span class="line">        s=((s&lt;&lt;2)+(v[i]&gt;&gt;4))^(v[i]&lt;&lt;10);</span><br><span class="line">    s = s % M;</span><br><span class="line">    s = s &lt; 0 ? s + M : s;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、碰撞"><a href="#五、碰撞" class="headerlink" title="五、碰撞"></a>五、碰撞</h1><p>通过前面说到的几种Hash算法的实现，我们可以发现，Hash算法虽然很多好，但是无法保证两个片段产生的Hash值不能重复。Hash算法产生冲突的情况，称之为Hash冲突，也称之为Hash碰撞。</p><p>通过构造性能良好的Hash算法，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是Hash算法的另一个关键问题。目前解决Hash冲突的主流方法大概有以下几种：</p><h2 id="1-开放寻址法-再散列法"><a href="#1-开放寻址法-再散列法" class="headerlink" title="1. 开放寻址法(再散列法)"></a>1. 开放寻址法(再散列法)</h2><p>开放寻址法的基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：</p><p>Hi=（H（key）+di）% m i=1，2，…，n</p><p>其中H（key）为哈希函数，m 为表长，di称为增量序列。</p><h2 id="2-再哈希法"><a href="#2-再哈希法" class="headerlink" title="2. 再哈希法"></a>2. 再哈希法</h2><p>这种方法的基本思想是：同时构造多个不同的哈希函数：</p><p>Hi=RH1（key） i=1，2，…，k</p><p>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p><h2 id="3-链地址法（拉链法）"><a href="#3-链地址法（拉链法）" class="headerlink" title="3. 链地址法（拉链法）"></a>3. 链地址法（拉链法）</h2><p>这种方法的基本思想是：将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p><h2 id="4-建立公共溢出区"><a href="#4-建立公共溢出区" class="headerlink" title="4. 建立公共溢出区"></a>4. 建立公共溢出区</h2><p>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p><p>目前用的比较多的就是 <strong>开放寻址法</strong> 和 <strong>拉链法</strong> ,针对 开放寻址法 和 拉链法 其具体的优缺点如下：</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><ul><li>优点：</li></ul><p>1.避免了动态调整的开销</p><p>2.由于底层是链表结构，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了</p><p>3.同样也是因为链表结构，删除记录时，比较方便，直接通过指针操作即可</p><ul><li>缺点：</li></ul><p>1.由于链表结构，所以查询比较耗时</p><p>2.由于链表结构，不利于序列化操作</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><ul><li>优点</li></ul><p>1.记录更容易进行序列化（serialize）操作</p><ul><li>缺点</li></ul><p>1.存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升</p><p>2.使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低</p><p>3.由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费</p><p>4.删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。</p><p><strong>总结：拉链法适合数据量不可预知，且写入多，查询少的情况。开放寻址法适合数据量可预知，查询多，写入少的情况。</strong></p><p>在传统的JDK中，采用的都是拉链法，自JDK1.8起，对拉链法做了改造。当链表长度超过预定值后将采用红黑树结构替代链表结构，这样对查询操作做了更好的优化。具体可参考我之前写的关于HashMap的文章 <a href="/2018/07/30/Java集合-0——HashMap类/">Java集合-0——HashMap类</a></p><p><strong>PS: 文中对Hash算法实现的代码均源于网络，若有侵权，请联系删除 <a href="https://blog.csdn.net/tanga842428/article/details/79850832" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></strong></p></div><div class="post-copyright"><div class="author"><b>本文作者：</b> <span>张未</span></div><div class="link"><b>本文链接：</b> <a href="https://blog.weechang.xyz/2018/10/19/hash/" target="_blank">https://blog.weechang.xyz/2018/10/19/hash/</a></div><div class="copyright"><b>版权声明：</b> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</div></div><footer class="article-footer"><div class="article-tag"><i class="fas fa-tag"></i> <a class="tag-link" href="/tags/哈希算法/">哈希算法</a>, <a class="tag-link" href="/tags/算法/">算法</a></div><div class="share-container"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more">分享到：</a> <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间">QQ空间</a> <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博">新浪微博</a> <a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博">腾讯微博</a> <a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网">人人网</a> <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信">微信</a></div><script>with(window._bd_share_config={common:{bdSnsKey:{},bdText:"",bdMini:"2",bdMiniList:!1,bdPic:"",bdStyle:"0",bdSize:"16"},share:{bdSize:16}},document)(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="https://blog.weechang.xyz/static/api/js/share.js?v=89860593.js?cdnversion="+~(-new Date/36e5)</script><style>.bdshare_popup_box{border-radius:4px;border:#e1e1e1 solid 1px}.bdshare-button-style0-16 .bds_more,.bdshare-button-style0-16 a{padding-left:20px;margin:6px 10px 6px 0}.bdshare_dialog_list a,.bdshare_popup_bottom a,.bdshare_popup_list a{font-family:'Microsoft Yahei'}.bdshare_popup_top{display:none}.bdshare_popup_bottom{height:auto;padding:5px}</style></div></footer></div><nav id="article-nav"><a href="/2018/10/22/windows-java-wifi/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">上一篇</strong><div class="article-nav-title">如何在Windows平台用Java代码暴力破解WIFI密码</div></a><a href="/2018/10/03/java-thread-03-synchronized/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">下一篇</strong><div class="article-nav-title">【Java学习之从头开始】Java多线程-3——synchronized是如何工作的</div></a></nav></article><section id="comments"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script type="text/javascript">var gitalk=new Gitalk({clientID:"295b369cd27d90dc5cfc",clientSecret:"23a308db213cd99742ff3e07da9021b9c5909b68",repo:"weechang.github.io",owner:"weechang",admin:["weechang"],id:"哈希算法究竟是个什么鬼"});gitalk.render("gitalk-container")</script></section></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">专题内容</h3><div class="widget"><ul id="topics"><li><a href="/topic/AxonFramework-内容汇总">AxonFramework-内容汇总</a></li><li><a href="/topic/Java学习之从头开始">Java学习之从头开始</a></li><li><a href="/topic/java-design-patterns">Java设计模式</a></li><li><a href="/topic/Hexo博客">Hexo博客</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">分类</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AxonFramework/">AxonFramework</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java多线程/">Java多线程</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java集合/">Java集合</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开源之路/">开源之路</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/日常记录/">日常记录</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法与数据结构/">算法与数据结构</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">标签云</h3><div class="widget tagcloud"><a href="/tags/AxonFramework/" style="font-size:20px">AxonFramework</a> <a href="/tags/ElasticSearch/" style="font-size:10px">ElasticSearch</a> <a href="/tags/FastJson高危漏洞/" style="font-size:10px">FastJson高危漏洞</a> <a href="/tags/GitHub-Pages/" style="font-size:10px">GitHub Pages</a> <a href="/tags/HashMap/" style="font-size:10px">HashMap</a> <a href="/tags/HashTable/" style="font-size:10px">HashTable</a> <a href="/tags/Hexo博客/" style="font-size:14px">Hexo博客</a> <a href="/tags/IDEA永久激活/" style="font-size:10px">IDEA永久激活</a> <a href="/tags/Java/" style="font-size:18px">Java</a> <a href="/tags/Java基础/" style="font-size:12px">Java基础</a> <a href="/tags/Java多线程/" style="font-size:16px">Java多线程</a> <a href="/tags/Java集合/" style="font-size:12px">Java集合</a> <a href="/tags/Jpa/" style="font-size:10px">Jpa</a> <a href="/tags/Jsoup/" style="font-size:10px">Jsoup</a> <a href="/tags/MySql/" style="font-size:10px">MySql</a> <a href="/tags/Object/" style="font-size:10px">Object</a> <a href="/tags/Sql/" style="font-size:10px">Sql</a> <a href="/tags/String/" style="font-size:10px">String</a> <a href="/tags/WebStorm永久激活/" style="font-size:10px">WebStorm永久激活</a> <a href="/tags/apm/" style="font-size:10px">apm</a> <a href="/tags/hexo插件/" style="font-size:10px">hexo插件</a> <a href="/tags/maven中央仓库/" style="font-size:10px">maven中央仓库</a> <a href="/tags/oshi/" style="font-size:10px">oshi</a> <a href="/tags/动态查询/" style="font-size:10px">动态查询</a> <a href="/tags/哈希算法/" style="font-size:10px">哈希算法</a> <a href="/tags/手把手教学/" style="font-size:12px">手把手教学</a> <a href="/tags/日常记录/" style="font-size:14px">日常记录</a> <a href="/tags/爬虫/" style="font-size:10px">爬虫</a> <a href="/tags/版权/" style="font-size:10px">版权</a> <a href="/tags/破解WIFI/" style="font-size:10px">破解WIFI</a> <a href="/tags/算法/" style="font-size:10px">算法</a></div></div><div class="widget-wrap widget-list"><h3 class="widget-title">链接</h3><div class="widget"><ul><li><a href="https://blog.unknowns.info/" target="_blank">披着前端的皮</a></li><li><a href="https://yanhaijing.com/yan_about/" target="_blank">颜海镜</a></li></ul></div></div><div id="toTop" class="fas fa-angle-up"></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2019 张未<br>Hosted by <a target="_blank" href="https://pages.coding.me" style="font-weight:700" rel="external nofollow noopener noreferrer">Coding Pages</a>. Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme by <a target="_blank" href="http://github.com/ppoffice" rel="external nofollow noopener noreferrer">PPOffice</a></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div>本站访问量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次 | 本站访客<span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人</div></div></footer><script src="/libs/lightgallery/js/lightgallery.min.js"></script><script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script><script src="/libs/lightgallery/js/lg-pager.min.js"></script><script src="/libs/lightgallery/js/lg-autoplay.min.js"></script><script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script><script src="/libs/lightgallery/js/lg-zoom.min.js"></script><script src="/libs/lightgallery/js/lg-hash.min.js"></script><script src="/libs/lightgallery/js/lg-share.min.js"></script><script src="/libs/lightgallery/js/lg-video.min.js"></script><script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="/js/main.js"></script><script src="/libs/google-code-prettify/prettify.js"></script><script type="text/javascript">$(document).ready(function(){$("pre").addClass("prettyprint"),prettyPrint()})</script></div></body>